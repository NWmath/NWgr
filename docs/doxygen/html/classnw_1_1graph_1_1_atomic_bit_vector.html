<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NWGraph: nw::graph::AtomicBitVector&lt; Word &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NWGraph
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nw</b></li><li class="navelem"><b>graph</b></li><li class="navelem"><a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html">AtomicBitVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnw_1_1graph_1_1_atomic_bit_vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">nw::graph::AtomicBitVector&lt; Word &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_atomic_bit_vector_8hpp_source.html">AtomicBitVector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector_1_1non__zero__iterator.html">non_zero_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector_1_1non__zero__range.html">non_zero_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac00d79ade20bf2e720aa4b1ac5f66b99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html#ac00d79ade20bf2e720aa4b1ac5f66b99">AtomicBitVector</a> (std::size_t bits, bool init=true)</td></tr>
<tr class="separator:ac00d79ade20bf2e720aa4b1ac5f66b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b078731ae92a19ec7389b4b08839aa0"><td class="memItemLeft" align="right" valign="top"><a id="a6b078731ae92a19ec7389b4b08839aa0" name="a6b078731ae92a19ec7389b4b08839aa0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~AtomicBitVector</b> ()</td></tr>
<tr class="memdesc:a6b078731ae92a19ec7389b4b08839aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the bitmap. <br /></td></tr>
<tr class="separator:a6b078731ae92a19ec7389b4b08839aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfbf00b7d121f7d462c161f71e2f69d"><td class="memItemLeft" align="right" valign="top"><a id="afdfbf00b7d121f7d462c161f71e2f69d" name="afdfbf00b7d121f7d462c161f71e2f69d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomicBitVector</b> (<a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html">AtomicBitVector</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:afdfbf00b7d121f7d462c161f71e2f69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move constructor needs to be explicit. <br /></td></tr>
<tr class="separator:afdfbf00b7d121f7d462c161f71e2f69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af178276b4a0b8c3581853caaa3a357be"><td class="memItemLeft" align="right" valign="top"><a id="af178276b4a0b8c3581853caaa3a357be" name="af178276b4a0b8c3581853caaa3a357be"></a>
<a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html">AtomicBitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html">AtomicBitVector</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:af178276b4a0b8c3581853caaa3a357be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move assignment operator needs to be explicit. <br /></td></tr>
<tr class="separator:af178276b4a0b8c3581853caaa3a357be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f2f9f688910e6ec842382398b67163"><td class="memItemLeft" align="right" valign="top"><a id="ae6f2f9f688910e6ec842382398b67163" name="ae6f2f9f688910e6ec842382398b67163"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:ae6f2f9f688910e6ec842382398b67163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the bitmap. <br /></td></tr>
<tr class="separator:ae6f2f9f688910e6ec842382398b67163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bc0b796e66d42abbab4aa60dad5a2d"><td class="memTemplParams" colspan="2">template&lt;std::memory_order order = std::memory_order_relaxed&gt; </td></tr>
<tr class="memitem:a23bc0b796e66d42abbab4aa60dad5a2d"><td class="memTemplItemLeft" align="right" valign="top">Word&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html#a23bc0b796e66d42abbab4aa60dad5a2d">get</a> (std::size_t i) const</td></tr>
<tr class="separator:a23bc0b796e66d42abbab4aa60dad5a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e4df43dca8844ca3c6969f294ce24d"><td class="memTemplParams" colspan="2">template&lt;std::memory_order order = std::memory_order_relaxed&gt; </td></tr>
<tr class="memitem:a59e4df43dca8844ca3c6969f294ce24d"><td class="memTemplItemLeft" align="right" valign="top">Word&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html#a59e4df43dca8844ca3c6969f294ce24d">set</a> (std::size_t i)</td></tr>
<tr class="separator:a59e4df43dca8844ca3c6969f294ce24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf44e7fbc7185570e495d8d34d28248"><td class="memItemLeft" align="right" valign="top">Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html#adaf44e7fbc7185570e495d8d34d28248">atomic_get</a> (std::size_t i) const</td></tr>
<tr class="separator:adaf44e7fbc7185570e495d8d34d28248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc0f928fbf09c9a33ec3bf472e19e72"><td class="memItemLeft" align="right" valign="top">Word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html#acfc0f928fbf09c9a33ec3bf472e19e72">atomic_set</a> (std::size_t i)</td></tr>
<tr class="separator:acfc0f928fbf09c9a33ec3bf472e19e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34261679626a81c24c6e57f95f1bfd47"><td class="memItemLeft" align="right" valign="top"><a id="a34261679626a81c24c6e57f95f1bfd47" name="a34261679626a81c24c6e57f95f1bfd47"></a>
<a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector_1_1non__zero__iterator.html">non_zero_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a34261679626a81c24c6e57f95f1bfd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1c2f1300d994042e223e8ad1d5e410"><td class="memItemLeft" align="right" valign="top"><a id="a9c1c2f1300d994042e223e8ad1d5e410" name="a9c1c2f1300d994042e223e8ad1d5e410"></a>
<a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector_1_1non__zero__iterator.html">non_zero_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a9c1c2f1300d994042e223e8ad1d5e410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa759a128c05719222407338ff8d146bc"><td class="memItemLeft" align="right" valign="top"><a id="aa759a128c05719222407338ff8d146bc" name="aa759a128c05719222407338ff8d146bc"></a>
<a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector_1_1non__zero__range.html">non_zero_range</a>&#160;</td><td class="memItemRight" valign="bottom"><b>non_zeros</b> (std::size_t cutoff)</td></tr>
<tr class="separator:aa759a128c05719222407338ff8d146bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Word = std::uint64_t&gt;<br />
class nw::graph::AtomicBitVector&lt; Word &gt;</div><p >Really basic concurrent bit vector for use as a bitmap.</p>
<p >This bitmap supports a simple get/set API, where set operations are always implemented using acquire/release, while get operations can either be acquire or relaxed. Though simple to provide, resetting, clearing, and resizing are not supported as those operations are not currently needed in BGL17.</p>
<p >Ideally this data structure or something equivalent would be provided by the standard library in the future. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac00d79ade20bf2e720aa4b1ac5f66b99" name="ac00d79ade20bf2e720aa4b1ac5f66b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00d79ade20bf2e720aa4b1ac5f66b99">&#9670;&nbsp;</a></span>AtomicBitVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word  = std::uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html">nw::graph::AtomicBitVector</a>&lt; Word &gt;::AtomicBitVector </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Allocate a bitmap.</p>
<p >The bitmap bits can be allocated in an uninitialized state, which can lead to simpler code in some algorithms that would like to avoid initialization on some code paths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>The number of bits to allocate. </td></tr>
    <tr><td class="paramname">init</td><td>If true, we'll initialize the bitmap data to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adaf44e7fbc7185570e495d8d34d28248" name="adaf44e7fbc7185570e495d8d34d28248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf44e7fbc7185570e495d8d34d28248">&#9670;&nbsp;</a></span>atomic_get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word  = std::uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word <a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html">nw::graph::AtomicBitVector</a>&lt; Word &gt;::atomic_get </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get a bit from the vector.</p>
<p >This forwards to the get operation with a stronger memory model and is safe for use in concurrent regions of code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The bit to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The masked value of the word containing the bit. </dd></dl>

</div>
</div>
<a id="acfc0f928fbf09c9a33ec3bf472e19e72" name="acfc0f928fbf09c9a33ec3bf472e19e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc0f928fbf09c9a33ec3bf472e19e72">&#9670;&nbsp;</a></span>atomic_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word  = std::uint64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word <a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html">nw::graph::AtomicBitVector</a>&lt; Word &gt;::atomic_set </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set a bit in the vector.</p>
<p >This forward to the set operation with a stronger memory model and is safe to use in concurrent regions of code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The bit to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The masked value of the word containing the bit prior to the set operation. </dd></dl>

</div>
</div>
<a id="a23bc0b796e66d42abbab4aa60dad5a2d" name="a23bc0b796e66d42abbab4aa60dad5a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bc0b796e66d42abbab4aa60dad5a2d">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word  = std::uint64_t&gt; </div>
<div class="memtemplate">
template&lt;std::memory_order order = std::memory_order_relaxed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word <a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html">nw::graph::AtomicBitVector</a>&lt; Word &gt;::get </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get a bit from the vector.</p>
<p >This reads a single bit from the vector, but for performance reasons it returns the bit un-shifted in a word. This word can be used in a boolean expression and the compiler will deal with efficiently testing it for 0.</p>
<p >By default it uses the memory_order_relaxed. This is not safe if there are ever concurrent set operations to the same underlying word, which can be hard to predict, and thus should mainly be used in sequential code. The <code>atomic_get</code> operation will propery synchronize with concurrent <code>atomic_set</code> operations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">order</td><td>The memory model for the load operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The bit to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The masked value of the word containing the bit. </dd></dl>

</div>
</div>
<a id="a59e4df43dca8844ca3c6969f294ce24d" name="a59e4df43dca8844ca3c6969f294ce24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e4df43dca8844ca3c6969f294ce24d">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word  = std::uint64_t&gt; </div>
<div class="memtemplate">
template&lt;std::memory_order order = std::memory_order_relaxed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Word <a class="el" href="classnw_1_1graph_1_1_atomic_bit_vector.html">nw::graph::AtomicBitVector</a>&lt; Word &gt;::set </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set a bit in the vector.</p>
<p >This sets a single bit in the vector, and returns the previous value of that bit as a masked word. This returned workd can be used in a boolean expression and the compiler will deal with efficiently testing it for 0.</p>
<p >By default it uses the memory_order_relaxed. This is not safe if there are ever concurrent set or get operations to the same underlying word, which can be hard to predict, and thus should be used only in sequential code. The <code>atomic_set</code> operation will properly synchronize with concurrent <code>atomic_get</code> and <code>atomic_set</code> operations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">order</td><td>The memory model for the load operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The bit to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The masked value of the word containing the bit prior to the set operation. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/lums/NWmath/NWgr/include/nwgraph/util/<a class="el" href="_atomic_bit_vector_8hpp_source.html">AtomicBitVector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
