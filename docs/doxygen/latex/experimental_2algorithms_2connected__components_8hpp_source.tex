\hypertarget{experimental_2algorithms_2connected__components_8hpp_source}{}\doxysection{connected\+\_\+components.\+hpp}
\label{experimental_2algorithms_2connected__components_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/experimental/algorithms/connected\_components.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/experimental/algorithms/connected\_components.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//     Xu Tony Liu  }}
\DoxyCodeLine{12 \textcolor{comment}{//}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#ifndef CONNECTED\_COMPONENT\_EXPERIMENTAL\_HPP}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#define CONNECTED\_COMPONENT\_EXPERIMENTAL\_HPP}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/bfs\_edge\_range.hpp"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/edge\_range.hpp"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/vertex\_range.hpp"{}}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}nwgraph/util/AtomicBitVector.hpp"{}}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/cyclic\_neighbor\_range.hpp"{}}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <atomic>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <unordered\_map>}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{preprocessor}{\#if defined(CL\_SYCL\_LANGUAGE\_VERSION)}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <dpstd/algorithm>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <dpstd/execution>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <execution>}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{36 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{37 }
\DoxyCodeLine{38 \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{39 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} writeMin(T\& old, T\& next) \{}
\DoxyCodeLine{40   T    prev;}
\DoxyCodeLine{41   \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false};}
\DoxyCodeLine{42   \textcolor{keywordflow}{do}}
\DoxyCodeLine{43     prev = old;}
\DoxyCodeLine{44   \textcolor{keywordflow}{while} (prev > next \&\& !(success = nw::graph::cas(old, prev, next)));}
\DoxyCodeLine{45   \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{46 \}}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{49 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} compare\_and\_swap(T\& x, T old\_val, T new\_val) \{}
\DoxyCodeLine{50   \textcolor{keywordflow}{return} \_\_sync\_bool\_compare\_and\_swap(\&x, *(\&old\_val), *(\&new\_val));}
\DoxyCodeLine{51 \}}
\DoxyCodeLine{52 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{53 \textcolor{keyword}{struct }\mbox{\hyperlink{structnw_1_1graph_1_1atomwrapper}{atomwrapper}} \{}
\DoxyCodeLine{54   std::atomic<T> \_a;}
\DoxyCodeLine{55 }
\DoxyCodeLine{56   \mbox{\hyperlink{structnw_1_1graph_1_1atomwrapper}{atomwrapper}}() : \_a() \{\}}
\DoxyCodeLine{57 }
\DoxyCodeLine{58   \mbox{\hyperlink{structnw_1_1graph_1_1atomwrapper}{atomwrapper}}(\textcolor{keyword}{const} std::atomic<T>\& a) : \_a(a.load()) \{\}}
\DoxyCodeLine{59 }
\DoxyCodeLine{60   \mbox{\hyperlink{structnw_1_1graph_1_1atomwrapper}{atomwrapper}}(\textcolor{keyword}{const} \mbox{\hyperlink{structnw_1_1graph_1_1atomwrapper}{atomwrapper}}\& other) : \_a(other.\_a.load()) \{\}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62   \mbox{\hyperlink{structnw_1_1graph_1_1atomwrapper}{atomwrapper}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{structnw_1_1graph_1_1atomwrapper}{atomwrapper}}\& other) \{}
\DoxyCodeLine{63     \_a.store(other.\_a.load());}
\DoxyCodeLine{64     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{65   \}}
\DoxyCodeLine{66 \};}
\DoxyCodeLine{67 }
\DoxyCodeLine{68 \textcolor{comment}{// BFS-\/based connected component algorithm}}
\DoxyCodeLine{69 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{70 \textcolor{keywordtype}{void} compute\_connected\_components(Graph\& A, std::vector<T>\& component\_ids) \{}
\DoxyCodeLine{71   \textcolor{keywordtype}{size\_t}         N                        = A.size();}
\DoxyCodeLine{72   std::atomic<T> global\_component\_counter = -\/1;}
\DoxyCodeLine{73   std::for\_each(std::execution::par\_unseq, \mbox{\hyperlink{classnw_1_1graph_1_1counting__iterator}{counting\_iterator<T>}}(0), \mbox{\hyperlink{classnw_1_1graph_1_1counting__iterator}{counting\_iterator<T>}}(N), [\&](\textcolor{keyword}{auto} vtx) \{}
\DoxyCodeLine{74     \textcolor{keywordflow}{if} (std::numeric\_limits<T>::max() == component\_ids[vtx]) \{}
\DoxyCodeLine{75       global\_component\_counter++;}
\DoxyCodeLine{76       component\_ids[vtx] = global\_component\_counter.load();}
\DoxyCodeLine{77       \textcolor{comment}{//      std::cout << "{}-\/-\/-\/-\/-\/-\/-\/-\/vertex-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/"{} << vtx << "{}}}
\DoxyCodeLine{78       \textcolor{comment}{//      component\_ids[vtx]: "{} << component\_ids[vtx] << std::endl;}}
\DoxyCodeLine{79       \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3}{bfs\_edge\_range3}} ranges(A, vtx);}
\DoxyCodeLine{80       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ite = ranges.begin(); ite != ranges.end(); ++ite) \{}
\DoxyCodeLine{81         \textcolor{comment}{// auto u = std::get<0>(*ite);}}
\DoxyCodeLine{82         \textcolor{keyword}{auto} v = target(A, *ite);}
\DoxyCodeLine{83         \textcolor{comment}{//auto v           = std::get<1>(*ite);}}
\DoxyCodeLine{84         component\_ids[v] = global\_component\_counter.load();}
\DoxyCodeLine{85       \}}
\DoxyCodeLine{86     \}}
\DoxyCodeLine{87   \});}
\DoxyCodeLine{88 \}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{91 \textcolor{keywordtype}{void} hook(T u, T v, std::vector<T>\& comp) \{}
\DoxyCodeLine{92   T p1 = comp[u];}
\DoxyCodeLine{93   T p2 = comp[v];}
\DoxyCodeLine{94   T high, low;}
\DoxyCodeLine{95   \textcolor{keywordflow}{while} (p1 != p2) \{}
\DoxyCodeLine{96     high              = std::max(p1, p2);}
\DoxyCodeLine{97     low               = p1 + p2 -\/ high;}
\DoxyCodeLine{98     \textcolor{keyword}{volatile} T p\_high = comp[high];}
\DoxyCodeLine{99     \textcolor{keywordflow}{if} (p\_high == low || compare\_and\_swap(comp[high], high, low)) \textcolor{keywordflow}{break};}
\DoxyCodeLine{100     p1 = comp[comp[high]];}
\DoxyCodeLine{101     p2 = comp[low];}
\DoxyCodeLine{102   \}    \textcolor{comment}{// while}}
\DoxyCodeLine{103 \}}
\DoxyCodeLine{104 }
\DoxyCodeLine{105 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{106 \textcolor{keywordtype}{void} compress(std::vector<T>\& comp) \{}
\DoxyCodeLine{107   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(comp.size()), [\&](\textcolor{keyword}{auto} n) \{}
\DoxyCodeLine{108     while (comp[n] != comp[comp[n]])}
\DoxyCodeLine{109       comp[n] = comp[comp[n]];}
\DoxyCodeLine{110   \});}
\DoxyCodeLine{111 \}}
\DoxyCodeLine{112 }
\DoxyCodeLine{113 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{114 T findDominantComponentID(\textcolor{keyword}{const} std::vector<T>\& comp, \textcolor{keywordtype}{size\_t} nsamples = 1024) \{}
\DoxyCodeLine{115   \textcolor{keywordflow}{if} (0 == comp.size()) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{116   std::unordered\_map<T, size\_t>                              sample\_counts(32);}
\DoxyCodeLine{117   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::unordered\_map<T, size\_t>::value\_type kvp\_type;}
\DoxyCodeLine{118   std::mt19937                                               gen;}
\DoxyCodeLine{119   std::uniform\_int\_distribution<T>                           distribution(0, comp.size() -\/ 1);}
\DoxyCodeLine{120   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < nsamples; i++) \{}
\DoxyCodeLine{121     T n = distribution(gen);}
\DoxyCodeLine{122     ++sample\_counts[comp[n]];}
\DoxyCodeLine{123   \}}
\DoxyCodeLine{124   \textcolor{keyword}{auto} dominant =}
\DoxyCodeLine{125       std::max\_element(sample\_counts.begin(), sample\_counts.end(), [](\textcolor{keyword}{const} kvp\_type\& a, \textcolor{keyword}{const} kvp\_type\& b) \{ return a.second < b.second; \});}
\DoxyCodeLine{126   \textcolor{comment}{/*}}
\DoxyCodeLine{127 \textcolor{comment}{    float frac\_of\_graph = static\_cast<float>(dominant-\/>second) / nsamples;}}
\DoxyCodeLine{128 \textcolor{comment}{    std::cout}}
\DoxyCodeLine{129 \textcolor{comment}{      << "{}Skipping largest intermediate component (ID: "{} << dominant-\/>first}}
\DoxyCodeLine{130 \textcolor{comment}{      << "{}, approx. "{} << static\_cast<int>(frac\_of\_graph * 100)}}
\DoxyCodeLine{131 \textcolor{comment}{      << "{}\% of the graph)"{} << std::endl;}}
\DoxyCodeLine{132 \textcolor{comment}{  */}}
\DoxyCodeLine{133   \textcolor{keywordflow}{return} dominant-\/>first;}
\DoxyCodeLine{134 \}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{137 \textcolor{keywordtype}{void} push(\textcolor{keyword}{const} Graph\& g, \textcolor{keyword}{const} T u, std::vector<T>\& comp) \{}
\DoxyCodeLine{138   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} j = g[u].begin(); j != g[u].end(); ++j) \{}
\DoxyCodeLine{139     \textcolor{keyword}{auto} v = target(g, *j);}
\DoxyCodeLine{140     \textcolor{comment}{//auto v = std::get<0>(*j);}}
\DoxyCodeLine{141     hook(u, v, comp);}
\DoxyCodeLine{142   \}}
\DoxyCodeLine{143 \}}
\DoxyCodeLine{144 }
\DoxyCodeLine{145 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{146 \textcolor{keywordtype}{void} link(\textcolor{keyword}{const} Graph\& g, \textcolor{keyword}{const} T u, std::vector<T>\& comp, \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} neighbor\_bound) \{}
\DoxyCodeLine{147   \textcolor{keywordtype}{size\_t} i = 0;}
\DoxyCodeLine{148   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} j = g[u].begin(); j != g[u].end() \&\& i < neighbor\_bound; ++j, ++i) \{}
\DoxyCodeLine{149     \textcolor{keyword}{auto} v = target(g, *j);}
\DoxyCodeLine{150     hook(u, v, comp);}
\DoxyCodeLine{151   \}}
\DoxyCodeLine{152 \}}
\DoxyCodeLine{153 }
\DoxyCodeLine{154 \textcolor{comment}{// fetch the smallest comp\_id among u's neighbors}}
\DoxyCodeLine{155 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{156 \textcolor{keywordtype}{bool} pull(\textcolor{keyword}{const} Graph\& g, \textcolor{keyword}{const} T u, std::vector<T>\& comp) \{}
\DoxyCodeLine{157   T min\_compid = comp[u];}
\DoxyCodeLine{158   T v;}
\DoxyCodeLine{159   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} j = g[u].begin(); j != g[u].end(); ++j) \{}
\DoxyCodeLine{160     v          = target(g, *j);}
\DoxyCodeLine{161     \textcolor{comment}{//v          = std::get<0>(*j);}}
\DoxyCodeLine{162     min\_compid = std::min(min\_compid, comp[v]);}
\DoxyCodeLine{163   \}}
\DoxyCodeLine{164   \textcolor{keywordtype}{bool} change = \textcolor{keyword}{false};}
\DoxyCodeLine{165   T    p1     = comp[u];}
\DoxyCodeLine{166   T    p2     = min\_compid;}
\DoxyCodeLine{167   T    high = comp[u], low = min\_compid;}
\DoxyCodeLine{168   \textcolor{keywordflow}{while} (p1 != p2) \{}
\DoxyCodeLine{169     high              = std::max(p1, p2);}
\DoxyCodeLine{170     low               = p1 + p2 -\/ high;}
\DoxyCodeLine{171     \textcolor{keyword}{volatile} T p\_high = comp[high];}
\DoxyCodeLine{172     \textcolor{keywordflow}{if} (p\_high == low || compare\_and\_swap(comp[high], high, low)) \{}
\DoxyCodeLine{173       change = \textcolor{keyword}{true};}
\DoxyCodeLine{174       \textcolor{keywordflow}{break};}
\DoxyCodeLine{175     \}}
\DoxyCodeLine{176     p1 = comp[comp[high]];}
\DoxyCodeLine{177     p2 = comp[low];}
\DoxyCodeLine{178   \}    \textcolor{comment}{// while}}
\DoxyCodeLine{179   \textcolor{keywordflow}{return} change;}
\DoxyCodeLine{180 \}}
\DoxyCodeLine{181 }
\DoxyCodeLine{182 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T = vertex\_\textcolor{keywordtype}{id}\_t<Graph>>}
\DoxyCodeLine{183 std::vector<T> compute\_connected\_components\_v1(\textcolor{keyword}{const} Graph\& g) \{}
\DoxyCodeLine{184   \textcolor{keywordtype}{size\_t} N = g.size();}
\DoxyCodeLine{185   \textcolor{comment}{// std::vector<atomwrapper<T>> comp(N,}}
\DoxyCodeLine{186   \textcolor{comment}{// atomwrapper<T>(-\/1));}}
\DoxyCodeLine{187   std::vector<atomwrapper<T>> comp(N);}
\DoxyCodeLine{188 }
\DoxyCodeLine{189   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(N), [\&](\textcolor{keyword}{auto} n) \{ comp[n].\_a.store(n); \});}
\DoxyCodeLine{190 }
\DoxyCodeLine{191   \textcolor{keywordtype}{bool} change = \textcolor{keyword}{true};}
\DoxyCodeLine{192   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} num\_iter = 0; num\_iter < 2; ++num\_iter) \{}
\DoxyCodeLine{193     \textcolor{keywordflow}{if} (\textcolor{keyword}{false} == change) \{}
\DoxyCodeLine{194       std::cout << \textcolor{stringliteral}{"{}Shiloach-\/Vishkin took "{}} << num\_iter << \textcolor{stringliteral}{"{} iterations"{}} << std::endl;}
\DoxyCodeLine{195       \textcolor{keywordflow}{break};}
\DoxyCodeLine{196     \}}
\DoxyCodeLine{197     change = \textcolor{keyword}{false};}
\DoxyCodeLine{198     \textcolor{comment}{/*}}
\DoxyCodeLine{199 \textcolor{comment}{     * TODO bfs edge based parallel iterating over graph}}
\DoxyCodeLine{200 \textcolor{comment}{      bfs\_edge\_range3 range(g, 0);}}
\DoxyCodeLine{201 \textcolor{comment}{      auto first = range.begin();}}
\DoxyCodeLine{202 \textcolor{comment}{      auto last = range.end();}}
\DoxyCodeLine{203 \textcolor{comment}{      std::for\_each(}}
\DoxyCodeLine{204 \textcolor{comment}{    std::execution::par\_unseq,}}
\DoxyCodeLine{205 \textcolor{comment}{      first, last, [\&](auto\&\& ite) \{}}
\DoxyCodeLine{206 \textcolor{comment}{        auto u = std::get<0>(*ite);}}
\DoxyCodeLine{207 \textcolor{comment}{        auto v = std::get<1>(*ite);}}
\DoxyCodeLine{208 \textcolor{comment}{}}
\DoxyCodeLine{209 \textcolor{comment}{          if (v != comp[v].\_a.load()) return;}}
\DoxyCodeLine{210 \textcolor{comment}{          auto p1 = comp[u].\_a.load();}}
\DoxyCodeLine{211 \textcolor{comment}{          auto p2 = comp[v].\_a.load();}}
\DoxyCodeLine{212 \textcolor{comment}{          while (p1 != p2) \{}}
\DoxyCodeLine{213 \textcolor{comment}{            auto high = std::max(p1, p2);}}
\DoxyCodeLine{214 \textcolor{comment}{            auto low = p1 + p2 -\/ high;}}
\DoxyCodeLine{215 \textcolor{comment}{            auto p\_high = comp[high].\_a.load();}}
\DoxyCodeLine{216 \textcolor{comment}{            if (p\_high == low || comp[high].\_a.compare\_exchange\_weak(p\_high,}}
\DoxyCodeLine{217 \textcolor{comment}{    comp[low].\_a)) \{ change = true; break;}}
\DoxyCodeLine{218 \textcolor{comment}{            \}}}
\DoxyCodeLine{219 \textcolor{comment}{            high = comp[high].\_a.load();}}
\DoxyCodeLine{220 \textcolor{comment}{            p1 = comp[high].\_a.load();}}
\DoxyCodeLine{221 \textcolor{comment}{            p2 = comp[low].\_a.load();}}
\DoxyCodeLine{222 \textcolor{comment}{          \}}}
\DoxyCodeLine{223 \textcolor{comment}{        \});}}
\DoxyCodeLine{224 \textcolor{comment}{    */}}
\DoxyCodeLine{225     std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(N), [\&](\textcolor{keyword}{auto} u) \{}
\DoxyCodeLine{226       T v;}
\DoxyCodeLine{227       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} j = g[u].begin(); j != g[u].end(); ++j) \{}
\DoxyCodeLine{228         v = target(g, *j);}
\DoxyCodeLine{229         \textcolor{comment}{//v = std::get<0>(*j);}}
\DoxyCodeLine{230         \textcolor{comment}{//      if (v != comp[v].\_a.load()) continue;}}
\DoxyCodeLine{231         \textcolor{keyword}{auto} p1 = comp[u].\_a.load();}
\DoxyCodeLine{232         \textcolor{keyword}{auto} p2 = comp[v].\_a.load();}
\DoxyCodeLine{233         \textcolor{keywordflow}{while} (p1 != p2) \{}
\DoxyCodeLine{234           \textcolor{keyword}{auto} high   = std::max(p1, p2);}
\DoxyCodeLine{235           \textcolor{keyword}{auto} low    = p1 + p2 -\/ high;}
\DoxyCodeLine{236           \textcolor{keyword}{auto} p\_high = comp[high].\_a.load();}
\DoxyCodeLine{237           \textcolor{keywordflow}{if} (p\_high == low || comp[high].\_a.compare\_exchange\_weak(p\_high, comp[low].\_a)) \{}
\DoxyCodeLine{238             change = \textcolor{keyword}{true};}
\DoxyCodeLine{239             \textcolor{keywordflow}{break};}
\DoxyCodeLine{240           \}}
\DoxyCodeLine{241           high = comp[high].\_a.load();}
\DoxyCodeLine{242           p1   = comp[high].\_a.load();}
\DoxyCodeLine{243           p2   = comp[low].\_a.load();}
\DoxyCodeLine{244         \}    \textcolor{comment}{// while}}
\DoxyCodeLine{245       \}}
\DoxyCodeLine{246     \});}
\DoxyCodeLine{247   \}}
\DoxyCodeLine{248   std::vector<T> res(N);}
\DoxyCodeLine{249   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(N), [\&](\textcolor{keyword}{auto} n) \{}
\DoxyCodeLine{250     \textcolor{keyword}{auto} m = n;}
\DoxyCodeLine{251     \textcolor{comment}{//    while (comp[m].\_a.load() != m)  m = comp[m].\_a.load();}}
\DoxyCodeLine{252     \textcolor{keywordflow}{while} (comp[m].\_a.load() != comp[comp[m].\_a.load()].\_a.load()) \{}
\DoxyCodeLine{253       comp[m].\_a.store(comp[comp[m].\_a.load()].\_a.load());}
\DoxyCodeLine{254       m = comp[m].\_a.load();}
\DoxyCodeLine{255     \}}
\DoxyCodeLine{256     res[n] = comp[n].\_a.load();}
\DoxyCodeLine{257     \textcolor{comment}{// std::cout << n <<"{}:"{} <<  res[n] << std::endl;}}
\DoxyCodeLine{258     \textcolor{comment}{/*}}
\DoxyCodeLine{259 \textcolor{comment}{          atomwrapper<T> m(std::atomic<T>(n));}}
\DoxyCodeLine{260 \textcolor{comment}{          while ( comp[m.\_a.load()] != comp[comp[m.\_a.load()].\_a.load()]) \{}}
\DoxyCodeLine{261 \textcolor{comment}{            m.\_a.store(comp[m.\_a.load()]);}}
\DoxyCodeLine{262 \textcolor{comment}{          \}}}
\DoxyCodeLine{263 \textcolor{comment}{          res[n] = comp[m.\_a.load()].a\_.load();}}
\DoxyCodeLine{264 \textcolor{comment}{        */}}
\DoxyCodeLine{265   \});}
\DoxyCodeLine{266   \textcolor{comment}{// compress(comp);}}
\DoxyCodeLine{267   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{268 \}    \textcolor{comment}{// compute\_connected\_components\_v1}}
\DoxyCodeLine{269 }
\DoxyCodeLine{270 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T = vertex\_\textcolor{keywordtype}{id}\_t<Graph>>}
\DoxyCodeLine{271 std::vector<T> compute\_connected\_components\_v2(\textcolor{keyword}{const} Graph\& g) \{}
\DoxyCodeLine{272   \textcolor{keywordtype}{size\_t}         N = g.size();}
\DoxyCodeLine{273   std::vector<T> comp(g.size());}
\DoxyCodeLine{274   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} n) \{ comp[n] = n; \});}
\DoxyCodeLine{275 }
\DoxyCodeLine{276   \textcolor{keywordtype}{bool} change = \textcolor{keyword}{true};}
\DoxyCodeLine{277 }
\DoxyCodeLine{278   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} num\_iter = 0; num\_iter < 1; ++num\_iter) \{}
\DoxyCodeLine{279     \textcolor{keywordflow}{if} (\textcolor{keyword}{false} == change) \{}
\DoxyCodeLine{280       std::cout << \textcolor{stringliteral}{"{}PULL-\/cc took "{}} << num\_iter << \textcolor{stringliteral}{"{} iterations"{}} << std::endl;}
\DoxyCodeLine{281       \textcolor{keywordflow}{break};}
\DoxyCodeLine{282     \}}
\DoxyCodeLine{283     change = \textcolor{keyword}{false};}
\DoxyCodeLine{284 }
\DoxyCodeLine{285     std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(N), [\&](\textcolor{keyword}{auto} u) \{ change = pull(g, u, comp); \});}
\DoxyCodeLine{286     std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(N), [\&](\textcolor{keyword}{auto} u) \{ push(g, u, comp); \});}
\DoxyCodeLine{287 }
\DoxyCodeLine{288     compress(comp);}
\DoxyCodeLine{289   \}}
\DoxyCodeLine{290   \textcolor{keywordflow}{return} comp;}
\DoxyCodeLine{291 \}    \textcolor{comment}{// compute\_connected\_components\_v2}}
\DoxyCodeLine{292 }
\DoxyCodeLine{293 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T = vertex\_\textcolor{keywordtype}{id}\_t<Graph>>}
\DoxyCodeLine{294 std::vector<T> ccv1(\textcolor{keyword}{const} Graph\& g) \{}
\DoxyCodeLine{295   std::vector<T> comp(g.size());}
\DoxyCodeLine{296   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} n) \{ comp[n] = n; \});}
\DoxyCodeLine{297 }
\DoxyCodeLine{298   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} u) \{ push(g, u, comp); \});}
\DoxyCodeLine{299   compress(comp);}
\DoxyCodeLine{300   \textcolor{keywordflow}{return} comp;}
\DoxyCodeLine{301 \}}
\DoxyCodeLine{302 }
\DoxyCodeLine{303 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Execution, adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T = vertex\_\textcolor{keywordtype}{id}\_t<Graph>>}
\DoxyCodeLine{304 std::vector<T> lpcc(Execution\& exec, Graph\& g, \textcolor{keywordtype}{int} num\_bins = 32) \{}
\DoxyCodeLine{305   \textcolor{comment}{//nw::util::life\_timer \_(\_\_func\_\_);}}
\DoxyCodeLine{306   \textcolor{keywordtype}{size\_t}     num\_nodes = g.size();}
\DoxyCodeLine{307   std::vector<T> comp(num\_nodes);}
\DoxyCodeLine{308   \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}}   visited(num\_nodes);}
\DoxyCodeLine{309   std::vector<T> cur(num\_nodes), next;}
\DoxyCodeLine{310   std::for\_each(exec,}
\DoxyCodeLine{311   counting\_iterator<T>(0), counting\_iterator<T>(num\_nodes), [\&](\textcolor{keyword}{auto} n) \{ }
\DoxyCodeLine{312     comp[n] = n;}
\DoxyCodeLine{313     cur[n] = n;}
\DoxyCodeLine{314   \});}
\DoxyCodeLine{315 }
\DoxyCodeLine{316   std::vector<T> frontier[num\_bins];}
\DoxyCodeLine{317   \textcolor{keyword}{auto} propagate = [\&](\textcolor{keyword}{auto}\& g, \textcolor{keyword}{auto}\& cur, \textcolor{keyword}{auto}\& bitmap, \textcolor{keyword}{auto}\& labels) \{}
\DoxyCodeLine{318     tbb::parallel\_for(tbb::blocked\_range<T>(0ul, cur.size()), [\&](tbb::blocked\_range<T>\& r) \{}
\DoxyCodeLine{319       int worker\_index = tbb::this\_task\_arena::current\_thread\_index();}
\DoxyCodeLine{320       for (auto i = r.begin(), e = r.end(); i < e; ++i) \{}
\DoxyCodeLine{321         auto x = cur[i];}
\DoxyCodeLine{322         auto labelx = labels[x];}
\DoxyCodeLine{323         \textcolor{comment}{//all neighbors of hyperedges are hypernode, vice versa}}
\DoxyCodeLine{324         std::for\_each(g[x].begin(), g[x].end(), [\&](auto \&\&j) \{}
\DoxyCodeLine{325           auto y = std::get<0>(j);}
\DoxyCodeLine{326           if (labelx < labels[y]) \{}
\DoxyCodeLine{327             if (writeMin(labels[y], labelx)) \{}
\DoxyCodeLine{328               if (0 == bitmap.atomic\_get(y) \&\& 0 == bitmap.atomic\_set(y))}
\DoxyCodeLine{329                 frontier[worker\_index].push\_back(y);}
\DoxyCodeLine{330             \}}
\DoxyCodeLine{331           \}}
\DoxyCodeLine{332         \});}
\DoxyCodeLine{333       \} \textcolor{comment}{//for}}
\DoxyCodeLine{334     \}, tbb::auto\_partitioner());}
\DoxyCodeLine{335   \};}
\DoxyCodeLine{336   std::vector<size\_t> size\_array(num\_bins);}
\DoxyCodeLine{337   \textcolor{keyword}{auto} curtonext = [\&](\textcolor{keyword}{auto}\& next) \{}
\DoxyCodeLine{338     \textcolor{keywordtype}{size\_t} size = 0;}
\DoxyCodeLine{339     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_bins; ++i) \{}
\DoxyCodeLine{340       \textcolor{comment}{//calculate the size of each thread-\/local frontier}}
\DoxyCodeLine{341       size\_array[i] = size;}
\DoxyCodeLine{342       \textcolor{comment}{//accumulate the total size of all thread-\/local frontiers}}
\DoxyCodeLine{343       size += frontier[i].size();}
\DoxyCodeLine{344     \}}
\DoxyCodeLine{345     \textcolor{comment}{//resize next frontier}}
\DoxyCodeLine{346     next.resize(size); }
\DoxyCodeLine{347     std::for\_each(exec, counting\_iterator(0), counting\_iterator(num\_bins), [\&](\textcolor{keyword}{auto} i) \{}
\DoxyCodeLine{348       \textcolor{comment}{//copy each thread-\/local frontier to next frontier based on their size offset}}
\DoxyCodeLine{349       \textcolor{keyword}{auto} begin = std::next(next.begin(), size\_array[i]);}
\DoxyCodeLine{350       std::copy(exec, frontier[i].begin(), frontier[i].end(), begin);}
\DoxyCodeLine{351       frontier[i].clear();}
\DoxyCodeLine{352     \});}
\DoxyCodeLine{353   \};}
\DoxyCodeLine{354   \textcolor{keywordflow}{while} (!cur.empty()) \{}
\DoxyCodeLine{355     propagate(g, cur, visited, comp);}
\DoxyCodeLine{356     curtonext(next);}
\DoxyCodeLine{357     visited.clear();}
\DoxyCodeLine{358     cur.clear();}
\DoxyCodeLine{359     cur.swap(next);}
\DoxyCodeLine{360   \} \textcolor{comment}{//while}}
\DoxyCodeLine{361 }
\DoxyCodeLine{362   \textcolor{keywordflow}{return} comp;}
\DoxyCodeLine{363 \}}
\DoxyCodeLine{364 }
\DoxyCodeLine{365 }
\DoxyCodeLine{366 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Execution, adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T = vertex\_\textcolor{keywordtype}{id}\_t<Graph>>}
\DoxyCodeLine{367 std::vector<T> lpcc\_cyclic(Execution\& exec, Graph\& g, \textcolor{keywordtype}{int} num\_bins = 32) \{}
\DoxyCodeLine{368   \textcolor{comment}{//nw::util::life\_timer \_(\_\_func\_\_);}}
\DoxyCodeLine{369   \textcolor{keywordtype}{size\_t}     num\_nodes = g.size();}
\DoxyCodeLine{370   std::vector<T> comp(num\_nodes);}
\DoxyCodeLine{371   \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}}   visited(num\_nodes);}
\DoxyCodeLine{372   std::vector<T> cur(num\_nodes), next;}
\DoxyCodeLine{373   std::for\_each(exec,}
\DoxyCodeLine{374   counting\_iterator<T>(0), counting\_iterator<T>(num\_nodes), [\&](\textcolor{keyword}{auto} n) \{ }
\DoxyCodeLine{375     comp[n] = n;}
\DoxyCodeLine{376     cur[n] = n;}
\DoxyCodeLine{377   \});}
\DoxyCodeLine{378 }
\DoxyCodeLine{379   std::vector<T> frontier[num\_bins];}
\DoxyCodeLine{380   \textcolor{keyword}{auto} propagate = [\&](\textcolor{keyword}{auto}\& g, \textcolor{keyword}{auto}\& cur, \textcolor{keyword}{auto}\& bitmap, \textcolor{keyword}{auto}\& labels) \{}
\DoxyCodeLine{381     tbb::parallel\_for(cyclic\_neighbor\_range(g, num\_bins), [\&](\textcolor{keyword}{auto}\& i) \{}
\DoxyCodeLine{382       \textcolor{keywordtype}{int} worker\_index = tbb::this\_task\_arena::current\_thread\_index();}
\DoxyCodeLine{383       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& j = i.begin(); j != i.end(); ++j) \{}
\DoxyCodeLine{384         \textcolor{keyword}{auto}\&\& [x, x\_ngh] = *j;}
\DoxyCodeLine{385         \textcolor{keyword}{auto} labelx = labels[x];}
\DoxyCodeLine{386         \textcolor{comment}{//all neighbors of hyperedges are hypernode, vice versa}}
\DoxyCodeLine{387         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \&\&[y] : x\_ngh) \{}
\DoxyCodeLine{388           \textcolor{keywordflow}{if} (labelx < labels[y]) \{}
\DoxyCodeLine{389             \textcolor{keywordflow}{if} (writeMin(labels[y], labelx)) \{}
\DoxyCodeLine{390               \textcolor{keywordflow}{if} (0 == bitmap.atomic\_get(y) \&\& 0 == bitmap.atomic\_set(y))}
\DoxyCodeLine{391                 frontier[worker\_index].push\_back(y);}
\DoxyCodeLine{392             \}}
\DoxyCodeLine{393           \}}
\DoxyCodeLine{394         \}\textcolor{comment}{//for each neighbor}}
\DoxyCodeLine{395       \} \textcolor{comment}{//for}}
\DoxyCodeLine{396     \}, tbb::auto\_partitioner());}
\DoxyCodeLine{397   \};}
\DoxyCodeLine{398   std::vector<size\_t> size\_array(num\_bins);}
\DoxyCodeLine{399   \textcolor{keyword}{auto} curtonext = [\&](\textcolor{keyword}{auto}\& next) \{}
\DoxyCodeLine{400     \textcolor{keywordtype}{size\_t} size = 0;}
\DoxyCodeLine{401     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_bins; ++i) \{}
\DoxyCodeLine{402       \textcolor{comment}{//calculate the size of each thread-\/local frontier}}
\DoxyCodeLine{403       size\_array[i] = size;}
\DoxyCodeLine{404       \textcolor{comment}{//accumulate the total size of all thread-\/local frontiers}}
\DoxyCodeLine{405       size += frontier[i].size();}
\DoxyCodeLine{406     \}}
\DoxyCodeLine{407     \textcolor{comment}{//resize next frontier}}
\DoxyCodeLine{408     next.resize(size); }
\DoxyCodeLine{409     std::for\_each(exec, counting\_iterator(0), counting\_iterator(num\_bins), [\&](\textcolor{keyword}{auto} i) \{}
\DoxyCodeLine{410       \textcolor{comment}{//copy each thread-\/local frontier to next frontier based on their size offset}}
\DoxyCodeLine{411       \textcolor{keyword}{auto} begin = std::next(next.begin(), size\_array[i]);}
\DoxyCodeLine{412       std::copy(exec, frontier[i].begin(), frontier[i].end(), begin);}
\DoxyCodeLine{413       frontier[i].clear();}
\DoxyCodeLine{414     \});}
\DoxyCodeLine{415   \};}
\DoxyCodeLine{416   \textcolor{keywordflow}{while} (!cur.empty()) \{}
\DoxyCodeLine{417     propagate(g, cur, visited, comp);}
\DoxyCodeLine{418     curtonext(next);}
\DoxyCodeLine{419     visited.clear();}
\DoxyCodeLine{420     cur.clear();}
\DoxyCodeLine{421     cur.swap(next);}
\DoxyCodeLine{422   \} \textcolor{comment}{//while}}
\DoxyCodeLine{423 }
\DoxyCodeLine{424   \textcolor{keywordflow}{return} comp;}
\DoxyCodeLine{425 \}}
\DoxyCodeLine{426 }
\DoxyCodeLine{427 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, adjacency\_list\_graph Graph2, \textcolor{keyword}{typename} T = vertex\_\textcolor{keywordtype}{id}\_t<Graph>>}
\DoxyCodeLine{428 std::vector<T> Afforest(\textcolor{keyword}{const} Graph\& g, Graph2\& t\_graph, \textcolor{keywordtype}{size\_t} neighbor\_bound = 2) \{}
\DoxyCodeLine{429   std::vector<T> comp(g.size());}
\DoxyCodeLine{430   \textcolor{comment}{// set component id of vertex v to v}}
\DoxyCodeLine{431   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} n) \{ comp[n] = n; \});}
\DoxyCodeLine{432   \textcolor{comment}{// approximate the dominant component by linking certain neighbors of each}}
\DoxyCodeLine{433   \textcolor{comment}{// vertex v (a sparse subgraph)}}
\DoxyCodeLine{434   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()),}
\DoxyCodeLine{435                 [\&](\textcolor{keyword}{auto} u) \{ link(g, u, comp, neighbor\_bound); \});}
\DoxyCodeLine{436   compress(comp);}
\DoxyCodeLine{437   \textcolor{comment}{// Sample certain vertices to find dominant component id}}
\DoxyCodeLine{438   T dominant\_c = findDominantComponentID(comp);}
\DoxyCodeLine{439   \textcolor{comment}{// link the rest vertices outside of dominant component}}
\DoxyCodeLine{440   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} u) \{}
\DoxyCodeLine{441     if (dominant\_c != comp[u]) \{}
\DoxyCodeLine{442       push(g, u, comp);}
\DoxyCodeLine{443       if (t\_graph.size() != 0) \{}
\DoxyCodeLine{444         push(t\_graph, u, comp);}
\DoxyCodeLine{445       \}}
\DoxyCodeLine{446     \}}
\DoxyCodeLine{447   \});}
\DoxyCodeLine{448   compress(comp);}
\DoxyCodeLine{449 }
\DoxyCodeLine{450   \textcolor{keywordflow}{return} comp;}
\DoxyCodeLine{451 \}}
\DoxyCodeLine{452 }
\DoxyCodeLine{453 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T = vertex\_\textcolor{keywordtype}{id}\_t<Graph>>}
\DoxyCodeLine{454 std::vector<T> ccv5(\textcolor{keyword}{const} Graph\& g) \{}
\DoxyCodeLine{455   \textcolor{keywordtype}{size\_t}         N = g.size();}
\DoxyCodeLine{456   std::vector<T> comp(g.size());}
\DoxyCodeLine{457   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} n) \{ comp[n] = n; \});}
\DoxyCodeLine{458 }
\DoxyCodeLine{459   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(N), [\&](\textcolor{keyword}{auto} u) \{ pull(g, u, comp); \});}
\DoxyCodeLine{460   T dominant\_c = findDominantComponentID(comp);}
\DoxyCodeLine{461   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(N), [\&](\textcolor{keyword}{auto} u) \{}
\DoxyCodeLine{462     \textcolor{keywordflow}{if} (dominant\_c != comp[u]) push(g, u, comp);}
\DoxyCodeLine{463   \});}
\DoxyCodeLine{464 }
\DoxyCodeLine{465   compress(comp);}
\DoxyCodeLine{466   \textcolor{keywordflow}{return} comp;}
\DoxyCodeLine{467 \}}
\DoxyCodeLine{468 }
\DoxyCodeLine{469 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T= vertex\_\textcolor{keywordtype}{id}\_t<Graph>>}
\DoxyCodeLine{470 \textcolor{keyword}{auto} sv\_v6(\textcolor{keyword}{const} Graph\& g) \{}
\DoxyCodeLine{471   std::vector<T> comp(g.size());}
\DoxyCodeLine{472 }
\DoxyCodeLine{473   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} n) \{ comp[n] = n; \});}
\DoxyCodeLine{474 }
\DoxyCodeLine{475   \textcolor{keywordtype}{bool} change = \textcolor{keyword}{true};}
\DoxyCodeLine{476 }
\DoxyCodeLine{477   \textcolor{keyword}{auto} G = g.begin();}
\DoxyCodeLine{478 }
\DoxyCodeLine{479   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} num\_iter = 0; num\_iter < g.size(); ++num\_iter) \{}
\DoxyCodeLine{480     \textcolor{keywordflow}{if} (\textcolor{keyword}{false} == change) \{}
\DoxyCodeLine{481       \textcolor{comment}{// std::cout << "{}Shiloach-\/Vishkin took "{} << num\_iter << "{} iterations"{} <<}}
\DoxyCodeLine{482       \textcolor{comment}{// std::endl;}}
\DoxyCodeLine{483       \textcolor{keywordflow}{break};}
\DoxyCodeLine{484     \}}
\DoxyCodeLine{485     change = \textcolor{keyword}{false};}
\DoxyCodeLine{486 }
\DoxyCodeLine{487     std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} u) \{}
\DoxyCodeLine{488       for (auto\&\& elt : G[u]) \{}
\DoxyCodeLine{489         auto v = target(g, elt);}
\DoxyCodeLine{490         T comp\_u = comp[u];}
\DoxyCodeLine{491         T comp\_v = comp[v];}
\DoxyCodeLine{492         if (comp\_u == comp\_v) continue;}
\DoxyCodeLine{493         T high\_comp = comp\_u > comp\_v ? comp\_u : comp\_v;}
\DoxyCodeLine{494         T low\_comp  = comp\_u + (comp\_v -\/ high\_comp);}
\DoxyCodeLine{495         if (high\_comp == comp[high\_comp]) \{}
\DoxyCodeLine{496           change          = true;}
\DoxyCodeLine{497           comp[high\_comp] = low\_comp;}
\DoxyCodeLine{498         \}}
\DoxyCodeLine{499       \}}
\DoxyCodeLine{500     \});}
\DoxyCodeLine{501 }
\DoxyCodeLine{502     \textcolor{keywordflow}{for} (T n = 0; n < g.size(); n++) \{}
\DoxyCodeLine{503       \textcolor{keywordflow}{while} (comp[n] != comp[comp[n]]) \{}
\DoxyCodeLine{504         comp[n] = comp[comp[n]];}
\DoxyCodeLine{505       \}}
\DoxyCodeLine{506     \}}
\DoxyCodeLine{507   \}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509   \textcolor{keywordflow}{return} comp;}
\DoxyCodeLine{510 \}}
\DoxyCodeLine{511 }
\DoxyCodeLine{512 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T = vertex\_\textcolor{keywordtype}{id}\_t<Graph>>}
\DoxyCodeLine{513 \textcolor{keyword}{auto} sv\_v8(Graph\& g) \{}
\DoxyCodeLine{514   std::vector<T> comp(g.size());}
\DoxyCodeLine{515 }
\DoxyCodeLine{516   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} n) \{ comp[n] = n; \});}
\DoxyCodeLine{517 }
\DoxyCodeLine{518   \textcolor{keywordtype}{bool} change = \textcolor{keyword}{true};}
\DoxyCodeLine{519 }
\DoxyCodeLine{520   \textcolor{keyword}{auto} G = g.begin();}
\DoxyCodeLine{521 }
\DoxyCodeLine{522   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} num\_iter = 0; num\_iter < g.size(); ++num\_iter) \{}
\DoxyCodeLine{523     \textcolor{keywordflow}{if} (\textcolor{keyword}{false} == change) \{}
\DoxyCodeLine{524       std::cout << \textcolor{stringliteral}{"{}Shiloach-\/Vishkin took "{}} << num\_iter << \textcolor{stringliteral}{"{} iterations"{}} << std::endl;}
\DoxyCodeLine{525       \textcolor{keywordflow}{break};}
\DoxyCodeLine{526     \}}
\DoxyCodeLine{527     change = \textcolor{keyword}{false};}
\DoxyCodeLine{528 }
\DoxyCodeLine{529     std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} u) \{}
\DoxyCodeLine{530       auto Gu = G[u];}
\DoxyCodeLine{531       \textcolor{comment}{// tbb::parallel\_for(G[u], [\&] (auto\& Gu) \{}}
\DoxyCodeLine{532       for (auto\&\& elt : Gu) \{}
\DoxyCodeLine{533         auto v = target(g, elt);}
\DoxyCodeLine{534         T comp\_u = comp[u];}
\DoxyCodeLine{535         T comp\_v = comp[v];}
\DoxyCodeLine{536         if (comp\_u == comp\_v) continue;}
\DoxyCodeLine{537         T high\_comp = std::max(comp\_u, comp\_v);}
\DoxyCodeLine{538 }
\DoxyCodeLine{539         T low\_comp = comp\_u + (comp\_v -\/ high\_comp);}
\DoxyCodeLine{540         if (high\_comp == comp[high\_comp]) \{}
\DoxyCodeLine{541           change          = true;}
\DoxyCodeLine{542           comp[high\_comp] = low\_comp;}
\DoxyCodeLine{543         \}}
\DoxyCodeLine{544       \}}
\DoxyCodeLine{545       \textcolor{comment}{// \});}}
\DoxyCodeLine{546     \});}
\DoxyCodeLine{547 }
\DoxyCodeLine{548     \textcolor{keywordflow}{for} (T n = 0; n < g.size(); n++) \{}
\DoxyCodeLine{549       \textcolor{keywordflow}{while} (comp[n] != comp[comp[n]]) \{}
\DoxyCodeLine{550         comp[n] = comp[comp[n]];}
\DoxyCodeLine{551       \}}
\DoxyCodeLine{552     \}}
\DoxyCodeLine{553   \}}
\DoxyCodeLine{554 }
\DoxyCodeLine{555   \textcolor{keywordflow}{return} comp;}
\DoxyCodeLine{556 \}}
\DoxyCodeLine{557 }
\DoxyCodeLine{558 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} T = vertex\_\textcolor{keywordtype}{id}\_t<Graph>>}
\DoxyCodeLine{559 \textcolor{keyword}{auto} sv\_v9(Graph\& g) \{}
\DoxyCodeLine{560   std::vector<T> comp(g.size());}
\DoxyCodeLine{561 }
\DoxyCodeLine{562   std::for\_each(std::execution::par\_unseq, counting\_iterator<T>(0), counting\_iterator<T>(g.size()), [\&](\textcolor{keyword}{auto} n) \{ comp[n] = n; \});}
\DoxyCodeLine{563 }
\DoxyCodeLine{564   \textcolor{keywordtype}{bool} change = \textcolor{keyword}{true};}
\DoxyCodeLine{565 }
\DoxyCodeLine{566   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} num\_iter = 0; num\_iter < g.size(); ++num\_iter) \{}
\DoxyCodeLine{567     \textcolor{keywordflow}{if} (\textcolor{keyword}{false} == change) \{}
\DoxyCodeLine{568       std::cout << \textcolor{stringliteral}{"{}Shiloach-\/Vishkin took "{}} << num\_iter << \textcolor{stringliteral}{"{} iterations"{}} << std::endl;}
\DoxyCodeLine{569       \textcolor{keywordflow}{break};}
\DoxyCodeLine{570     \}}
\DoxyCodeLine{571     change = \textcolor{keyword}{false};}
\DoxyCodeLine{572 }
\DoxyCodeLine{573     tbb::parallel\_for(edge\_range(g), [\&](\textcolor{keyword}{auto}\&\& sub) \{}
\DoxyCodeLine{574       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& [u, v] : sub) \{}
\DoxyCodeLine{575         T comp\_u = comp[u];}
\DoxyCodeLine{576         T comp\_v = comp[v];}
\DoxyCodeLine{577         \textcolor{keywordflow}{if} (comp\_u == comp\_v) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{578         T high\_comp = std::max(comp\_u, comp\_v);}
\DoxyCodeLine{579 }
\DoxyCodeLine{580         T low\_comp = comp\_u + (comp\_v -\/ high\_comp);}
\DoxyCodeLine{581         \textcolor{keywordflow}{if} (high\_comp == comp[high\_comp]) \{}
\DoxyCodeLine{582           change          = \textcolor{keyword}{true};}
\DoxyCodeLine{583           comp[high\_comp] = low\_comp;}
\DoxyCodeLine{584         \}}
\DoxyCodeLine{585       \}}
\DoxyCodeLine{586     \});}
\DoxyCodeLine{587 }
\DoxyCodeLine{588     \textcolor{keywordflow}{for} (T n = 0; n < g.size(); n++) \{}
\DoxyCodeLine{589       \textcolor{keywordflow}{while} (comp[n] != comp[comp[n]]) \{}
\DoxyCodeLine{590         comp[n] = comp[comp[n]];}
\DoxyCodeLine{591       \}}
\DoxyCodeLine{592     \}}
\DoxyCodeLine{593   \}}
\DoxyCodeLine{594 }
\DoxyCodeLine{595   \textcolor{keywordflow}{return} comp;}
\DoxyCodeLine{596 \}}
\DoxyCodeLine{597 }
\DoxyCodeLine{598 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{599 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{600 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// CONNECTED\_COMPONENT\_EXPERIMENTAL\_HPP}}

\end{DoxyCode}
