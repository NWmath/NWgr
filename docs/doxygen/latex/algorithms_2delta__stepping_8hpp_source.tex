\hypertarget{algorithms_2delta__stepping_8hpp_source}{}\doxysection{delta\+\_\+stepping.\+hpp}
\label{algorithms_2delta__stepping_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/delta\_stepping.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/delta\_stepping.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#ifndef DELTA\_STEPPING\_HPP}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#define DELTA\_STEPPING\_HPP}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <queue>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_concepts.hpp"{}}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include "{}nwgraph/containers/compressed.hpp"{}}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include "{}nwgraph/edge\_list.hpp"{}}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include "{}nwgraph/util/atomic.hpp"{}}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include "{}nwgraph/util/parallel\_for.hpp"{}}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include "{}nwgraph/util/timer.hpp"{}}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include "{}nwgraph/util/util.hpp"{}}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include "{}tbb/concurrent\_vector.h"{}}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include "{}tbb/parallel\_for\_each.h"{}}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#include "{}tbb/queuing\_mutex.h"{}}}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{37 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{keyword}{template} <\textcolor{keyword}{class} T, \textcolor{keyword}{class} Container = std::vector<T>, \textcolor{keyword}{class} Compare = std::less<\textcolor{keyword}{typename} Container::value\_type>>}
\DoxyCodeLine{40 \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1__priority__queue}{\_priority\_queue}} : \textcolor{keyword}{public} std::priority\_queue<T, Container, Compare> \{}
\DoxyCodeLine{41   \textcolor{keyword}{using} base = std::priority\_queue<T, Container, Compare>;}
\DoxyCodeLine{42 }
\DoxyCodeLine{43 \textcolor{keyword}{public}:}
\DoxyCodeLine{44   \textcolor{keyword}{explicit} \mbox{\hyperlink{classnw_1_1graph_1_1__priority__queue}{\_priority\_queue}}(\textcolor{keyword}{const} Compare\& compare = Compare(), \textcolor{keyword}{const} Container\& cont = Container()) : base(compare, cont) \{\}}
\DoxyCodeLine{45   \textcolor{keyword}{auto} begin() \{ \textcolor{keywordflow}{return} base::c.begin(); \}}
\DoxyCodeLine{46   \textcolor{keyword}{auto} end() \{ \textcolor{keywordflow}{return} base::c.begin(); \}}
\DoxyCodeLine{47   \textcolor{keyword}{auto} begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} base::c.begin(); \}}
\DoxyCodeLine{48   \textcolor{keyword}{auto} end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} base::c.begin(); \}}
\DoxyCodeLine{49 \};}
\DoxyCodeLine{50 }
\DoxyCodeLine{51 \textcolor{keyword}{template} <\textcolor{keyword}{class }distance\_t, adjacency\_list\_graph Graph, \textcolor{keyword}{class }Id,}
\DoxyCodeLine{52           \textcolor{keyword}{class }Weight>}
\DoxyCodeLine{53 \textcolor{keyword}{auto} delta\_stepping\_m1(\textcolor{keyword}{const} Graph\& graph, Id source, distance\_t,}
\DoxyCodeLine{54     Weight weight = [](\textcolor{keyword}{auto}\& e) -\/> \textcolor{keyword}{auto}\& \{ \textcolor{keywordflow}{return} std::get<1>(e); \}) \{}
\DoxyCodeLine{55   std::vector<distance\_t> tdist(num\_vertices(graph), std::numeric\_limits<distance\_t>::max());}
\DoxyCodeLine{56   \textcolor{keywordtype}{size\_t}                  top\_bin = 0;}
\DoxyCodeLine{57 }
\DoxyCodeLine{58   \textcolor{keyword}{auto} tdist\_comp = [\&](Id a, Id b) \{ \textcolor{keywordflow}{return} tdist[a] > tdist[b]; \};}
\DoxyCodeLine{59 }
\DoxyCodeLine{60   \_priority\_queue<Id, std::vector<Id>, std::function<bool(Id, Id)>> Q(tdist\_comp), frontier(tdist\_comp);}
\DoxyCodeLine{61 }
\DoxyCodeLine{62   Q.push(source);}
\DoxyCodeLine{63   tdist[source] = 0;}
\DoxyCodeLine{64 }
\DoxyCodeLine{65   \textcolor{keyword}{auto} relax = [\&](Id i, Id j, \textcolor{keyword}{auto} wt) \{}
\DoxyCodeLine{66     \textcolor{keyword}{auto} new\_distance = tdist[i] + wt;}
\DoxyCodeLine{67     \textcolor{keywordflow}{if} (new\_distance < tdist[j]) \{}
\DoxyCodeLine{68       tdist[j] = new\_distance;}
\DoxyCodeLine{69       Q.push(j);}
\DoxyCodeLine{70     \}}
\DoxyCodeLine{71   \};}
\DoxyCodeLine{72 }
\DoxyCodeLine{73   \textcolor{keywordflow}{while} (!Q.empty()) \{}
\DoxyCodeLine{74 }
\DoxyCodeLine{75     frontier = \_priority\_queue<Id, std::vector<Id>, std::function<bool(Id, Id)>>(tdist\_comp);}
\DoxyCodeLine{76     std::swap(frontier, Q);}
\DoxyCodeLine{77 }
\DoxyCodeLine{78     std::for\_each(frontier.begin(), frontier.end(), [\&](Id i) \{}
\DoxyCodeLine{79       std::for\_each(graph[i].begin(), graph[i].end(), [\&](auto\&\& elt) \{}
\DoxyCodeLine{80         auto j = target(graph, elt);}
\DoxyCodeLine{81         auto wt = weight(elt);}
\DoxyCodeLine{82         \textcolor{comment}{//auto\&\& [j, wt] = elt;    // i == v}}
\DoxyCodeLine{83         relax(i, j, wt);}
\DoxyCodeLine{84       \});}
\DoxyCodeLine{85     \});}
\DoxyCodeLine{86   \}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88   \textcolor{keywordflow}{return} tdist;}
\DoxyCodeLine{89 \}}
\DoxyCodeLine{90 }
\DoxyCodeLine{91 \textcolor{comment}{// Inspired by gapbs implementation}}
\DoxyCodeLine{92 \textcolor{keyword}{template} <\textcolor{keyword}{class }distance\_t, adjacency\_list\_graph Graph, \textcolor{keyword}{class }Id, \textcolor{keyword}{class }T,}
\DoxyCodeLine{93           \textcolor{keyword}{class }Weight>}
\DoxyCodeLine{94 \textcolor{keyword}{auto} delta\_stepping\_v0(}
\DoxyCodeLine{95     \textcolor{keyword}{const} Graph\& graph, Id source, T delta,}
\DoxyCodeLine{96     Weight weight = [](\textcolor{keyword}{auto}\& e) -\/> \textcolor{keyword}{auto}\& \{ \textcolor{keywordflow}{return} std::get<1>(e); \}) \{}
\DoxyCodeLine{97   std::vector<distance\_t>      tdist(num\_vertices(graph), std::numeric\_limits<distance\_t>::max());}
\DoxyCodeLine{98   std::vector<std::vector<Id>> bins(1);}
\DoxyCodeLine{99   std::size\_t                  top\_bin = 0;}
\DoxyCodeLine{100 }
\DoxyCodeLine{101   bins[top\_bin].push\_back(source);}
\DoxyCodeLine{102   tdist[source] = 0;}
\DoxyCodeLine{103 }
\DoxyCodeLine{104   \textcolor{keyword}{auto} relax = [\&](Id i, Id j, \textcolor{keyword}{auto} wt) \{}
\DoxyCodeLine{105     \textcolor{keyword}{auto} new\_distance = tdist[i] + wt;}
\DoxyCodeLine{106     \textcolor{keywordflow}{if} (new\_distance < tdist[j]) \{}
\DoxyCodeLine{107       tdist[j]             = new\_distance;}
\DoxyCodeLine{108       std::size\_t dest\_bin = new\_distance / delta;}
\DoxyCodeLine{109       \textcolor{keywordflow}{if} (dest\_bin >= bins.size()) \{}
\DoxyCodeLine{110         bins.resize(dest\_bin + 1);}
\DoxyCodeLine{111       \}}
\DoxyCodeLine{112       bins[dest\_bin].push\_back(j);}
\DoxyCodeLine{113     \}}
\DoxyCodeLine{114   \};}
\DoxyCodeLine{115 }
\DoxyCodeLine{116   std::vector<Id> frontier;}
\DoxyCodeLine{117 }
\DoxyCodeLine{118   \textcolor{keywordflow}{while} (top\_bin < bins.size()) \{}
\DoxyCodeLine{119 }
\DoxyCodeLine{120     frontier.resize(0);}
\DoxyCodeLine{121     std::swap(frontier, bins[top\_bin]);}
\DoxyCodeLine{122 }
\DoxyCodeLine{123     std::for\_each(frontier.begin(), frontier.end(), [\&](Id i) \{}
\DoxyCodeLine{124       if (tdist[i] >= delta * top\_bin) \{}
\DoxyCodeLine{125         std::for\_each(graph[i].begin(), graph[i].end(), [\&](auto\&\& elt) \{}
\DoxyCodeLine{126           auto j = target(graph, elt);}
\DoxyCodeLine{127           auto wt = weight(elt);}
\DoxyCodeLine{128           \textcolor{comment}{//auto\&\& [j, wt] = elt;    // i == v}}
\DoxyCodeLine{129           relax(i, j, wt);}
\DoxyCodeLine{130         \});}
\DoxyCodeLine{131       \}}
\DoxyCodeLine{132     \});}
\DoxyCodeLine{133 }
\DoxyCodeLine{134     \textcolor{keywordflow}{while} (top\_bin < bins.size() \&\& bins[top\_bin].size() == 0) \{}
\DoxyCodeLine{135       ++top\_bin;}
\DoxyCodeLine{136     \}}
\DoxyCodeLine{137   \}}
\DoxyCodeLine{138 }
\DoxyCodeLine{139   \textcolor{keywordflow}{return} tdist;}
\DoxyCodeLine{140 \}}
\DoxyCodeLine{141 }
\DoxyCodeLine{142 \textcolor{keyword}{template} <\textcolor{keyword}{class} distance\_t, adjacency\_list\_graph Graph, \textcolor{keyword}{class} Id, \textcolor{keyword}{class} T>}
\DoxyCodeLine{143 \textcolor{keyword}{auto} delta\_stepping\_v12(\textcolor{keyword}{const} Graph\& graph, Id source, T delta) \{}
\DoxyCodeLine{144   tbb::queuing\_mutex                                 lock;}
\DoxyCodeLine{145   std::atomic<std::size\_t>                           size = 1;}
\DoxyCodeLine{146   tbb::concurrent\_vector<tbb::concurrent\_vector<Id>> bins(size);}
\DoxyCodeLine{147   std::size\_t                                        top\_bin = 0;}
\DoxyCodeLine{148 }
\DoxyCodeLine{149   std::vector<std::atomic<distance\_t>> tdist(num\_vertices(graph));}
\DoxyCodeLine{150   tbb::parallel\_for\_each(tdist, [](\textcolor{keyword}{auto}\&\& d) \{ d = std::numeric\_limits<distance\_t>::max(); \});}
\DoxyCodeLine{151 }
\DoxyCodeLine{152   bins[top\_bin].push\_back(source);}
\DoxyCodeLine{153   tdist[source] = 0;}
\DoxyCodeLine{154 }
\DoxyCodeLine{155   \textcolor{keyword}{auto} relax = [\&](Id i, Id j, \textcolor{keyword}{auto} wt) \{}
\DoxyCodeLine{156     distance\_t next = nw::graph::acquire(tdist[i]) + wt;}
\DoxyCodeLine{157     distance\_t prev = nw::graph::acquire(tdist[j]);}
\DoxyCodeLine{158     \textcolor{keywordtype}{bool}       success;}
\DoxyCodeLine{159     \textcolor{keywordflow}{while} (next < prev \&\& !(success = nw::graph::cas(tdist[j], prev, next))) \{}
\DoxyCodeLine{160     \}}
\DoxyCodeLine{161     \textcolor{keywordflow}{if} (!success) \textcolor{keywordflow}{return};}
\DoxyCodeLine{162 }
\DoxyCodeLine{163     \textcolor{comment}{// inject this into the right bin (double-\/checked locking to serialize}}
\DoxyCodeLine{164     \textcolor{comment}{// resizing because tbb::concurrent\_vector resizing is not thread safe}}
\DoxyCodeLine{165     \textcolor{comment}{// https://www.threadingbuildingblocks.org/docs/help/hh\_goto.htm?index.htm\#tbb\_userguide/Advanced\_Idiom\_Waiting\_on\_an\_Element.html)}}
\DoxyCodeLine{166     std::size\_t bin = next / delta;}
\DoxyCodeLine{167     \textcolor{keywordflow}{if} (nw::graph::acquire(size) < bin + 1) \{}
\DoxyCodeLine{168       tbb::queuing\_mutex::scoped\_lock \_(lock);}
\DoxyCodeLine{169       \textcolor{keywordflow}{if} (nw::graph::acquire(size) < bin + 1) \{}
\DoxyCodeLine{170         bins.grow\_to\_at\_least(bin + 1);}
\DoxyCodeLine{171         nw::graph::release(size, bin + 1);}
\DoxyCodeLine{172       \}}
\DoxyCodeLine{173     \}}
\DoxyCodeLine{174     bins[bin].push\_back(j);}
\DoxyCodeLine{175   \};}
\DoxyCodeLine{176 }
\DoxyCodeLine{177   tbb::concurrent\_vector<Id> frontier;}
\DoxyCodeLine{178 }
\DoxyCodeLine{179   \textcolor{keywordflow}{while} (top\_bin < bins.size()) \{}
\DoxyCodeLine{180     frontier.resize(0);}
\DoxyCodeLine{181     std::swap(frontier, bins[top\_bin]);}
\DoxyCodeLine{182     tbb::parallel\_for\_each(frontier, [\&](\textcolor{keyword}{auto}\&\& u) \{}
\DoxyCodeLine{183       \textcolor{keywordflow}{if} (tdist[u] >= delta * top\_bin) \{}
\DoxyCodeLine{184         nw::graph::parallel\_for(graph[u], [\&](\textcolor{keyword}{auto}\&\& v, \textcolor{keyword}{auto}\&\& wt) \{ relax(u, v, wt); \});}
\DoxyCodeLine{185       \}}
\DoxyCodeLine{186     \});}
\DoxyCodeLine{187 }
\DoxyCodeLine{188     \textcolor{keywordflow}{while} (top\_bin < bins.size() \&\& bins[top\_bin].size() == 0) \{}
\DoxyCodeLine{189       bins[top\_bin++].shrink\_to\_fit();}
\DoxyCodeLine{190     \}}
\DoxyCodeLine{191   \}}
\DoxyCodeLine{192   \textcolor{keywordflow}{return} tdist;}
\DoxyCodeLine{193 \}}
\DoxyCodeLine{194 }
\DoxyCodeLine{195 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{196 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{197 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// DELTA\_STEPPING\_HPP}}

\end{DoxyCode}
