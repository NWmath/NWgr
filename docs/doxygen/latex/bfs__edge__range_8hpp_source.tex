\hypertarget{bfs__edge__range_8hpp_source}{}\doxysection{bfs\+\_\+edge\+\_\+range.\+hpp}
\label{bfs__edge__range_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/adaptors/bfs\_edge\_range.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/adaptors/bfs\_edge\_range.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#ifndef BFS\_EDGE\_RANGE\_HPP}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define BFS\_EDGE\_RANGE\_HPP}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 }
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_traits.hpp"{}}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <queue>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{26 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 }
\DoxyCodeLine{29 \textcolor{keyword}{enum} three\_colors \{ black, white, grey \};}
\DoxyCodeLine{30 }
\DoxyCodeLine{31 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{32 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Graph, \textcolor{keyword}{typename} Queue = std::queue<vertex\_\textcolor{keywordtype}{id}\_t<Graph>>>}
\DoxyCodeLine{33 \textcolor{keyword}{class }bfs\_edge\_range \{}
\DoxyCodeLine{34 \textcolor{keyword}{private}:}
\DoxyCodeLine{35   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<Graph>;}
\DoxyCodeLine{36 }
\DoxyCodeLine{37 \textcolor{keyword}{public}:}
\DoxyCodeLine{38   bfs\_edge\_range(Graph\& graph, vertex\_id\_type seed = 0) : the\_graph\_(graph), colors\_(graph.size(), white) \{}
\DoxyCodeLine{39     Q\_.push(seed);}
\DoxyCodeLine{40     colors\_[seed] = grey;}
\DoxyCodeLine{41   \}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43   bfs\_edge\_range(\textcolor{keyword}{const} bfs\_edge\_range\&)  = \textcolor{keyword}{delete};}
\DoxyCodeLine{44   bfs\_edge\_range(\textcolor{keyword}{const} bfs\_edge\_range\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{45 }
\DoxyCodeLine{46   \textcolor{keywordtype}{bool} empty() \{}
\DoxyCodeLine{47     \textcolor{keywordtype}{bool} b = Q\_.empty();}
\DoxyCodeLine{48     \textcolor{keywordflow}{return} b;}
\DoxyCodeLine{49   \}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51   \textcolor{keyword}{class }bfs\_edge\_range\_iterator \{}
\DoxyCodeLine{52   \textcolor{keyword}{private}:}
\DoxyCodeLine{53     bfs\_edge\_range<Graph, Queue>\&  the\_range\_;}
\DoxyCodeLine{54     \textcolor{keyword}{typename} Graph::outer\_iterator G;}
\DoxyCodeLine{55     vertex\_id\_type                 v\_;}
\DoxyCodeLine{56     \textcolor{keyword}{typename} Graph::inner\_iterator u\_begin, u\_end;}
\DoxyCodeLine{57 }
\DoxyCodeLine{58   \textcolor{keyword}{public}:}
\DoxyCodeLine{59     bfs\_edge\_range\_iterator(bfs\_edge\_range<Graph, Queue>\& range)}
\DoxyCodeLine{60         : the\_range\_(range), G(the\_range\_.the\_graph\_.begin()), v\_(the\_range\_.Q\_.front()), u\_begin(G[v\_].begin()), u\_end(G[v\_].end()) \{\}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62     bfs\_edge\_range\_iterator(\textcolor{keyword}{const} bfs\_edge\_range\_iterator\& ite)}
\DoxyCodeLine{63         : the\_range\_(ite.the\_range\_), G(ite.G), v\_(ite.v\_), u\_begin(u\_begin), u\_end(u\_end) \{\}}
\DoxyCodeLine{64 }
\DoxyCodeLine{65     bfs\_edge\_range\_iterator\& operator++() \{}
\DoxyCodeLine{66       \textcolor{keyword}{auto}\& Q      = the\_range\_.Q\_;}
\DoxyCodeLine{67       \textcolor{keyword}{auto}\& colors = the\_range\_.colors\_;}
\DoxyCodeLine{68 }
\DoxyCodeLine{69       Q.push(std::get<0>(*u\_begin));}
\DoxyCodeLine{70       colors[std::get<0>(*u\_begin)] = grey;}
\DoxyCodeLine{71 }
\DoxyCodeLine{72       ++u\_begin;}
\DoxyCodeLine{73       \textcolor{keywordflow}{while} (u\_begin != u\_end \&\& colors[std::get<0>(*u\_begin)] != white) \{}
\DoxyCodeLine{74         ++u\_begin;}
\DoxyCodeLine{75       \}}
\DoxyCodeLine{76 }
\DoxyCodeLine{77       \textcolor{keywordflow}{while} (u\_begin == u\_end) \{}
\DoxyCodeLine{78         colors[v\_] = black;}
\DoxyCodeLine{79         Q.pop();}
\DoxyCodeLine{80         \textcolor{keywordflow}{if} (Q.empty()) \textcolor{keywordflow}{break};}
\DoxyCodeLine{81 }
\DoxyCodeLine{82         v\_ = Q.front();}
\DoxyCodeLine{83         assert(colors[v\_] == grey);}
\DoxyCodeLine{84         u\_begin = G[v\_].begin();}
\DoxyCodeLine{85         u\_end   = G[v\_].end();}
\DoxyCodeLine{86 }
\DoxyCodeLine{87         \textcolor{keywordflow}{while} (u\_begin != u\_end \&\& colors[std::get<0>(*u\_begin)] != white) \{}
\DoxyCodeLine{88           ++u\_begin;}
\DoxyCodeLine{89         \}}
\DoxyCodeLine{90       \}}
\DoxyCodeLine{91 }
\DoxyCodeLine{92       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{93     \}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95     \textcolor{keyword}{auto} operator*() \{ \textcolor{keywordflow}{return} std::tuple\_cat(std::make\_tuple(v\_), *u\_begin); \}}
\DoxyCodeLine{96 }
\DoxyCodeLine{97     \textcolor{keyword}{class }end\_sentinel\_type \{}
\DoxyCodeLine{98     \textcolor{keyword}{public}:}
\DoxyCodeLine{99       end\_sentinel\_type() \{\}}
\DoxyCodeLine{100     \};}
\DoxyCodeLine{101 }
\DoxyCodeLine{102     \textcolor{keyword}{auto} operator==(\textcolor{keyword}{const} end\_sentinel\_type\&)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} the\_range\_.empty(); \}}
\DoxyCodeLine{103     \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} end\_sentinel\_type\&)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !the\_range\_.empty(); \}}
\DoxyCodeLine{104   \};}
\DoxyCodeLine{105 }
\DoxyCodeLine{106   \textcolor{keyword}{typedef} bfs\_edge\_range\_iterator iterator;}
\DoxyCodeLine{107 }
\DoxyCodeLine{108   \textcolor{keyword}{auto} begin() \{ \textcolor{keywordflow}{return} bfs\_edge\_range\_iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{109   \textcolor{keyword}{auto} end() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{typename} bfs\_edge\_range\_iterator::end\_sentinel\_type(); \}}
\DoxyCodeLine{110 }
\DoxyCodeLine{111 \textcolor{keyword}{private}:}
\DoxyCodeLine{112   Graph\&                    the\_graph\_;}
\DoxyCodeLine{113   Queue                     Q\_;}
\DoxyCodeLine{114   std::vector<three\_colors> colors\_;}
\DoxyCodeLine{115 \};}
\DoxyCodeLine{116 }
\DoxyCodeLine{117 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{118 }
\DoxyCodeLine{119 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Graph, \textcolor{keyword}{typename} Queue = std::queue<vertex\_\textcolor{keywordtype}{id}\_t<Graph>>>}
\DoxyCodeLine{120 \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range}{bfs\_edge\_range}} \{}
\DoxyCodeLine{121 \textcolor{keyword}{private}:}
\DoxyCodeLine{122   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<Graph>;}
\DoxyCodeLine{123 }
\DoxyCodeLine{124 \textcolor{keyword}{public}:}
\DoxyCodeLine{125   \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range}{bfs\_edge\_range}}(Graph\& graph, vertex\_id\_type seed = 0) : the\_graph\_(graph), visited\_(graph.size(), \textcolor{keyword}{false}) \{}
\DoxyCodeLine{126     Q\_.push(seed);}
\DoxyCodeLine{127   \}}
\DoxyCodeLine{128 }
\DoxyCodeLine{129   \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range}{bfs\_edge\_range}}(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range}{bfs\_edge\_range}}\&)  = \textcolor{keyword}{delete};}
\DoxyCodeLine{130   \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range}{bfs\_edge\_range}}(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range}{bfs\_edge\_range}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{131 }
\DoxyCodeLine{132   \textcolor{keywordtype}{bool} empty() \{}
\DoxyCodeLine{133     \textcolor{keywordtype}{bool} b = Q\_.empty();}
\DoxyCodeLine{134     \textcolor{keywordflow}{return} b;}
\DoxyCodeLine{135   \}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137   \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range_1_1bfs__edge__range__iterator}{bfs\_edge\_range\_iterator}} \{}
\DoxyCodeLine{138   \textcolor{keyword}{private}:}
\DoxyCodeLine{139     \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range}{bfs\_edge\_range<Graph, Queue>}}\&  the\_range\_;}
\DoxyCodeLine{140     \textcolor{keyword}{typename} Graph::outer\_iterator G;}
\DoxyCodeLine{141     vertex\_id\_type                 v\_;}
\DoxyCodeLine{142     \textcolor{keyword}{typename} Graph::inner\_iterator u\_begin, u\_end;}
\DoxyCodeLine{143 }
\DoxyCodeLine{144   \textcolor{keyword}{public}:}
\DoxyCodeLine{145     \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range_1_1bfs__edge__range__iterator}{bfs\_edge\_range\_iterator}}(\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range}{bfs\_edge\_range<Graph, Queue>}}\& range)}
\DoxyCodeLine{146         : the\_range\_(range), G(the\_range\_.the\_graph\_.begin()), v\_(the\_range\_.Q\_.front()), u\_begin(G[v\_].begin()), u\_end(G[v\_].end()) \{\}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148     \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range_1_1bfs__edge__range__iterator}{bfs\_edge\_range\_iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range_1_1bfs__edge__range__iterator}{bfs\_edge\_range\_iterator}}\& ite)}
\DoxyCodeLine{149         : the\_range\_(ite.the\_range\_), G(ite.G), v\_(ite.v\_), u\_begin(u\_begin), u\_end(u\_end) \{\}}
\DoxyCodeLine{150 }
\DoxyCodeLine{151     \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range_1_1bfs__edge__range__iterator}{bfs\_edge\_range\_iterator}}\& operator++() \{}
\DoxyCodeLine{152       \textcolor{keyword}{auto}\& Q      = the\_range\_.Q\_;}
\DoxyCodeLine{153       \textcolor{keyword}{auto}\& visited = the\_range\_.visited\_;}
\DoxyCodeLine{154 }
\DoxyCodeLine{155 }
\DoxyCodeLine{156       visited[std::get<0>(*u\_begin)] = \textcolor{keyword}{true};}
\DoxyCodeLine{157       Q.push(std::get<0>(*u\_begin));}
\DoxyCodeLine{158 }
\DoxyCodeLine{159       ++u\_begin;}
\DoxyCodeLine{160       \textcolor{keywordflow}{while} (u\_begin != u\_end \&\& visited[std::get<0>(*u\_begin)] != \textcolor{keyword}{false}) \{}
\DoxyCodeLine{161         ++u\_begin;}
\DoxyCodeLine{162       \}}
\DoxyCodeLine{163 }
\DoxyCodeLine{164       \textcolor{keywordflow}{while} (u\_begin == u\_end) \{}
\DoxyCodeLine{165         Q.pop();}
\DoxyCodeLine{166         \textcolor{keywordflow}{if} (Q.empty()) \textcolor{keywordflow}{break};}
\DoxyCodeLine{167 }
\DoxyCodeLine{168         v\_ = Q.front();}
\DoxyCodeLine{169         u\_begin = G[v\_].begin();}
\DoxyCodeLine{170         u\_end   = G[v\_].end();}
\DoxyCodeLine{171 }
\DoxyCodeLine{172         \textcolor{keywordflow}{while} (u\_begin != u\_end \&\& visited[std::get<0>(*u\_begin)] != \textcolor{keyword}{false}) \{}
\DoxyCodeLine{173           ++u\_begin;}
\DoxyCodeLine{174         \}}
\DoxyCodeLine{175       \}}
\DoxyCodeLine{176 }
\DoxyCodeLine{177       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{178     \}}
\DoxyCodeLine{179 }
\DoxyCodeLine{180     \textcolor{keyword}{auto} operator*() \{ \textcolor{keywordflow}{return} std::tuple\_cat(std::make\_tuple(v\_), *u\_begin); \}}
\DoxyCodeLine{181 }
\DoxyCodeLine{182     \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range_1_1bfs__edge__range__iterator_1_1end__sentinel__type}{end\_sentinel\_type}} \{}
\DoxyCodeLine{183     \textcolor{keyword}{public}:}
\DoxyCodeLine{184       \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range_1_1bfs__edge__range__iterator_1_1end__sentinel__type}{end\_sentinel\_type}}() \{\}}
\DoxyCodeLine{185     \};}
\DoxyCodeLine{186 }
\DoxyCodeLine{187     \textcolor{keyword}{auto} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range_1_1bfs__edge__range__iterator_1_1end__sentinel__type}{end\_sentinel\_type}}\&)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} the\_range\_.empty(); \}}
\DoxyCodeLine{188     \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} end\_sentinel\_type\&)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !the\_range\_.empty(); \}}
\DoxyCodeLine{189   \};}
\DoxyCodeLine{190 }
\DoxyCodeLine{191   \textcolor{keyword}{typedef} bfs\_edge\_range\_iterator iterator;}
\DoxyCodeLine{192 }
\DoxyCodeLine{193   \textcolor{keyword}{auto} begin() \{ \textcolor{keywordflow}{return} bfs\_edge\_range\_iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{194   \textcolor{keyword}{auto} end() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{typename} bfs\_edge\_range\_iterator::end\_sentinel\_type(); \}}
\DoxyCodeLine{195 }
\DoxyCodeLine{196 \textcolor{keyword}{private}:}
\DoxyCodeLine{197   Graph\&                    the\_graph\_;}
\DoxyCodeLine{198   Queue                     Q\_;}
\DoxyCodeLine{199   std::vector<bool> visited\_;}
\DoxyCodeLine{200 \};}
\DoxyCodeLine{201 }
\DoxyCodeLine{202 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{203 \textcolor{comment}{//****************************************************************************}}
\DoxyCodeLine{204 \textcolor{comment}{// This range used by dijkstra}}
\DoxyCodeLine{205 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Graph, \textcolor{keyword}{typename} PriorityQueue>}
\DoxyCodeLine{206 \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2}{bfs\_edge\_range2}} \{}
\DoxyCodeLine{207 \textcolor{keyword}{private}:}
\DoxyCodeLine{208   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{209 }
\DoxyCodeLine{210 \textcolor{keyword}{public}:}
\DoxyCodeLine{211   \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2}{bfs\_edge\_range2}}(Graph\& graph, PriorityQueue\& Q, std::tuple<size\_t, size\_t> seed = \{0, 0\})}
\DoxyCodeLine{212       : the\_graph\_(graph), Q\_(Q), colors\_(graph.end() -\/ graph.begin(), white) \{}
\DoxyCodeLine{213     Q\_.push(seed);}
\DoxyCodeLine{214     colors\_[std::get<0>(seed)] = grey;}
\DoxyCodeLine{215   \}}
\DoxyCodeLine{216 }
\DoxyCodeLine{217   \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2}{bfs\_edge\_range2}}(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2}{bfs\_edge\_range2}}\&)  = \textcolor{keyword}{delete};}
\DoxyCodeLine{218   \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2}{bfs\_edge\_range2}}(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2}{bfs\_edge\_range2}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{219 }
\DoxyCodeLine{220   \textcolor{keywordtype}{bool} empty() \{ \textcolor{keywordflow}{return} Q\_.empty(); \}}
\DoxyCodeLine{221 }
\DoxyCodeLine{222   \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2_1_1bfs__edge__range2__iterator}{bfs\_edge\_range2\_iterator}} \{}
\DoxyCodeLine{223   \textcolor{keyword}{private}:}
\DoxyCodeLine{224     \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2}{bfs\_edge\_range2<Graph, PriorityQueue>}}\& the\_range\_;}
\DoxyCodeLine{225     \textcolor{keyword}{typename} Graph::outer\_iterator         G;}
\DoxyCodeLine{226     vertex\_id\_type                         v\_;}
\DoxyCodeLine{227     \textcolor{keyword}{typename} Graph::inner\_iterator         u\_begin, u\_end;}
\DoxyCodeLine{228 }
\DoxyCodeLine{229     \textcolor{comment}{// Graph -\/> v, u, w}}
\DoxyCodeLine{230     \textcolor{comment}{// Q -\/> v, d}}
\DoxyCodeLine{231 }
\DoxyCodeLine{232   \textcolor{keyword}{public}:}
\DoxyCodeLine{233     \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2_1_1bfs__edge__range2__iterator}{bfs\_edge\_range2\_iterator}}(\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2}{bfs\_edge\_range2<Graph, PriorityQueue>}}\& range)}
\DoxyCodeLine{234         : the\_range\_(range), G(the\_range\_.the\_graph\_.begin()), v\_(std::get<0>(the\_range\_.Q\_.top())), u\_begin(G[v\_].begin()),}
\DoxyCodeLine{235           u\_end(G[v\_].end()) \{\}}
\DoxyCodeLine{236 }
\DoxyCodeLine{237     \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2_1_1bfs__edge__range2__iterator}{bfs\_edge\_range2\_iterator}}\& operator++() \{}
\DoxyCodeLine{238       \textcolor{keyword}{auto}\& Q      = the\_range\_.Q\_;}
\DoxyCodeLine{239       \textcolor{keyword}{auto}\& colors = the\_range\_.colors\_;}
\DoxyCodeLine{240 }
\DoxyCodeLine{241       Q.push(\{std::get<0>(*u\_begin), size\_t(0xffffffffffffffffULL)\});}
\DoxyCodeLine{242       colors[std::get<0>(*u\_begin)] = grey;}
\DoxyCodeLine{243 }
\DoxyCodeLine{244       ++u\_begin;}
\DoxyCodeLine{245       \textcolor{keywordflow}{while} (u\_begin != u\_end \&\& colors[std::get<0>(*u\_begin)] != white) \{}
\DoxyCodeLine{246         ++u\_begin;}
\DoxyCodeLine{247       \}}
\DoxyCodeLine{248 }
\DoxyCodeLine{249       \textcolor{keywordflow}{while} (u\_begin == u\_end) \{}
\DoxyCodeLine{250         colors[v\_] = black;}
\DoxyCodeLine{251 }
\DoxyCodeLine{252         \textcolor{keywordflow}{while} (colors[std::get<0>(Q.top())] == black \&\& !Q.empty())}
\DoxyCodeLine{253           Q.pop();}
\DoxyCodeLine{254 }
\DoxyCodeLine{255         \textcolor{keywordflow}{if} (Q.empty()) \textcolor{keywordflow}{break};}
\DoxyCodeLine{256 }
\DoxyCodeLine{257         v\_      = std::get<0>(Q.top());}
\DoxyCodeLine{258         u\_begin = G[v\_].begin();}
\DoxyCodeLine{259         u\_end   = G[v\_].end();}
\DoxyCodeLine{260 }
\DoxyCodeLine{261         \textcolor{keywordflow}{while} (u\_begin != u\_end \&\& colors[std::get<0>(*u\_begin)] != white) \{}
\DoxyCodeLine{262           ++u\_begin;}
\DoxyCodeLine{263         \}}
\DoxyCodeLine{264       \}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{267     \}}
\DoxyCodeLine{268 }
\DoxyCodeLine{269     \textcolor{keyword}{auto} operator*() \{ \textcolor{keywordflow}{return} std::tuple<vertex\_id\_type, vertex\_id\_type, size\_t>(v\_, std::get<0>(*u\_begin), std::get<1>(*u\_begin)); \}}
\DoxyCodeLine{270 }
\DoxyCodeLine{271     \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2_1_1bfs__edge__range2__iterator_1_1end__sentinel__type}{end\_sentinel\_type}} \{}
\DoxyCodeLine{272     \textcolor{keyword}{public}:}
\DoxyCodeLine{273       \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2_1_1bfs__edge__range2__iterator_1_1end__sentinel__type}{end\_sentinel\_type}}() \{\}}
\DoxyCodeLine{274     \};}
\DoxyCodeLine{275 }
\DoxyCodeLine{276     \textcolor{keyword}{auto} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range2_1_1bfs__edge__range2__iterator_1_1end__sentinel__type}{end\_sentinel\_type}}\&)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} the\_range\_.empty(); \}}
\DoxyCodeLine{277     \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} end\_sentinel\_type\&)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !the\_range\_.empty(); \}}
\DoxyCodeLine{278   \};}
\DoxyCodeLine{279 }
\DoxyCodeLine{280   \textcolor{keyword}{typedef} bfs\_edge\_range2\_iterator iterator;}
\DoxyCodeLine{281 }
\DoxyCodeLine{282   \textcolor{keyword}{auto} begin() \{ \textcolor{keywordflow}{return} bfs\_edge\_range2\_iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{283   \textcolor{keyword}{auto} end() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{typename} bfs\_edge\_range2\_iterator::end\_sentinel\_type(); \}}
\DoxyCodeLine{284 }
\DoxyCodeLine{285 \textcolor{keyword}{private}:}
\DoxyCodeLine{286   Graph\&                    the\_graph\_;}
\DoxyCodeLine{287   PriorityQueue\&            Q\_;}
\DoxyCodeLine{288   std::vector<three\_colors> colors\_;}
\DoxyCodeLine{289 \};}
\DoxyCodeLine{290 }
\DoxyCodeLine{291 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Graph, \textcolor{keyword}{typename} Queue = std::queue<\textcolor{keyword}{typename} Graph::vertex\_\textcolor{keywordtype}{id}\_type>>}
\DoxyCodeLine{292 \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3}{bfs\_edge\_range3}} \{}
\DoxyCodeLine{293 \textcolor{keyword}{private}:}
\DoxyCodeLine{294   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{295 }
\DoxyCodeLine{296 \textcolor{keyword}{public}:}
\DoxyCodeLine{297   \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3}{bfs\_edge\_range3}}(Graph\& graph, vertex\_id\_type seed = 0) : the\_graph\_(graph), colors\_(graph.end() -\/ graph.begin(), white) \{}
\DoxyCodeLine{298     Q\_[0].push(seed);}
\DoxyCodeLine{299     colors\_[seed] = grey;}
\DoxyCodeLine{300     \textcolor{comment}{//After adding seed, add the neighbors of seed to next queue}}
\DoxyCodeLine{301     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ite = the\_graph\_[seed].begin(); ite != the\_graph\_[seed].end(); ++ite) \{    \textcolor{comment}{// Explore neighbors}}
\DoxyCodeLine{302       \textcolor{keyword}{auto} u = std::get<0>(*ite);}
\DoxyCodeLine{303       \textcolor{keywordflow}{if} (colors\_[u] == white) \{}
\DoxyCodeLine{304         colors\_[u] = grey;}
\DoxyCodeLine{305         Q\_[1].push(u);}
\DoxyCodeLine{306       \}}
\DoxyCodeLine{307     \}}
\DoxyCodeLine{308   \}}
\DoxyCodeLine{309 }
\DoxyCodeLine{310   \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3}{bfs\_edge\_range3}}(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3}{bfs\_edge\_range3}}\&)  = \textcolor{keyword}{delete};}
\DoxyCodeLine{311   \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3}{bfs\_edge\_range3}}(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3}{bfs\_edge\_range3}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{312 }
\DoxyCodeLine{313   \textcolor{keywordtype}{bool} empty() \{ \textcolor{keywordflow}{return} Q\_[0].empty(); \}}
\DoxyCodeLine{314 }
\DoxyCodeLine{315   \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3_1_1bfs__edge__range3__iterator}{bfs\_edge\_range3\_iterator}} \{}
\DoxyCodeLine{316   \textcolor{keyword}{public}:}
\DoxyCodeLine{317     \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3_1_1bfs__edge__range3__iterator}{bfs\_edge\_range3\_iterator}}(\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3}{bfs\_edge\_range3<Graph>}}\& range) : the\_range\_(range) \{\}}
\DoxyCodeLine{318 }
\DoxyCodeLine{319     \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3_1_1bfs__edge__range3__iterator}{bfs\_edge\_range3\_iterator}}\& operator++() \{}
\DoxyCodeLine{320       \textcolor{keyword}{auto} G       = the\_range\_.the\_graph\_.begin();}
\DoxyCodeLine{321       Queue(\&Q)[2] = the\_range\_.Q\_;}
\DoxyCodeLine{322       \textcolor{keyword}{auto}\& colors = the\_range\_.colors\_;}
\DoxyCodeLine{323 }
\DoxyCodeLine{324       \textcolor{keywordflow}{if} (!Q[1].empty()) \{    \textcolor{comment}{// if the neighbor queue is not empty}}
\DoxyCodeLine{325                               \textcolor{comment}{// we proceed all the neighbors}}
\DoxyCodeLine{326         \textcolor{keyword}{auto} u = Q[1].front();}
\DoxyCodeLine{327         Q[1].pop();                   \textcolor{comment}{// pop the child which has been visited}}
\DoxyCodeLine{328         colors[u] = black;            \textcolor{comment}{// mark the child as black (visited)}}
\DoxyCodeLine{329         Q[0].push(u);                 \textcolor{comment}{// put the visited child to current frontier (it becomes parent)}}
\DoxyCodeLine{330         \textcolor{keywordflow}{while} (Q[1].empty()) \{        \textcolor{comment}{// keep filling neighbors until the}}
\DoxyCodeLine{331                                       \textcolor{comment}{// neighboring queue is not empty}}
\DoxyCodeLine{332           \textcolor{keywordflow}{if} (Q[0].empty()) \textcolor{keywordflow}{break};    \textcolor{comment}{// break if both queue are empty}}
\DoxyCodeLine{333 }
\DoxyCodeLine{334           \textcolor{keyword}{auto} v = Q[0].front();    \textcolor{comment}{// get parent vertex v}}
\DoxyCodeLine{335 }
\DoxyCodeLine{336           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ite = G[v].begin(); ite != G[v].end(); ++ite) \{    \textcolor{comment}{// Explore neighbors}}
\DoxyCodeLine{337             u = std::get<0>(*ite);}
\DoxyCodeLine{338             \textcolor{keywordflow}{if} (colors[u] == white) \{}
\DoxyCodeLine{339               colors[u] = grey;}
\DoxyCodeLine{340               Q[1].push(u);    \textcolor{comment}{//add all the white neighbors of v}}
\DoxyCodeLine{341             \}}
\DoxyCodeLine{342           \}                       \textcolor{comment}{//for}}
\DoxyCodeLine{343           \textcolor{keywordflow}{if} (Q[1].empty()) \{     \textcolor{comment}{//if parent vertex v has no white neighbors, then v has done all traverse}}
\DoxyCodeLine{344             Q[0].pop();           \textcolor{comment}{//pop it out}}
\DoxyCodeLine{345             colors[v] = black;    \textcolor{comment}{//be done with parent vertex v}}
\DoxyCodeLine{346           \}}
\DoxyCodeLine{347           \textcolor{comment}{// but we still need to populate the child queue, so we continue populate with the next parent vertex}}
\DoxyCodeLine{348         \}    \textcolor{comment}{// while}}
\DoxyCodeLine{349       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{350         \textcolor{keyword}{auto} v = Q[0].front();}
\DoxyCodeLine{351         Q[0].pop();    \textcolor{comment}{//if v has no neighbor, pop it}}
\DoxyCodeLine{352         colors[v] = black;}
\DoxyCodeLine{353       \}}
\DoxyCodeLine{354 }
\DoxyCodeLine{355       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{356     \}}
\DoxyCodeLine{357 }
\DoxyCodeLine{358     \textcolor{keyword}{auto} operator*() \{}
\DoxyCodeLine{359       Queue(\&Q)[2] = the\_range\_.Q\_;}
\DoxyCodeLine{360       \textcolor{comment}{//if v has no neighbor, return a self loop}}
\DoxyCodeLine{361       \textcolor{keywordflow}{if} (!Q[1].empty())}
\DoxyCodeLine{362         \textcolor{keywordflow}{return} std::make\_tuple(Q[0].front(), Q[1].front());}
\DoxyCodeLine{363       \textcolor{keywordflow}{else}}
\DoxyCodeLine{364         \textcolor{keywordflow}{return} std::make\_tuple(Q[0].front(), Q[0].front());}
\DoxyCodeLine{365     \}}
\DoxyCodeLine{366 }
\DoxyCodeLine{367     \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3_1_1bfs__edge__range3__iterator_1_1end__sentinel__type}{end\_sentinel\_type}} \{}
\DoxyCodeLine{368     \textcolor{keyword}{public}:}
\DoxyCodeLine{369       \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3_1_1bfs__edge__range3__iterator_1_1end__sentinel__type}{end\_sentinel\_type}}() \{\}}
\DoxyCodeLine{370     \};}
\DoxyCodeLine{371 }
\DoxyCodeLine{372     \textcolor{keyword}{auto} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3_1_1bfs__edge__range3__iterator_1_1end__sentinel__type}{end\_sentinel\_type}}\&)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} the\_range\_.empty(); \}}
\DoxyCodeLine{373     \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} end\_sentinel\_type\&)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !the\_range\_.empty(); \}}
\DoxyCodeLine{374 }
\DoxyCodeLine{375   \textcolor{keyword}{private}:}
\DoxyCodeLine{376     \mbox{\hyperlink{classnw_1_1graph_1_1bfs__edge__range3}{bfs\_edge\_range3<Graph>}}\& the\_range\_;}
\DoxyCodeLine{377   \};}
\DoxyCodeLine{378 }
\DoxyCodeLine{379   \textcolor{keyword}{typedef} bfs\_edge\_range3\_iterator iterator;}
\DoxyCodeLine{380 }
\DoxyCodeLine{381   \textcolor{keyword}{auto} begin() \{ \textcolor{keywordflow}{return} bfs\_edge\_range3\_iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{382   \textcolor{keyword}{auto} end() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{typename} bfs\_edge\_range3\_iterator::end\_sentinel\_type(); \}}
\DoxyCodeLine{383 }
\DoxyCodeLine{384 \textcolor{keyword}{private}:}
\DoxyCodeLine{385   Graph\&                    the\_graph\_;}
\DoxyCodeLine{386   std::vector<three\_colors> colors\_;    \textcolor{comment}{// Every node in Q\_[0] and those who has been processed is black.}}
\DoxyCodeLine{387                                         \textcolor{comment}{// Every nobe in Q\_[1] is grey.}}
\DoxyCodeLine{388                                         \textcolor{comment}{// Every unprocessed node is white.}}
\DoxyCodeLine{389   Queue Q\_[2];                          \textcolor{comment}{//Q\_[0] is processing queue, Q\_[1] is neighbor queue}}
\DoxyCodeLine{390   \textcolor{comment}{//the reason to use two queues instead of one: we need to return <parent,child> tuple at the front of each queue respectively.}}
\DoxyCodeLine{391 \};}
\DoxyCodeLine{392 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{393 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{394 }
\DoxyCodeLine{395 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// BFS\_EDGE\_RANGE\_HPP}}

\end{DoxyCode}
