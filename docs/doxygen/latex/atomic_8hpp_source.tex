\hypertarget{atomic_8hpp_source}{}\doxysection{atomic.\+hpp}
\label{atomic_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/util/atomic.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/util/atomic.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Luke D'Alessandro    }}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_ATOMIC}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define NW\_GRAPH\_ATOMIC}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include "{}nwgraph/util/traits.hpp"{}}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <atomic>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{21 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{23 \textcolor{keyword}{template} <std::memory\_order order, \textcolor{keyword}{class} T>}
\DoxyCodeLine{24 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} load(T\&\& t) \{}
\DoxyCodeLine{25   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (is\_atomic\_v<std::decay\_t<T>>) \{}
\DoxyCodeLine{26     \textcolor{keywordflow}{return} std::forward<T>(t).load(order);}
\DoxyCodeLine{27   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{28     \textcolor{keywordflow}{return} load<order>(std::atomic\_ref(t));}
\DoxyCodeLine{29   \}}
\DoxyCodeLine{30 \}}
\DoxyCodeLine{31 }
\DoxyCodeLine{43 \textcolor{keyword}{template} <std::memory\_order order, \textcolor{keyword}{class} T, \textcolor{keyword}{class} U>}
\DoxyCodeLine{44 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{void} store(T\&\& t, U\&\& u) \{}
\DoxyCodeLine{45   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (is\_atomic\_v<std::decay\_t<T>>) \{}
\DoxyCodeLine{46     std::forward<T>(t).store(std::forward<U>(u), order);}
\DoxyCodeLine{47   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{48     store<order>(std::atomic\_ref(t), std::forward<U>(u));}
\DoxyCodeLine{49   \}}
\DoxyCodeLine{50 \}}
\DoxyCodeLine{51 }
\DoxyCodeLine{71 \textcolor{keyword}{template} <std::memory\_order success = std::memory\_order\_acq\_rel, std::memory\_order failure = std::memory\_order\_acquire, \textcolor{keyword}{class }T, \textcolor{keyword}{class }U,}
\DoxyCodeLine{72           \textcolor{keyword}{class }V>}
\DoxyCodeLine{73 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} cas(T\&\& t, U\&\& u, V\&\& v) \{}
\DoxyCodeLine{74   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (is\_atomic\_v<std::decay\_t<T>>) \{}
\DoxyCodeLine{75     \textcolor{keywordflow}{return} std::forward<T>(t).compare\_exchange\_strong(std::forward<U>(u), std::forward<V>(v), success, failure);}
\DoxyCodeLine{76   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{77     \textcolor{keywordflow}{return} cas<success, failure>(std::atomic\_ref(t), std::forward<U>(u), std::forward<V>(v));}
\DoxyCodeLine{78   \}}
\DoxyCodeLine{79 \}}
\DoxyCodeLine{80 }
\DoxyCodeLine{88 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{89 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} acquire(T\&\& t) \{}
\DoxyCodeLine{90   \textcolor{keywordflow}{return} load<std::memory\_order\_acquire>(std::forward<T>(t));}
\DoxyCodeLine{91 \}}
\DoxyCodeLine{92 }
\DoxyCodeLine{93 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{94 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} relaxed(T\&\& t) \{}
\DoxyCodeLine{95   \textcolor{keywordflow}{return} load<std::memory\_order\_relaxed>(std::forward<T>(t));}
\DoxyCodeLine{96 \}}
\DoxyCodeLine{97 }
\DoxyCodeLine{105 \textcolor{keyword}{template} <\textcolor{keyword}{class} T, \textcolor{keyword}{class} U>}
\DoxyCodeLine{106 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{void} release(T\&\& t, U\&\& u) \{}
\DoxyCodeLine{107   store<std::memory\_order\_release>(std::forward<T>(t), std::forward<U>(u));}
\DoxyCodeLine{108 \}}
\DoxyCodeLine{109 }
\DoxyCodeLine{110 \textcolor{keyword}{template} <\textcolor{keyword}{class} T, \textcolor{keyword}{class} U>}
\DoxyCodeLine{111 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{void} relaxed(T\&\& t, U\&\& u) \{}
\DoxyCodeLine{112   store<std::memory\_order\_relaxed>(std::forward<T>(t), std::forward<U>(u));}
\DoxyCodeLine{113 \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{129 \textcolor{keyword}{template} <std::memory\_order order = std::memory\_order\_acq\_rel, \textcolor{keyword}{class} T, \textcolor{keyword}{class} U>}
\DoxyCodeLine{130 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} fetch\_add(T\&\& t, U\&\& u) \{}
\DoxyCodeLine{131   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (is\_atomic\_v<std::decay\_t<T>>) \{}
\DoxyCodeLine{132     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_floating\_point\_v<remove\_atomic\_t<std::decay\_t<T>>>) \{}
\DoxyCodeLine{133       \textcolor{keyword}{auto}\&\& e = acquire(t);}
\DoxyCodeLine{134       \textcolor{keywordflow}{while} (!cas<order>(std::forward<T>(t), e, e + u))}
\DoxyCodeLine{135         ;}
\DoxyCodeLine{136       \textcolor{keywordflow}{return} e;}
\DoxyCodeLine{137     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{138       \textcolor{keywordflow}{return} t.fetch\_add(std::forward<U>(u), order);}
\DoxyCodeLine{139     \}}
\DoxyCodeLine{140   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{142     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_floating\_point\_v<std::decay\_t<T>>) \{}
\DoxyCodeLine{143       \textcolor{keyword}{auto} e = acquire(std::forward<T>(t));}
\DoxyCodeLine{144       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} f = e + u; !cas<order>(std::forward<T>(t), e, f); f = e + u)}
\DoxyCodeLine{145         ;}
\DoxyCodeLine{146       \textcolor{keywordflow}{return} e;}
\DoxyCodeLine{147     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{148       \textcolor{keywordflow}{return} fetch\_add<order>(std::atomic\_ref(t), std::forward<U>(u));}
\DoxyCodeLine{149     \}}
\DoxyCodeLine{150   \}}
\DoxyCodeLine{151 \}}
\DoxyCodeLine{152 }
\DoxyCodeLine{153 \textcolor{keyword}{template} <std::memory\_order order = std::memory\_order\_acq\_rel, \textcolor{keyword}{class} T, \textcolor{keyword}{class} U>}
\DoxyCodeLine{154 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} fetch\_or(T\&\& t, U\&\& u) \{}
\DoxyCodeLine{155   \textcolor{keyword}{static\_assert}(!std::is\_floating\_point\_v<std::decay\_t<T>>, \textcolor{stringliteral}{"{}Logical fetch\_or invalid for floating point types."{}});}
\DoxyCodeLine{156   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (is\_atomic\_v<std::decay\_t<T>>) \{}
\DoxyCodeLine{157     \textcolor{keywordflow}{return} std::forward<T>(t).fetch\_or(std::forward<U>(u), order);}
\DoxyCodeLine{158   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{159     \textcolor{keywordflow}{return} fetch\_or<order>(std::atomic\_ref(t), std::forward<U>(u));}
\DoxyCodeLine{160   \}}
\DoxyCodeLine{161 \}}
\DoxyCodeLine{162 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{163 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{164 }
\DoxyCodeLine{165 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// NW\_GRAPH\_ATOMIC\_HPP}}

\end{DoxyCode}
