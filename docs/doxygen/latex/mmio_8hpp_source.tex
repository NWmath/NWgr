\hypertarget{mmio_8hpp_source}{}\doxysection{mmio.\+hpp}
\label{mmio_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/io/mmio.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/io/mmio.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_MMIO\_HPP}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define NW\_GRAPH\_MMIO\_HPP}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <fcntl.h>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <future>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <sys/mman.h>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <sys/stat.h>}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <sys/types.h>}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <thread>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <unistd.h>}}
\DoxyCodeLine{28 }
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include "{}MatrixMarketFile.hpp"{}}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include "{}nwgraph/adjacency.hpp"{}}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include "{}nwgraph/edge\_list.hpp"{}}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include <tbb/concurrent\_vector.h>}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{36 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{37 }
\DoxyCodeLine{38 \textcolor{keywordtype}{void} mm\_fill(std::istream\& inputStream, bi\_edge\_list<directedness::directed>\& A, \textcolor{keywordtype}{size\_t} nNonzeros, \textcolor{keywordtype}{bool} file\_symmetry, \textcolor{keywordtype}{bool} pattern) \{}
\DoxyCodeLine{39   A.reserve((file\_symmetry ? 2 : 1) * nNonzeros);}
\DoxyCodeLine{40   A.open\_for\_push\_back();}
\DoxyCodeLine{41   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < nNonzeros; ++i) \{}
\DoxyCodeLine{42     std::string buffer;}
\DoxyCodeLine{43     \textcolor{keywordtype}{size\_t}      d0, d1;}
\DoxyCodeLine{44 }
\DoxyCodeLine{45     std::getline(inputStream, buffer);}
\DoxyCodeLine{46     std::stringstream(buffer) >> d0 >> d1;}
\DoxyCodeLine{47 }
\DoxyCodeLine{48     A.push\_back(d0-\/1, d1-\/1);}
\DoxyCodeLine{49 }
\DoxyCodeLine{50     \textcolor{keywordflow}{if} (file\_symmetry \&\& (d0 != d1)) \{}
\DoxyCodeLine{51       A.push\_back(d1-\/1, d0-\/1);}
\DoxyCodeLine{52     \}}
\DoxyCodeLine{53   \}}
\DoxyCodeLine{54   A.close\_for\_push\_back();}
\DoxyCodeLine{55 \}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{58 \textcolor{keywordtype}{void} mm\_fill(std::istream\& inputStream, bi\_edge\_list<directedness::directed, T>\& A, \textcolor{keywordtype}{size\_t} nNonzeros, \textcolor{keywordtype}{bool} file\_symmetry, \textcolor{keywordtype}{bool} pattern) \{}
\DoxyCodeLine{59 }
\DoxyCodeLine{60   A.reserve((file\_symmetry ? 2 : 1) * nNonzeros);}
\DoxyCodeLine{61   A.open\_for\_push\_back();}
\DoxyCodeLine{62   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < nNonzeros; ++i) \{}
\DoxyCodeLine{63     std::string buffer;}
\DoxyCodeLine{64     \textcolor{keywordtype}{size\_t}      d0, d1;}
\DoxyCodeLine{65     T           v(1.0);}
\DoxyCodeLine{66 }
\DoxyCodeLine{67     std::getline(inputStream, buffer);}
\DoxyCodeLine{68     \textcolor{keywordflow}{if} (pattern) \{}
\DoxyCodeLine{69       std::stringstream(buffer) >> d0 >> d1;}
\DoxyCodeLine{70     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{71       std::stringstream(buffer) >> d0 >> d1 >> v;}
\DoxyCodeLine{72     \}}
\DoxyCodeLine{73 }
\DoxyCodeLine{74     A.push\_back(d0-\/1, d1-\/1, v);}
\DoxyCodeLine{75 }
\DoxyCodeLine{76     \textcolor{keywordflow}{if} (file\_symmetry \&\& (d0 != d1)) \{}
\DoxyCodeLine{77       A.push\_back(d1-\/1, d0-\/1, v);}
\DoxyCodeLine{78     \}}
\DoxyCodeLine{79   \}}
\DoxyCodeLine{80   A.close\_for\_push\_back();}
\DoxyCodeLine{81 \}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83 \textcolor{keywordtype}{void} mm\_fill(std::istream\& inputStream, edge\_list<directedness::directed>\& A, \textcolor{keywordtype}{size\_t} nNonzeros, \textcolor{keywordtype}{bool} file\_symmetry, \textcolor{keywordtype}{bool} pattern) \{}
\DoxyCodeLine{84   A.reserve((file\_symmetry ? 2 : 1) * nNonzeros);}
\DoxyCodeLine{85   A.open\_for\_push\_back();}
\DoxyCodeLine{86   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < nNonzeros; ++i) \{}
\DoxyCodeLine{87     std::string buffer;}
\DoxyCodeLine{88     \textcolor{keywordtype}{size\_t}      d0, d1;}
\DoxyCodeLine{89 }
\DoxyCodeLine{90     std::getline(inputStream, buffer);}
\DoxyCodeLine{91     std::stringstream(buffer) >> d0 >> d1;}
\DoxyCodeLine{92 }
\DoxyCodeLine{93     A.push\_back(d0-\/1, d1-\/1);}
\DoxyCodeLine{94 }
\DoxyCodeLine{95     \textcolor{keywordflow}{if} (file\_symmetry \&\& (d0 != d1)) \{}
\DoxyCodeLine{96       A.push\_back(d1-\/1, d0-\/1);}
\DoxyCodeLine{97     \}}
\DoxyCodeLine{98   \}}
\DoxyCodeLine{99   A.close\_for\_push\_back();}
\DoxyCodeLine{100 \}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{103 \textcolor{keywordtype}{void} mm\_fill(std::istream\& inputStream, edge\_list<directedness::directed, T>\& A, \textcolor{keywordtype}{size\_t} nNonzeros, \textcolor{keywordtype}{bool} file\_symmetry, \textcolor{keywordtype}{bool} pattern) \{}
\DoxyCodeLine{104 }
\DoxyCodeLine{105   A.reserve((file\_symmetry ? 2 : 1) * nNonzeros);}
\DoxyCodeLine{106   A.open\_for\_push\_back();}
\DoxyCodeLine{107   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < nNonzeros; ++i) \{}
\DoxyCodeLine{108     std::string buffer;}
\DoxyCodeLine{109     \textcolor{keywordtype}{size\_t}      d0, d1;}
\DoxyCodeLine{110     T           v(1.0);}
\DoxyCodeLine{111 }
\DoxyCodeLine{112     std::getline(inputStream, buffer);}
\DoxyCodeLine{113     \textcolor{keywordflow}{if} (pattern) \{}
\DoxyCodeLine{114       std::stringstream(buffer) >> d0 >> d1;}
\DoxyCodeLine{115     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{116       std::stringstream(buffer) >> d0 >> d1 >> v;}
\DoxyCodeLine{117     \}}
\DoxyCodeLine{118 }
\DoxyCodeLine{119     A.push\_back(d0-\/1, d1-\/1, v);}
\DoxyCodeLine{120 }
\DoxyCodeLine{121     \textcolor{keywordflow}{if} (file\_symmetry \&\& (d0 != d1)) \{}
\DoxyCodeLine{122       A.push\_back(d1-\/1, d0-\/1, v);}
\DoxyCodeLine{123     \}}
\DoxyCodeLine{124   \}}
\DoxyCodeLine{125   A.close\_for\_push\_back();}
\DoxyCodeLine{126 \}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128 \textcolor{keywordtype}{void} mm\_fill(std::istream\& inputStream, edge\_list<directedness::undirected>\& A, \textcolor{keywordtype}{size\_t} nNonzeros, \textcolor{keywordtype}{bool} file\_symmetry, \textcolor{keywordtype}{bool} pattern) \{}
\DoxyCodeLine{129 }
\DoxyCodeLine{130   A.reserve(nNonzeros);}
\DoxyCodeLine{131   A.open\_for\_push\_back();}
\DoxyCodeLine{132 }
\DoxyCodeLine{133   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < nNonzeros; ++i) \{}
\DoxyCodeLine{134     \textcolor{keywordtype}{size\_t} d0, d1;}
\DoxyCodeLine{135     \textcolor{keywordtype}{double} d2;}
\DoxyCodeLine{136 }
\DoxyCodeLine{137     \textcolor{keywordflow}{if} (pattern) \{}
\DoxyCodeLine{138       inputStream >> d0 >> d1;}
\DoxyCodeLine{139     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{140       inputStream >> d0 >> d1 >> d2;}
\DoxyCodeLine{141     \}}
\DoxyCodeLine{142 }
\DoxyCodeLine{143     A.push\_back(d0-\/1, d1-\/1);}
\DoxyCodeLine{144   \}}
\DoxyCodeLine{145   A.close\_for\_push\_back();}
\DoxyCodeLine{146 \}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{149 \textcolor{keywordtype}{void} mm\_fill(std::istream\& inputStream, edge\_list<directedness::undirected, T>\& A, \textcolor{keywordtype}{size\_t} nNonzeros, \textcolor{keywordtype}{bool} file\_symmetry, \textcolor{keywordtype}{bool} pattern) \{}
\DoxyCodeLine{150   \textcolor{comment}{// assert(file\_symmetry);}}
\DoxyCodeLine{151   A.reserve(nNonzeros);}
\DoxyCodeLine{152   A.open\_for\_push\_back();}
\DoxyCodeLine{153   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < nNonzeros; ++i) \{}
\DoxyCodeLine{154     std::string buffer;}
\DoxyCodeLine{155     \textcolor{keywordtype}{size\_t}      d0, d1;}
\DoxyCodeLine{156     T           v(1.0);}
\DoxyCodeLine{157     std::getline(inputStream, buffer);}
\DoxyCodeLine{158     \textcolor{keywordflow}{if} (pattern) \{}
\DoxyCodeLine{159       std::stringstream(buffer) >> d0 >> d1;}
\DoxyCodeLine{160     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{161       std::stringstream(buffer) >> d0 >> d1 >> v;}
\DoxyCodeLine{162     \}}
\DoxyCodeLine{163     A.push\_back(d0-\/1, d1-\/1, v);}
\DoxyCodeLine{164   \}}
\DoxyCodeLine{165   A.close\_for\_push\_back();}
\DoxyCodeLine{166 \}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168 \textcolor{keyword}{template} <directedness sym, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{169 edge\_list<sym, Attributes...> read\_mm(std::istream\& inputStream) \{}
\DoxyCodeLine{170   std::string              string\_input;}
\DoxyCodeLine{171   \textcolor{keywordtype}{bool}                     file\_symmetry = \textcolor{keyword}{false};}
\DoxyCodeLine{172   std::vector<std::string> header(5);}
\DoxyCodeLine{173 }
\DoxyCodeLine{174   \textcolor{comment}{// \%\%MatrixMarket matrix coordinate integer symmetric}}
\DoxyCodeLine{175   std::getline(inputStream, string\_input);}
\DoxyCodeLine{176   std::stringstream h(string\_input);}
\DoxyCodeLine{177   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& s : header)}
\DoxyCodeLine{178     h >> s;}
\DoxyCodeLine{179 }
\DoxyCodeLine{180   \textcolor{keywordflow}{if} (header[0] != \textcolor{stringliteral}{"{}\%\%MatrixMarket"{}}) \{}
\DoxyCodeLine{181     std::cerr << \textcolor{stringliteral}{"{}Unsupported format"{}} << std::endl;}
\DoxyCodeLine{182     \textcolor{keywordflow}{throw};}
\DoxyCodeLine{183   \}}
\DoxyCodeLine{184   \textcolor{keywordflow}{if} (header[4] == \textcolor{stringliteral}{"{}symmetric"{}}) \{}
\DoxyCodeLine{185     file\_symmetry = \textcolor{keyword}{true};}
\DoxyCodeLine{186   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (header[4] == \textcolor{stringliteral}{"{}general"{}}) \{}
\DoxyCodeLine{187     file\_symmetry = \textcolor{keyword}{false};}
\DoxyCodeLine{188   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{189     std::cerr << \textcolor{stringliteral}{"{}Bad format (symmetry): "{}} << header[4] << std::endl;}
\DoxyCodeLine{190     \textcolor{keywordflow}{throw};}
\DoxyCodeLine{191   \}}
\DoxyCodeLine{192 }
\DoxyCodeLine{193   \textcolor{keywordflow}{while} (std::getline(inputStream, string\_input)) \{}
\DoxyCodeLine{194     \textcolor{keywordflow}{if} (string\_input[0] != \textcolor{charliteral}{'\%'}) \textcolor{keywordflow}{break};}
\DoxyCodeLine{195   \}}
\DoxyCodeLine{196   \textcolor{keywordtype}{size\_t} n0, n1, nNonzeros;}
\DoxyCodeLine{197   std::stringstream(string\_input) >> n0 >> n1 >> nNonzeros;}
\DoxyCodeLine{198 }
\DoxyCodeLine{199   \textcolor{comment}{// assert(n0 == n1);}}
\DoxyCodeLine{200 }
\DoxyCodeLine{201   edge\_list<sym, Attributes...> A(n0);}
\DoxyCodeLine{202   mm\_fill(inputStream, A, nNonzeros, file\_symmetry, (header[3] == \textcolor{stringliteral}{"{}pattern"{}}));}
\DoxyCodeLine{203 }
\DoxyCodeLine{204   \textcolor{keywordflow}{return} A;}
\DoxyCodeLine{205 \}}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 \textcolor{keyword}{template} <directedness sym, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{208 edge\_list<sym, Attributes...> read\_mm(\textcolor{keyword}{const} std::string\& filename) \{}
\DoxyCodeLine{209   std::ifstream inputFile(filename);}
\DoxyCodeLine{210 }
\DoxyCodeLine{211   edge\_list<sym, Attributes...> A = read\_mm<sym, Attributes...>(inputFile);}
\DoxyCodeLine{212 }
\DoxyCodeLine{213   \textcolor{keywordflow}{return} A;}
\DoxyCodeLine{214 \}}
\DoxyCodeLine{215 }
\DoxyCodeLine{216 \textcolor{keyword}{template} <directedness sym, \textcolor{keyword}{typename}... Attributes, edge\_list\_graph edge\_list\_t>}
\DoxyCodeLine{217 edge\_list\_t read\_mm(\textcolor{keyword}{const} std::string\& filename) \{}
\DoxyCodeLine{218   std::ifstream            inputStream(filename);}
\DoxyCodeLine{219   std::string              string\_input;}
\DoxyCodeLine{220   \textcolor{keywordtype}{bool}                     file\_symmetry = \textcolor{keyword}{false};}
\DoxyCodeLine{221   std::vector<std::string> header(5);}
\DoxyCodeLine{222 }
\DoxyCodeLine{223   \textcolor{comment}{// \%\%MatrixMarket matrix coordinate integer symmetric}}
\DoxyCodeLine{224   std::getline(inputStream, string\_input);}
\DoxyCodeLine{225   std::stringstream h(string\_input);}
\DoxyCodeLine{226   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& s : header)}
\DoxyCodeLine{227     h >> s;}
\DoxyCodeLine{228 }
\DoxyCodeLine{229   \textcolor{keywordflow}{if} (header[0] != \textcolor{stringliteral}{"{}\%\%MatrixMarket"{}}) \{}
\DoxyCodeLine{230     std::cerr << \textcolor{stringliteral}{"{}Unsupported format"{}} << std::endl;}
\DoxyCodeLine{231     \textcolor{keywordflow}{throw};}
\DoxyCodeLine{232   \}}
\DoxyCodeLine{233   \textcolor{keywordflow}{if} (header[4] == \textcolor{stringliteral}{"{}symmetric"{}}) \{}
\DoxyCodeLine{234     file\_symmetry = \textcolor{keyword}{true};}
\DoxyCodeLine{235   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (header[4] == \textcolor{stringliteral}{"{}general"{}}) \{}
\DoxyCodeLine{236     file\_symmetry = \textcolor{keyword}{false};}
\DoxyCodeLine{237   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{238     std::cerr << \textcolor{stringliteral}{"{}Bad format (symmetry): "{}} << header[4] << std::endl;}
\DoxyCodeLine{239     \textcolor{keywordflow}{throw};}
\DoxyCodeLine{240   \}}
\DoxyCodeLine{241 }
\DoxyCodeLine{242   \textcolor{keywordflow}{while} (std::getline(inputStream, string\_input)) \{}
\DoxyCodeLine{243     \textcolor{keywordflow}{if} (string\_input[0] != \textcolor{charliteral}{'\%'}) \textcolor{keywordflow}{break};}
\DoxyCodeLine{244   \}}
\DoxyCodeLine{245   \textcolor{keywordtype}{size\_t} n0, n1, nNonzeros;}
\DoxyCodeLine{246   std::stringstream(string\_input) >> n0 >> n1 >> nNonzeros;}
\DoxyCodeLine{247 }
\DoxyCodeLine{248   \textcolor{keywordflow}{if} (n0 == n1 \&\& is\_unipartite<edge\_list\_t>::value) \{}
\DoxyCodeLine{249     \textcolor{comment}{//unipartite edge list}}
\DoxyCodeLine{250     \textcolor{comment}{//edge\_list<sym, Attributes...> A(n0);}}
\DoxyCodeLine{251     \textcolor{comment}{//mm\_fill(inputStream, A, nNonzeros, file\_symmetry, (header[3] == "{}pattern"{}));}}
\DoxyCodeLine{252 }
\DoxyCodeLine{253     \textcolor{comment}{//return A;}}
\DoxyCodeLine{254     std::cerr << \textcolor{stringliteral}{"{}Can not populate unipartite graph with symmetric matrix"{}} << std::endl;}
\DoxyCodeLine{255     \textcolor{keywordflow}{throw};}
\DoxyCodeLine{256   \}}
\DoxyCodeLine{257   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n0 != n1 \&\& \textcolor{keyword}{false} == is\_unipartite<edge\_list\_t>::value)\{}
\DoxyCodeLine{258     \textcolor{comment}{//bipartite edge list}}
\DoxyCodeLine{259     \textcolor{keywordflow}{if} (file\_symmetry) \{}
\DoxyCodeLine{260       std::cerr << \textcolor{stringliteral}{"{}Can not populate bipartite graph with symmetric matrix"{}} << std::endl;}
\DoxyCodeLine{261       \textcolor{keywordflow}{throw};}
\DoxyCodeLine{262     \}}
\DoxyCodeLine{263     bi\_edge\_list<sym, Attributes...> A(n0, n1);}
\DoxyCodeLine{264     mm\_fill(inputStream, A, nNonzeros, file\_symmetry, (header[3] == \textcolor{stringliteral}{"{}pattern"{}}));}
\DoxyCodeLine{265 }
\DoxyCodeLine{266     \textcolor{keywordflow}{return} A;}
\DoxyCodeLine{267   \}}
\DoxyCodeLine{268   \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{269     std::cerr << \textcolor{stringliteral}{"{}Mismatch edge list type with matrix symmetry"{}} << std::endl;}
\DoxyCodeLine{270     \textcolor{keywordflow}{throw};    }
\DoxyCodeLine{271   \}}
\DoxyCodeLine{272 \}}
\DoxyCodeLine{273 }
\DoxyCodeLine{274 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{275 \textcolor{keyword}{auto} read\_mm\_vector(std::istream\& inputStream) \{}
\DoxyCodeLine{276   std::string string\_input;}
\DoxyCodeLine{277   \textcolor{keywordtype}{bool}        file\_symmetry = \textcolor{keyword}{false};}
\DoxyCodeLine{278   (void)file\_symmetry;    \textcolor{comment}{// silence warnings}}
\DoxyCodeLine{279   std::vector<std::string> header(5);}
\DoxyCodeLine{280 }
\DoxyCodeLine{281   \textcolor{comment}{// \%\%MatrixMarket matrix array real general}}
\DoxyCodeLine{282   \textcolor{comment}{// 64 1}}
\DoxyCodeLine{283   std::getline(inputStream, string\_input);}
\DoxyCodeLine{284   std::stringstream h(string\_input);}
\DoxyCodeLine{285   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& s : header)}
\DoxyCodeLine{286     h >> s;}
\DoxyCodeLine{287 }
\DoxyCodeLine{288   \textcolor{keywordflow}{if} (header[0] != \textcolor{stringliteral}{"{}\%\%MatrixMarket"{}}) \{}
\DoxyCodeLine{289     std::cerr << \textcolor{stringliteral}{"{}Unsupported format"{}} << std::endl;}
\DoxyCodeLine{290     \textcolor{keywordflow}{throw};}
\DoxyCodeLine{291   \}}
\DoxyCodeLine{292   \textcolor{keywordflow}{if} (header[4] == \textcolor{stringliteral}{"{}symmetric"{}}) \{}
\DoxyCodeLine{293     file\_symmetry = \textcolor{keyword}{true};}
\DoxyCodeLine{294   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (header[4] == \textcolor{stringliteral}{"{}general"{}}) \{}
\DoxyCodeLine{295     file\_symmetry = \textcolor{keyword}{false};}
\DoxyCodeLine{296   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{297     std::cerr << \textcolor{stringliteral}{"{}Bad format (symmetry): "{}} << header[4] << std::endl;}
\DoxyCodeLine{298     \textcolor{keywordflow}{throw};}
\DoxyCodeLine{299   \}}
\DoxyCodeLine{300 }
\DoxyCodeLine{301   \textcolor{keywordflow}{while} (std::getline(inputStream, string\_input)) \{}
\DoxyCodeLine{302     \textcolor{keywordflow}{if} (string\_input[0] != \textcolor{charliteral}{'\%'}) \textcolor{keywordflow}{break};}
\DoxyCodeLine{303   \}}
\DoxyCodeLine{304   \textcolor{keywordtype}{size\_t} n0, n1;}
\DoxyCodeLine{305   std::stringstream(string\_input) >> n0 >> n1;}
\DoxyCodeLine{306 }
\DoxyCodeLine{307   assert(1 == n1);}
\DoxyCodeLine{308 }
\DoxyCodeLine{309   std::vector<T> vec(n0);}
\DoxyCodeLine{310 }
\DoxyCodeLine{311   \textcolor{keywordflow}{if} (header[3] == \textcolor{stringliteral}{"{}real"{}}) \{}
\DoxyCodeLine{312     \textcolor{keywordtype}{double} d;}
\DoxyCodeLine{313     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n0; ++i) \{}
\DoxyCodeLine{314       inputStream >> d;}
\DoxyCodeLine{315       vec[i] = d -\/ 1;}
\DoxyCodeLine{316     \}}
\DoxyCodeLine{317   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{318     \textcolor{keywordtype}{size\_t} d;}
\DoxyCodeLine{319     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n0; ++i) \{}
\DoxyCodeLine{320       inputStream >> d;}
\DoxyCodeLine{321       vec[i] = d -\/ 1;}
\DoxyCodeLine{322     \}}
\DoxyCodeLine{323   \}}
\DoxyCodeLine{324 }
\DoxyCodeLine{325   \textcolor{keywordflow}{return} vec;}
\DoxyCodeLine{326 \}}
\DoxyCodeLine{327 }
\DoxyCodeLine{328 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{329 \textcolor{keyword}{auto} read\_mm\_vector(\textcolor{keyword}{const} std::string\& filename) \{}
\DoxyCodeLine{330   std::ifstream inputFile(filename);}
\DoxyCodeLine{331 }
\DoxyCodeLine{332   \textcolor{keyword}{auto} v = read\_mm\_vector<T>(inputFile);}
\DoxyCodeLine{333 }
\DoxyCodeLine{334   \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{335 \}}
\DoxyCodeLine{336 }
\DoxyCodeLine{337 \textcolor{keywordtype}{bool} is\_mm(\textcolor{keyword}{const} std::string filename) \{}
\DoxyCodeLine{338   std::ifstream            input\_stream(filename);}
\DoxyCodeLine{339   std::vector<std::string> header(5);}
\DoxyCodeLine{340 }
\DoxyCodeLine{341   std::string buf;}
\DoxyCodeLine{342   std::getline(input\_stream, buf);}
\DoxyCodeLine{343   std::stringstream h(buf);}
\DoxyCodeLine{344   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& s : header) \{}
\DoxyCodeLine{345     h >> s;}
\DoxyCodeLine{346   \}}
\DoxyCodeLine{347 }
\DoxyCodeLine{348   \textcolor{keywordflow}{return} header[0] == \textcolor{stringliteral}{"{}\%\%MatrixMarket"{}};}
\DoxyCodeLine{349 \}}
\DoxyCodeLine{350 }
\DoxyCodeLine{351 directedness get\_mm\_symmetry(\textcolor{keyword}{const} std::string filename) \{}
\DoxyCodeLine{352   std::ifstream            inputStream(filename);}
\DoxyCodeLine{353   std::string              string\_input;}
\DoxyCodeLine{354   std::vector<std::string> header(5);}
\DoxyCodeLine{355 }
\DoxyCodeLine{356   \textcolor{comment}{// \%\%MatrixMarket matrix coordinate integer symmetric}}
\DoxyCodeLine{357   std::getline(inputStream, string\_input);}
\DoxyCodeLine{358   std::stringstream h(string\_input);}
\DoxyCodeLine{359   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& s : header) \{}
\DoxyCodeLine{360     h >> s;}
\DoxyCodeLine{361   \}}
\DoxyCodeLine{362 }
\DoxyCodeLine{363   \textcolor{keywordflow}{if} (header[0] != \textcolor{stringliteral}{"{}\%\%MatrixMarket"{}}) \{}
\DoxyCodeLine{364     std::cerr << \textcolor{stringliteral}{"{}Unsupported format: "{}} << header[0] << std::endl;}
\DoxyCodeLine{365     \textcolor{keywordflow}{throw};}
\DoxyCodeLine{366   \}}
\DoxyCodeLine{367   \textcolor{keywordflow}{if} (header[4] == \textcolor{stringliteral}{"{}symmetric"{}}) \{}
\DoxyCodeLine{368     \textcolor{keywordflow}{return} directedness::undirected;}
\DoxyCodeLine{369   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{370     \textcolor{keywordflow}{return} directedness::directed;}
\DoxyCodeLine{371   \}}
\DoxyCodeLine{372 \}}
\DoxyCodeLine{373 }
\DoxyCodeLine{374 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} w\_idx, directedness sym, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{375 \textcolor{keywordtype}{void} aos\_stream(std::ofstream\& outputStream, edge\_list<sym, Attributes...> A, \textcolor{keyword}{const} std::string\& file\_symmetry, std::string\& w\_type) \{}
\DoxyCodeLine{376   outputStream << \textcolor{stringliteral}{"{}\%\%MatrixMarket matrix coordinate "{}} << w\_type << \textcolor{stringliteral}{"{} "{}} << file\_symmetry << \textcolor{stringliteral}{"{}\(\backslash\)n\%\%\(\backslash\)n"{}};}
\DoxyCodeLine{377 }
\DoxyCodeLine{378   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (is\_unipartite<edge\_list<sym, Attributes...>>::value) \{}
\DoxyCodeLine{379     outputStream << num\_vertices(A) << \textcolor{stringliteral}{"{} "{}} << num\_vertices(A) << \textcolor{stringliteral}{"{} "{}};    \textcolor{comment}{// + 1 ???}}
\DoxyCodeLine{380   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{381     outputStream << num\_vertices(A, 0) << \textcolor{stringliteral}{"{} "{}} << num\_vertices(A, 1) << \textcolor{stringliteral}{"{} "{}};    \textcolor{comment}{// + 1 ???}}
\DoxyCodeLine{382   \}}
\DoxyCodeLine{383 }
\DoxyCodeLine{384   \textcolor{keywordflow}{if} (file\_symmetry == \textcolor{stringliteral}{"{}general"{}} \&\& sym == directedness::undirected)}
\DoxyCodeLine{385     outputStream << 2 * (A.end() -\/ A.begin()) << std::endl;}
\DoxyCodeLine{386   \textcolor{keywordflow}{else}}
\DoxyCodeLine{387     outputStream << A.end() -\/ A.begin() << std::endl;}
\DoxyCodeLine{388 }
\DoxyCodeLine{389   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& element : A) \{}
\DoxyCodeLine{390     outputStream << std::get<0>(element) + 1 << \textcolor{stringliteral}{"{} "{}} << std::get<1>(element) + 1;}
\DoxyCodeLine{391     \textcolor{keywordflow}{if} (w\_idx != 0) outputStream << \textcolor{stringliteral}{"{} "{}} << std::get<w\_idx>(element);}
\DoxyCodeLine{392     outputStream << std::endl;}
\DoxyCodeLine{393     \textcolor{keywordflow}{if} (file\_symmetry == \textcolor{stringliteral}{"{}general"{}} \&\& sym == directedness::undirected) \{}
\DoxyCodeLine{394       outputStream << std::get<1>(element) + 1 << \textcolor{stringliteral}{"{} "{}} << std::get<0>(element) + 1;}
\DoxyCodeLine{395       \textcolor{keywordflow}{if} (w\_idx != 0) outputStream << \textcolor{stringliteral}{"{} "{}} << std::get<w\_idx>(element);}
\DoxyCodeLine{396       outputStream << std::endl;}
\DoxyCodeLine{397     \}}
\DoxyCodeLine{398   \}}
\DoxyCodeLine{399 \}}
\DoxyCodeLine{400 }
\DoxyCodeLine{401 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} w\_idx = 0, \textcolor{keyword}{typename} idxtype = void, directedness sym, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{402 \textcolor{keywordtype}{void} write\_mm(\textcolor{keyword}{const} std::string\& filename, edge\_list<sym, Attributes...>\& A, \textcolor{keyword}{const} std::string\& file\_symmetry = \textcolor{stringliteral}{"{}general"{}}) \{}
\DoxyCodeLine{403   \textcolor{keywordflow}{if} (file\_symmetry == \textcolor{stringliteral}{"{}symmetric"{}} \&\& sym == directedness::directed) \{}
\DoxyCodeLine{404     std::cerr << \textcolor{stringliteral}{"{}cannot save directed matrix as symmetric matrix market"{}} << std::endl;}
\DoxyCodeLine{405   \}}
\DoxyCodeLine{406 }
\DoxyCodeLine{407   std::string w\_type = \textcolor{stringliteral}{"{}pattern"{}};}
\DoxyCodeLine{408   \textcolor{keywordflow}{if} (std::numeric\_limits<idxtype>::is\_integer)}
\DoxyCodeLine{409     w\_type = \textcolor{stringliteral}{"{}integer"{}};}
\DoxyCodeLine{410   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (std::is\_floating\_point<idxtype>::value)}
\DoxyCodeLine{411     w\_type = \textcolor{stringliteral}{"{}real"{}};}
\DoxyCodeLine{412 }
\DoxyCodeLine{413   std::ofstream outputStream(filename);}
\DoxyCodeLine{414   aos\_stream<w\_idx>(outputStream, A, file\_symmetry, w\_type);}
\DoxyCodeLine{415 \}}
\DoxyCodeLine{416 }
\DoxyCodeLine{417 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} w\_idx, \textcolor{keywordtype}{int} idx, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{418 \textcolor{keywordtype}{void} adjacency\_stream(std::ofstream\& outputStream, adjacency<idx, Attributes...>\& A, \textcolor{keyword}{const} std::string\& file\_symmetry, std::string\& w\_type) \{}
\DoxyCodeLine{419   outputStream << \textcolor{stringliteral}{"{}\%\%MatrixMarket matrix coordinate "{}} << w\_type << \textcolor{stringliteral}{"{} "{}} << file\_symmetry << \textcolor{stringliteral}{"{}\(\backslash\)n\%\%\(\backslash\)n"{}};}
\DoxyCodeLine{420 }
\DoxyCodeLine{421   outputStream << num\_vertices(A) << \textcolor{stringliteral}{"{} "{}} << num\_vertices(A) << \textcolor{stringliteral}{"{} "{}}}
\DoxyCodeLine{422                << std::accumulate(A.begin(), A.end(), 0, [\&](\textcolor{keywordtype}{int} a, \textcolor{keyword}{auto} b) \{ return a + (int)(b.end() -\/ b.begin()); \}) << std::endl;}
\DoxyCodeLine{423 }
\DoxyCodeLine{424   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} first = A.begin(); first != A.end(); ++first) \{}
\DoxyCodeLine{425     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} v = (*first).begin(); v != (*first).end(); ++v) \{}
\DoxyCodeLine{426       outputStream << first -\/ A.begin() + (1 -\/ idx) << \textcolor{stringliteral}{"{} "{}} << std::get<0>(*v) + (1 -\/ idx);}
\DoxyCodeLine{427       \textcolor{keywordflow}{if} (w\_idx != 0) outputStream << \textcolor{stringliteral}{"{} "{}} << std::get<w\_idx>(*v);}
\DoxyCodeLine{428       outputStream << std::endl;}
\DoxyCodeLine{429     \}}
\DoxyCodeLine{430   \}}
\DoxyCodeLine{431 \}}
\DoxyCodeLine{432 }
\DoxyCodeLine{433 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} w\_idx = 0, \textcolor{keyword}{typename} idxtype = void, \textcolor{keywordtype}{int} idx, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{434 \textcolor{keywordtype}{void} write\_mm(\textcolor{keyword}{const} std::string\& filename, adjacency<idx, Attributes...>\& A, \textcolor{keyword}{const} std::string\& file\_symmetry = \textcolor{stringliteral}{"{}general"{}}) \{}
\DoxyCodeLine{435   \textcolor{comment}{/*if (file\_symmetry == "{}symmetric"{} \&\& sym == directedness::directed) \{}}
\DoxyCodeLine{436 \textcolor{comment}{    std::cerr << "{}cannot save directed matrix as symmetric matrix market"{} << std::endl;}}
\DoxyCodeLine{437 \textcolor{comment}{  \}*/}}
\DoxyCodeLine{438 }
\DoxyCodeLine{439   std::string w\_type = \textcolor{stringliteral}{"{}pattern"{}};}
\DoxyCodeLine{440   \textcolor{keywordflow}{if} (std::numeric\_limits<idxtype>::is\_integer)}
\DoxyCodeLine{441     w\_type = \textcolor{stringliteral}{"{}integer"{}};}
\DoxyCodeLine{442   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (std::is\_floating\_point<idxtype>::value)}
\DoxyCodeLine{443     w\_type = \textcolor{stringliteral}{"{}real"{}};}
\DoxyCodeLine{444 }
\DoxyCodeLine{445   std::ofstream outputStream(filename);}
\DoxyCodeLine{446   adjacency\_stream<w\_idx>(outputStream, A, file\_symmetry, w\_type);}
\DoxyCodeLine{447 \}}
\DoxyCodeLine{448 }
\DoxyCodeLine{449 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} w\_idx, \textcolor{keywordtype}{int} idx, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{450 \textcolor{keywordtype}{void} adjacency\_stream(std::ofstream\& outputStream, biadjacency<idx, Attributes...>\& A, \textcolor{keyword}{const} std::string\& file\_symmetry, std::string\& w\_type) \{}
\DoxyCodeLine{451   outputStream << \textcolor{stringliteral}{"{}\%\%MatrixMarket matrix coordinate "{}} << w\_type << \textcolor{stringliteral}{"{} "{}} << file\_symmetry << \textcolor{stringliteral}{"{}\(\backslash\)n\%\%\(\backslash\)n"{}};}
\DoxyCodeLine{452 }
\DoxyCodeLine{453   outputStream << num\_vertices(A, 0) << \textcolor{stringliteral}{"{} "{}} << num\_vertices(A, 1) << \textcolor{stringliteral}{"{} "{}}}
\DoxyCodeLine{454                << std::accumulate(A.begin(), A.end(), 0, [\&](\textcolor{keywordtype}{int} a, \textcolor{keyword}{auto} b) \{ return a + (int)(b.end() -\/ b.begin()); \}) << std::endl;}
\DoxyCodeLine{455 }
\DoxyCodeLine{456   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} first = A.begin(); first != A.end(); ++first) \{}
\DoxyCodeLine{457     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} v = (*first).begin(); v != (*first).end(); ++v) \{}
\DoxyCodeLine{458       outputStream << first -\/ A.begin() + (1 -\/ idx) << \textcolor{stringliteral}{"{} "{}} << std::get<0>(*v) + (1 -\/ idx);}
\DoxyCodeLine{459       \textcolor{keywordflow}{if} (w\_idx != 0) outputStream << \textcolor{stringliteral}{"{} "{}} << std::get<w\_idx>(*v);}
\DoxyCodeLine{460       outputStream << std::endl;}
\DoxyCodeLine{461     \}}
\DoxyCodeLine{462   \}}
\DoxyCodeLine{463 \}}
\DoxyCodeLine{464 }
\DoxyCodeLine{465 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} w\_idx = 0, \textcolor{keyword}{typename} idxtype = void, \textcolor{keywordtype}{int} idx, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{466 \textcolor{keywordtype}{void} write\_mm(\textcolor{keyword}{const} std::string\& filename, biadjacency<idx, Attributes...>\& A, \textcolor{keyword}{const} std::string\& file\_symmetry = \textcolor{stringliteral}{"{}general"{}}) \{}
\DoxyCodeLine{467   \textcolor{comment}{/*if (file\_symmetry == "{}symmetric"{} \&\& sym == directedness::directed) \{}}
\DoxyCodeLine{468 \textcolor{comment}{    std::cerr << "{}cannot save directed matrix as symmetric matrix market"{} << std::endl;}}
\DoxyCodeLine{469 \textcolor{comment}{  \}*/}}
\DoxyCodeLine{470 }
\DoxyCodeLine{471   std::string w\_type = \textcolor{stringliteral}{"{}pattern"{}};}
\DoxyCodeLine{472   \textcolor{keywordflow}{if} (std::numeric\_limits<idxtype>::is\_integer)}
\DoxyCodeLine{473     w\_type = \textcolor{stringliteral}{"{}integer"{}};}
\DoxyCodeLine{474   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (std::is\_floating\_point<idxtype>::value)}
\DoxyCodeLine{475     w\_type = \textcolor{stringliteral}{"{}real"{}};}
\DoxyCodeLine{476 }
\DoxyCodeLine{477   std::ofstream outputStream(filename);}
\DoxyCodeLine{478   adjacency\_stream<w\_idx>(outputStream, A, file\_symmetry, w\_type);}
\DoxyCodeLine{479 \}}
\DoxyCodeLine{480 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{481 }
\DoxyCodeLine{482 \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} block\_min(\textcolor{keywordtype}{int} thread, \textcolor{keywordtype}{size\_t} M, \textcolor{keywordtype}{int} threads) \{}
\DoxyCodeLine{483   \textcolor{keywordtype}{size\_t}         block = M / threads;}
\DoxyCodeLine{484   \textcolor{keywordtype}{int}            rem = M \% threads;}
\DoxyCodeLine{485   \textcolor{keywordflow}{return} thread*block + std::min(thread, rem);}
\DoxyCodeLine{486 \}}
\DoxyCodeLine{487 }
\DoxyCodeLine{488 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{489 std::tuple<size\_t, std::array<vertex\_id\_type, 2>, std::array<vertex\_id\_type, 2>>}
\DoxyCodeLine{490 par\_load\_mm(\mbox{\hyperlink{classmmio_1_1_matrix_market_file}{mmio::MatrixMarketFile}}\& mmio, std::vector<std::vector<std::tuple<size\_t, size\_t, T>>>\& sub\_lists, std::vector<std::vector<std::tuple<size\_t, size\_t, T>>>\& sub\_loops, \textcolor{keywordtype}{bool} keep\_loops, \textcolor{keywordtype}{size\_t} threads) \{}
\DoxyCodeLine{491   \textcolor{comment}{//mmio::MatrixMarketFile mmio(filename);}}
\DoxyCodeLine{492   std::array<vertex\_id\_type, 2> Gi\_min = \{std::numeric\_limits<vertex\_id\_type>::max(), std::numeric\_limits<vertex\_id\_type>::max()\};}
\DoxyCodeLine{493   std::array<vertex\_id\_type, 2> Gi\_max = \{0, 0\};}
\DoxyCodeLine{494   std::vector<std::future<std::tuple<size\_t, std::array<vertex\_id\_type, 2>, std::array<vertex\_id\_type, 2>>>> futures(threads);}
\DoxyCodeLine{495   \textcolor{keywordflow}{for} (std::size\_t tid = 0; tid < threads; ++tid) \{}
\DoxyCodeLine{496     futures[tid] = std::async(std::launch::async, }
\DoxyCodeLine{497       [\&](\textcolor{keywordtype}{size\_t} thread) \{}
\DoxyCodeLine{498         \textcolor{keywordtype}{size\_t} GN = mmio.getNCols();}
\DoxyCodeLine{499         \textcolor{keywordtype}{size\_t} GM = mmio.getNEdges();}
\DoxyCodeLine{500 }
\DoxyCodeLine{501         \textcolor{comment}{// figure out which edges I'm going to read from the file}}
\DoxyCodeLine{502         \textcolor{keywordtype}{size\_t} min = block\_min(thread, GM, threads);}
\DoxyCodeLine{503         \textcolor{keywordtype}{size\_t} max = block\_min(thread + 1, GM, threads);}
\DoxyCodeLine{504 }
\DoxyCodeLine{505         std::array<vertex\_id\_type, 2> i\_min = \{std::numeric\_limits<vertex\_id\_type>::max(), std::numeric\_limits<vertex\_id\_type>::max()\};}
\DoxyCodeLine{506         std::array<vertex\_id\_type, 2> i\_max = \{0, 0\};}
\DoxyCodeLine{507 }
\DoxyCodeLine{508         \textcolor{comment}{// slightly oversize to try and avoid resizing}}
\DoxyCodeLine{509         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{double} scale = 1.1;}
\DoxyCodeLine{510         sub\_lists[thread].reserve(scale*(max-\/min));}
\DoxyCodeLine{511         \textcolor{keywordtype}{size\_t} count = 0;}
\DoxyCodeLine{512 }
\DoxyCodeLine{513         \textcolor{comment}{// read edge data from the file}}
\DoxyCodeLine{514         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& [u, v, w] : mmio::edges<T>(mmio, min, max)) \{}
\DoxyCodeLine{515           i\_min[0] = std::min((vertex\_id\_type)u, i\_min[0]);}
\DoxyCodeLine{516           i\_min[1] = std::min((vertex\_id\_type)v, i\_min[1]);}
\DoxyCodeLine{517           i\_max[0] = std::max((vertex\_id\_type)u, i\_max[0]);}
\DoxyCodeLine{518           i\_max[1] = std::max((vertex\_id\_type)v, i\_max[1]);}
\DoxyCodeLine{519 }
\DoxyCodeLine{520           \textcolor{keywordflow}{if}(u == v \&\& keep\_loops) \{}
\DoxyCodeLine{521             \textcolor{keywordflow}{if}(mmio.isPattern()) \{}
\DoxyCodeLine{522               sub\_loops[thread].push\_back(std::tuple(u-\/1, v-\/1, T(1)));}
\DoxyCodeLine{523             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{524               sub\_loops[thread].push\_back(std::tuple(u-\/1, v-\/1, w));}
\DoxyCodeLine{525             \}}
\DoxyCodeLine{526           \}}
\DoxyCodeLine{527           \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{528             \textcolor{keywordflow}{if}(mmio.isPattern()) \{}
\DoxyCodeLine{529               sub\_lists[thread].push\_back(std::tuple(u-\/1, v-\/1, T(1)));}
\DoxyCodeLine{530             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{531               sub\_lists[thread].push\_back(std::tuple(u-\/1, v-\/1, w));}
\DoxyCodeLine{532             \}}
\DoxyCodeLine{533             ++count;}
\DoxyCodeLine{534           \}}
\DoxyCodeLine{535         \}}
\DoxyCodeLine{536         \textcolor{keywordflow}{return} std::tuple(count, i\_min, i\_max);}
\DoxyCodeLine{537       \}, tid);}
\DoxyCodeLine{538   \}}
\DoxyCodeLine{539   std::size\_t entries = 0;}
\DoxyCodeLine{540   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& f : futures) \{}
\DoxyCodeLine{541     \textcolor{keyword}{auto} res = f.get();}
\DoxyCodeLine{542     entries += std::get<0>(res);}
\DoxyCodeLine{543     Gi\_min[0] = std::min(std::get<1>(res)[0], Gi\_min[0]);}
\DoxyCodeLine{544     Gi\_min[1] = std::min(std::get<1>(res)[1], Gi\_min[1]);}
\DoxyCodeLine{545     Gi\_max[0] = std::max(std::get<2>(res)[0], Gi\_max[0]);}
\DoxyCodeLine{546     Gi\_max[1] = std::max(std::get<2>(res)[1], Gi\_max[1]);}
\DoxyCodeLine{547   \}}
\DoxyCodeLine{548   }
\DoxyCodeLine{549   \textcolor{keywordflow}{return} std::tuple(entries, Gi\_min, Gi\_max);}
\DoxyCodeLine{550 \}}
\DoxyCodeLine{551 }
\DoxyCodeLine{552 std::tuple<size\_t, std::array<vertex\_id\_type, 2>, std::array<vertex\_id\_type, 2>>}
\DoxyCodeLine{553 par\_load\_mm(\mbox{\hyperlink{classmmio_1_1_matrix_market_file}{mmio::MatrixMarketFile}}\& mmio, std::vector<std::vector<std::tuple<size\_t, size\_t>>>\& sub\_lists, std::vector<std::vector<std::tuple<size\_t, size\_t>>>\& sub\_loops, \textcolor{keywordtype}{bool} keep\_loops, \textcolor{keywordtype}{size\_t} threads) \{}
\DoxyCodeLine{554   std::array<vertex\_id\_type, 2> Gi\_min = \{std::numeric\_limits<vertex\_id\_type>::max(), std::numeric\_limits<vertex\_id\_type>::max()\};}
\DoxyCodeLine{555   std::array<vertex\_id\_type, 2> Gi\_max = \{0, 0\};}
\DoxyCodeLine{556   std::vector<std::future<std::tuple<size\_t, std::array<vertex\_id\_type, 2>, std::array<vertex\_id\_type, 2>>>> futures(threads);}
\DoxyCodeLine{557   \textcolor{keywordflow}{for} (std::size\_t tid = 0; tid < threads; ++tid) \{}
\DoxyCodeLine{558     futures[tid] = std::async(std::launch::async, }
\DoxyCodeLine{559       [\&](\textcolor{keywordtype}{size\_t} thread) \{}
\DoxyCodeLine{560         }
\DoxyCodeLine{561         \textcolor{keywordtype}{size\_t} GN = mmio.getNCols();}
\DoxyCodeLine{562         \textcolor{keywordtype}{size\_t} GM = mmio.getNEdges();}
\DoxyCodeLine{563 }
\DoxyCodeLine{564         \textcolor{comment}{// figure out which edges I'm going to read from the file}}
\DoxyCodeLine{565         \textcolor{keywordtype}{size\_t} min = block\_min(thread, GM, threads);}
\DoxyCodeLine{566         \textcolor{keywordtype}{size\_t} max = block\_min(thread + 1, GM, threads);}
\DoxyCodeLine{567 }
\DoxyCodeLine{568         std::array<vertex\_id\_type, 2> i\_min = \{std::numeric\_limits<vertex\_id\_type>::max(), std::numeric\_limits<vertex\_id\_type>::max()\};}
\DoxyCodeLine{569         std::array<vertex\_id\_type, 2> i\_max = \{0, 0\};}
\DoxyCodeLine{570 }
\DoxyCodeLine{571         \textcolor{comment}{// slightly oversize to try and avoid resizing}}
\DoxyCodeLine{572         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{double} scale = 1.1;}
\DoxyCodeLine{573         sub\_lists[thread].reserve(scale*(max-\/min));}
\DoxyCodeLine{574         \textcolor{keywordtype}{size\_t} count = 0;}
\DoxyCodeLine{575 }
\DoxyCodeLine{576         \textcolor{comment}{// read edge data from the file}}
\DoxyCodeLine{577         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& [u, v] : mmio::edges<>(mmio, min, max)) \{}
\DoxyCodeLine{578           i\_min[0] = std::min((vertex\_id\_type)u, i\_min[0]);}
\DoxyCodeLine{579           i\_min[1] = std::min((vertex\_id\_type)v, i\_min[1]);}
\DoxyCodeLine{580           i\_max[0] = std::max((vertex\_id\_type)u, i\_max[0]);}
\DoxyCodeLine{581           i\_max[1] = std::max((vertex\_id\_type)v, i\_max[1]);}
\DoxyCodeLine{582 }
\DoxyCodeLine{583           \textcolor{keywordflow}{if}(u == v \&\& keep\_loops) \{}
\DoxyCodeLine{584             sub\_loops[thread].push\_back(std::tuple(u-\/1,v-\/1));}
\DoxyCodeLine{585           \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{586             sub\_lists[thread].push\_back(std::tuple(u-\/1, v-\/1));}
\DoxyCodeLine{587             ++count;}
\DoxyCodeLine{588           \}}
\DoxyCodeLine{589         \}}
\DoxyCodeLine{590         \textcolor{keywordflow}{return} std::tuple(count, i\_min, i\_max);}
\DoxyCodeLine{591       \}, tid);}
\DoxyCodeLine{592   \}}
\DoxyCodeLine{593   std::size\_t entries = 0;}
\DoxyCodeLine{594   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& f : futures) \{}
\DoxyCodeLine{595     \textcolor{keyword}{auto} res = f.get();}
\DoxyCodeLine{596     entries += std::get<0>(res);}
\DoxyCodeLine{597     Gi\_min[0] = std::min(std::get<1>(res)[0], Gi\_min[0]);}
\DoxyCodeLine{598     Gi\_min[1] = std::min(std::get<1>(res)[1], Gi\_min[1]);}
\DoxyCodeLine{599     Gi\_max[0] = std::max(std::get<2>(res)[0], Gi\_max[0]);}
\DoxyCodeLine{600     Gi\_max[1] = std::max(std::get<2>(res)[1], Gi\_max[1]);}
\DoxyCodeLine{601   \}}
\DoxyCodeLine{602   \textcolor{keywordflow}{return} std::tuple(entries, Gi\_min, Gi\_max);}
\DoxyCodeLine{603 \}}
\DoxyCodeLine{604 }
\DoxyCodeLine{605 }
\DoxyCodeLine{606 \textcolor{keyword}{template} <directedness sym, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{607 edge\_list<sym, Attributes...> par\_read\_mm(\textcolor{keyword}{const} std::string\& filename, \textcolor{keywordtype}{bool} keep\_loops = \textcolor{keyword}{true}, \textcolor{keywordtype}{size\_t} threads = (\textcolor{keywordtype}{size\_t}) std::thread::hardware\_concurrency()) \{}
\DoxyCodeLine{608   \mbox{\hyperlink{classmmio_1_1_matrix_market_file}{mmio::MatrixMarketFile}} mmio(filename);}
\DoxyCodeLine{609   \textcolor{keywordflow}{if}(!mmio.isSymmetric() \&\& sym == undirected) \{}
\DoxyCodeLine{610     std::cerr << \textcolor{stringliteral}{"{}warning: requested undirected edge list, but mtx file is general"{}} << std::endl;}
\DoxyCodeLine{611   \}}
\DoxyCodeLine{612 }
\DoxyCodeLine{613   edge\_list<sym, Attributes...> A(mmio.getNCols());}
\DoxyCodeLine{614   std::vector<std::vector<std::tuple<size\_t, size\_t, Attributes...>>> sub\_lists(threads);}
\DoxyCodeLine{615   std::vector<std::vector<std::tuple<size\_t, size\_t, Attributes...>>> sub\_loops(threads);}
\DoxyCodeLine{616   }
\DoxyCodeLine{617   \textcolor{keyword}{auto} info = par\_load\_mm(mmio, sub\_lists, sub\_loops, keep\_loops, threads);}
\DoxyCodeLine{618   \textcolor{keywordflow}{if}(mmio.isSymmetric() \&\& sym == directed) \{}
\DoxyCodeLine{619     A.resize(std::get<0>(info)*2);}
\DoxyCodeLine{620   \}}
\DoxyCodeLine{621   \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{622     A.resize(std::get<0>(info));}
\DoxyCodeLine{623   \}}
\DoxyCodeLine{624   A.min\_ = std::get<1>(info);}
\DoxyCodeLine{625   A.max\_ = std::get<2>(info);}
\DoxyCodeLine{626 }
\DoxyCodeLine{627   mmio.\mbox{\hyperlink{classmmio_1_1_matrix_market_file_ad85445697beca19901e616047fc2c875}{release}}();}
\DoxyCodeLine{628   }
\DoxyCodeLine{629   std::vector<size\_t> offsets(threads+1);}
\DoxyCodeLine{630   offsets[0] = 0;}
\DoxyCodeLine{631   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} tid = 1; tid < threads; ++tid) \{}
\DoxyCodeLine{632     offsets[tid] = offsets[tid-\/1] + sub\_lists[tid-\/1].size();}
\DoxyCodeLine{633   \}}
\DoxyCodeLine{634   offsets[threads] = offsets[threads-\/1] + sub\_lists[threads-\/1].size();}
\DoxyCodeLine{635   }
\DoxyCodeLine{636   std::vector<std::future<void>> futures(threads);}
\DoxyCodeLine{637   \textcolor{keywordflow}{for} (std::size\_t tid = 0; tid < threads; ++tid) \{}
\DoxyCodeLine{638     futures[tid] = std::async(std::launch::async,}
\DoxyCodeLine{639       [\&](\textcolor{keywordtype}{size\_t} thread) \{}
\DoxyCodeLine{640     std::copy(std::execution::par\_unseq, sub\_lists[thread].begin(), sub\_lists[thread].end(), A.begin() + offsets[thread]);}
\DoxyCodeLine{641         \textcolor{keywordflow}{if}(mmio.isSymmetric() \&\& sym == directed) \{}
\DoxyCodeLine{642           std::transform(std::execution::par\_unseq, A.begin() + offsets[thread], A.begin() + offsets[thread+1], A.begin() + offsets[threads] + offsets[thread], [\&](\textcolor{keyword}{auto}\&\& e)\{}
\DoxyCodeLine{643             std::tuple<size\_t, size\_t, Attributes...> copy(e);}
\DoxyCodeLine{644             std::swap(std::get<0>(copy), std::get<1>(copy));}
\DoxyCodeLine{645             return copy;}
\DoxyCodeLine{646           \});}
\DoxyCodeLine{647     \}}
\DoxyCodeLine{648       \textcolor{keywordflow}{return};}
\DoxyCodeLine{649       \}, tid);}
\DoxyCodeLine{650   \}}
\DoxyCodeLine{651   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& f : futures) \{}
\DoxyCodeLine{652     f.get();}
\DoxyCodeLine{653   \}}
\DoxyCodeLine{654 }
\DoxyCodeLine{655   \textcolor{keywordflow}{if}(keep\_loops) \{}
\DoxyCodeLine{656     \textcolor{keywordtype}{size\_t} loops = 0;}
\DoxyCodeLine{657     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} t = 0; t < threads; ++t) \{}
\DoxyCodeLine{658       loops += sub\_loops[t].size();}
\DoxyCodeLine{659     \}}
\DoxyCodeLine{660     A.resize(A.size() + loops);}
\DoxyCodeLine{661     \textcolor{keywordtype}{size\_t} offset = offsets[threads];}
\DoxyCodeLine{662     \textcolor{keywordflow}{if}(mmio.isSymmetric() \&\& sym == directed) \{}
\DoxyCodeLine{663       offset *= 2;}
\DoxyCodeLine{664     \}}
\DoxyCodeLine{665     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} t = 0; t < threads; ++t) \{}
\DoxyCodeLine{666       std::copy(std::execution::par\_unseq, sub\_loops[t].begin(), sub\_loops[t].end(), A.begin() + offset);}
\DoxyCodeLine{667       offset += sub\_loops[t].size();}
\DoxyCodeLine{668     \}}
\DoxyCodeLine{669   \}}
\DoxyCodeLine{670  }
\DoxyCodeLine{671   A.close\_for\_push\_back();}
\DoxyCodeLine{672   A.set\_origin(filename);}
\DoxyCodeLine{673   }
\DoxyCodeLine{674   \textcolor{keywordflow}{return} A;}
\DoxyCodeLine{675 \}}
\DoxyCodeLine{676 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{677 }
\DoxyCodeLine{678 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{679 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{680 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// NW\_GRAPH\_MMIO\_HPP}}

\end{DoxyCode}
