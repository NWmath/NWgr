\hypertarget{max__flow_8hpp_source}{}\doxysection{max\+\_\+flow.\+hpp}
\label{max__flow_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/max\_flow.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/max\_flow.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_MAX\_FLOW\_HPP}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define NW\_GRAPH\_MAX\_FLOW\_HPP}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/back\_edge\_range.hpp"{}}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/filtered\_bfs\_range.hpp"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/reverse.hpp"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}nwgraph/util/util.hpp"{}}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{25 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{keyword}{static} \textcolor{keywordtype}{int} DEFAULT\_MAX = 1000;}
\DoxyCodeLine{28 \textcolor{keyword}{enum class} default\_dict \{ capacity\_idx = 1, flow\_idx = 2 \};}
\DoxyCodeLine{29 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} Idx, \textcolor{keyword}{typename} Edge>}
\DoxyCodeLine{30 \textcolor{keyword}{auto} backedge\_property(Edge edge) \{}
\DoxyCodeLine{31   \textcolor{keywordflow}{return} std::get<Idx>(edge);}
\DoxyCodeLine{32 \}}
\DoxyCodeLine{33 \textcolor{comment}{//****************************************************************************}}
\DoxyCodeLine{34 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Dict = default\_dict, \textcolor{keyword}{typename} flowtype = \textcolor{keywordtype}{double}, \textcolor{keyword}{typename} Graph>}
\DoxyCodeLine{35 flowtype max\_flow(\textcolor{keyword}{const} Graph\& A, vertex\_id\_type source, vertex\_id\_type sink, \textcolor{keywordtype}{size\_t} max\_iters = DEFAULT\_MAX) \{}
\DoxyCodeLine{36   \textcolor{keyword}{struct }tree\_edge \{}
\DoxyCodeLine{37     flowtype* capacity;}
\DoxyCodeLine{38     flowtype* flow;}
\DoxyCodeLine{39     flowtype* back\_flow;}
\DoxyCodeLine{40     \textcolor{keywordtype}{size\_t}    predecessor;}
\DoxyCodeLine{41   \};}
\DoxyCodeLine{42 }
\DoxyCodeLine{43   \textcolor{keywordtype}{size\_t}                 n\_vtx = A.size();}
\DoxyCodeLine{44   std::vector<tree\_edge> search\_tree(n\_vtx);}
\DoxyCodeLine{45   flowtype               maxflow = 0;}
\DoxyCodeLine{46 }
\DoxyCodeLine{47   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i <= max\_iters; ++i) \{}
\DoxyCodeLine{48     \textcolor{keyword}{auto} mf\_filter = [\&A](vertex\_id\_type vtx, \textcolor{keyword}{typename} Graph::inner\_iterator edge) \{}
\DoxyCodeLine{49       \textcolor{keywordflow}{return} property<idx(Dict::flow\_idx)>(edge) >=}
\DoxyCodeLine{50              property<idx(Dict::capacity\_idx)>(edge) + backedge\_property<idx(Dict::flow\_idx)>(A.get\_back\_edge(vtx, edge));}
\DoxyCodeLine{51     \};}
\DoxyCodeLine{52 }
\DoxyCodeLine{53     filtered\_bfs::filtered\_bfs\_edge\_range ranges(A, source, sink, mf\_filter);}
\DoxyCodeLine{54     \textcolor{keyword}{auto}                                  ite = ranges.begin();}
\DoxyCodeLine{55     \textcolor{keywordflow}{for} (; ite != ranges.end(); ++ite) \{}
\DoxyCodeLine{56       \textcolor{keyword}{auto} v                     = get\_source(ite);}
\DoxyCodeLine{57       \textcolor{keyword}{auto} u                     = get\_target(ite);}
\DoxyCodeLine{58       \textcolor{keyword}{auto} c                     = property\_ptr<idx(Dict::capacity\_idx)>(ite);}
\DoxyCodeLine{59       \textcolor{keyword}{auto} f                     = property\_ptr<idx(Dict::flow\_idx)>(ite);}
\DoxyCodeLine{60       search\_tree[u].capacity    = c;}
\DoxyCodeLine{61       search\_tree[u].flow        = f;}
\DoxyCodeLine{62       search\_tree[u].predecessor = v;}
\DoxyCodeLine{63       search\_tree[u].back\_flow   = \&std::get<idx(Dict::flow\_idx)>(A.get\_back\_edge(v, u));}
\DoxyCodeLine{64     \}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66     \textcolor{keywordflow}{if} (!ite.found()) \textcolor{keywordflow}{break};}
\DoxyCodeLine{67 }
\DoxyCodeLine{68     flowtype min\_cap     = 100000;}
\DoxyCodeLine{69     \textcolor{keywordtype}{size\_t}   path\_length = 0;}
\DoxyCodeLine{70     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} y : reverse\_path(search\_tree, sink, source)) \{}
\DoxyCodeLine{71       min\_cap = std::min(min\_cap, *(search\_tree[std::get<0>(y)].capacity) -\/ *(search\_tree[std::get<0>(y)].flow) +}
\DoxyCodeLine{72                                       *(search\_tree[std::get<0>(y)].back\_flow));}
\DoxyCodeLine{73       ++path\_length;}
\DoxyCodeLine{74     \}}
\DoxyCodeLine{75 }
\DoxyCodeLine{76     maxflow += min\_cap;}
\DoxyCodeLine{77     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} y : reverse\_path(search\_tree, sink, source)) \{}
\DoxyCodeLine{78       *(search\_tree[std::get<0>(y)].flow) += min\_cap;}
\DoxyCodeLine{79       \textcolor{keyword}{auto} excess = *(search\_tree[std::get<0>(y)].flow) -\/ *(search\_tree[std::get<0>(y)].capacity);}
\DoxyCodeLine{80       \textcolor{keywordflow}{if} (excess > 0) \{}
\DoxyCodeLine{81         *(search\_tree[std::get<0>(y)].flow) = *(search\_tree[std::get<0>(y)].capacity);}
\DoxyCodeLine{82         *(search\_tree[std::get<0>(y)].back\_flow) -\/= excess;}
\DoxyCodeLine{83       \}}
\DoxyCodeLine{84     \}}
\DoxyCodeLine{85   \}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87   \textcolor{keywordflow}{return} maxflow;}
\DoxyCodeLine{88 \}}
\DoxyCodeLine{89 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{90 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{91 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// NW\_GRAPH\_MAX\_FLOW\_HPP}}

\end{DoxyCode}
