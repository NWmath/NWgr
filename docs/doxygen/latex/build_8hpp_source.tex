\hypertarget{build_8hpp_source}{}\doxysection{build.\+hpp}
\label{build_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/build.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/build.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Luke D'Alessandro    }}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_BUILD\_HPP}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define NW\_GRAPH\_BUILD\_HPP}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include "{}util/print\_types.hpp"{}}}
\DoxyCodeLine{17 }
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}nwgraph/util/proxysort.hpp"{}}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_base.hpp"{}}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_traits.hpp"{}}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <atomic>}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <execution>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{preprocessor}{\#include "{}graph\_concepts.hpp"{}}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38 \textcolor{preprocessor}{\#include "{}nwgraph/containers/zip.hpp"{}}}
\DoxyCodeLine{39 }
\DoxyCodeLine{40 }
\DoxyCodeLine{41 }
\DoxyCodeLine{42 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{43 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{keyword}{using} default\_execution\_policy = std::execution::parallel\_unsequenced\_policy;}
\DoxyCodeLine{46 }
\DoxyCodeLine{47 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{48 \textcolor{keywordtype}{void} sort\_by(edge\_list\_t\& el, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{49   std::sort(std::execution::seq, el.begin(), el.end(),}
\DoxyCodeLine{50             [](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& a, \textcolor{keyword}{const} \textcolor{keyword}{auto}\& b) -\/> \textcolor{keywordtype}{bool} \{ return (std::get<idx>(a) < std::get<idx>(b)); \});}
\DoxyCodeLine{51 \}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{54 \textcolor{keywordtype}{void} stable\_sort\_by(edge\_list\_t\& el, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{55   std::stable\_sort(policy, el.begin(), el.end(), [](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& a, \textcolor{keyword}{const} \textcolor{keyword}{auto}\& b) -\/> \textcolor{keywordtype}{bool} \{ return (std::get<idx>(a) < std::get<idx>(b)); \});}
\DoxyCodeLine{56 \}}
\DoxyCodeLine{57 }
\DoxyCodeLine{58 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{59 \textcolor{keywordtype}{void} lexical\_sort\_by(edge\_list\_t\& el, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{60   \textcolor{keyword}{static\_assert}(std::is\_same\_v<\textcolor{keyword}{decltype}(el.begin()), \textcolor{keyword}{typename} edge\_list\_t::iterator>);}
\DoxyCodeLine{61 }
\DoxyCodeLine{62   \textcolor{keyword}{const} \textcolor{keywordtype}{int} jdx = (idx + 1) \% 2;}
\DoxyCodeLine{63 }
\DoxyCodeLine{64   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (idx == 0) \{}
\DoxyCodeLine{65     std::sort(policy, el.begin(), el.end());}
\DoxyCodeLine{66   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{67     std::sort(policy, el.begin(), el.end(), [](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& a, \textcolor{keyword}{const} \textcolor{keyword}{auto}\& b) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{68       return std::tie(std::get<1>(a), std::get<0>(a)) < std::tie(std::get<1>(b), std::get<0>(b));}
\DoxyCodeLine{69     \});}
\DoxyCodeLine{70   \}}
\DoxyCodeLine{71 \}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{74 \textcolor{keywordtype}{void} lexical\_stable\_sort\_by(edge\_list\_t\& el, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{75 }
\DoxyCodeLine{76   \textcolor{keyword}{const} \textcolor{keywordtype}{int} jdx = (idx + 1) \% 2;}
\DoxyCodeLine{77 }
\DoxyCodeLine{78   std::stable\_sort(policy, el.begin(), el.end(), [](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& a, \textcolor{keyword}{const} \textcolor{keyword}{auto}\& b) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{79     return std::tie(std::get<idx>(a), std::get<jdx>(a)) < std::tie(std::get<idx>(b), std::get<jdx>(b));}
\DoxyCodeLine{80   \});}
\DoxyCodeLine{81 \}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{keyword}{template} <adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{85 \textcolor{keyword}{auto} push\_back\_fill\_helper(adjacency\_t\& cs, std::tuple<Ts...> \textcolor{keyword}{const}\& theTuple) \{}
\DoxyCodeLine{86 }
\DoxyCodeLine{87   std::apply([\&](Ts \textcolor{keyword}{const}\&... args) \{ cs.push\_back(args...); \}, theTuple);}
\DoxyCodeLine{88 \}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90 \textcolor{keyword}{template} <edge\_list\_c edge\_list\_t, adjacency\_list\_graph adjacency\_t>}
\DoxyCodeLine{91 \textcolor{keywordtype}{void} push\_back\_fill(edge\_list\_t\& el, adjacency\_t\& cs) \{}
\DoxyCodeLine{92   cs.open\_for\_push\_back();}
\DoxyCodeLine{93 }
\DoxyCodeLine{94   std::for\_each(el.begin(), el.end(), [\&](\textcolor{keyword}{auto}\&\& elt) \{ push\_back\_fill\_helper(cs, elt); \});}
\DoxyCodeLine{95 }
\DoxyCodeLine{96   cs.close\_for\_push\_back();}
\DoxyCodeLine{97 \}}
\DoxyCodeLine{98 }
\DoxyCodeLine{102 \textcolor{keyword}{template} <edge\_list\_graph EdgeList, adjacency\_list\_graph Adjacency>}
\DoxyCodeLine{103 \textcolor{keywordtype}{void} push\_back\_fill(\textcolor{keyword}{const} EdgeList\& edge\_list, Adjacency\& adj, \textcolor{keywordtype}{bool} directed, \textcolor{keywordtype}{size\_t} idx) \{}
\DoxyCodeLine{104   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} jdx = (idx + 1) \% 2;}
\DoxyCodeLine{105 }
\DoxyCodeLine{106   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& e : edge\_list) \{}
\DoxyCodeLine{107     \textcolor{keywordflow}{if} (0 == idx) \{}
\DoxyCodeLine{108       std::apply(}
\DoxyCodeLine{109           [\&](\textcolor{keyword}{auto}... properties) \{}
\DoxyCodeLine{110             adj[std::get<0>(e)].emplace\_back(std::get<1>(e), properties...);}
\DoxyCodeLine{111           \},}
\DoxyCodeLine{112           props(e));}
\DoxyCodeLine{113       \textcolor{keywordflow}{if} (!directed) \{}
\DoxyCodeLine{114         std::apply(}
\DoxyCodeLine{115             [\&](\textcolor{keyword}{auto}... properties) \{}
\DoxyCodeLine{116               adj[std::get<1>(e)].emplace\_back(std::get<0>(e), properties...);}
\DoxyCodeLine{117             \},}
\DoxyCodeLine{118             props(e));}
\DoxyCodeLine{119       \}}
\DoxyCodeLine{120     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{121       std::apply(}
\DoxyCodeLine{122           [\&](\textcolor{keyword}{auto}... properties) \{}
\DoxyCodeLine{123             adj[std::get<1>(e)].emplace\_back(std::get<0>(e), properties...);}
\DoxyCodeLine{124           \},}
\DoxyCodeLine{125           props(e));}
\DoxyCodeLine{126       \textcolor{keywordflow}{if} (!directed) \{}
\DoxyCodeLine{127         std::apply(}
\DoxyCodeLine{128             [\&](\textcolor{keyword}{auto}... properties) \{}
\DoxyCodeLine{129               adj[std::get<0>(e)].emplace\_back(std::get<1>(e), properties...);}
\DoxyCodeLine{130             \},}
\DoxyCodeLine{131             props(e));}
\DoxyCodeLine{132       \}}
\DoxyCodeLine{133     \}}
\DoxyCodeLine{134   \}}
\DoxyCodeLine{135 \}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t, adjacency\_list\_graph adj\_list\_t>}
\DoxyCodeLine{138 \textcolor{keyword}{auto} fill\_adj\_list(edge\_list\_t\& el, adj\_list\_t\& al) \{}
\DoxyCodeLine{139   \textcolor{keywordtype}{size\_t} num\_edges = 0;}
\DoxyCodeLine{140 }
\DoxyCodeLine{141   al.open\_for\_push\_back();}
\DoxyCodeLine{142 }
\DoxyCodeLine{143   std::for\_each(el.begin(), el.end(), [\&](\textcolor{keyword}{auto} elt) \{}
\DoxyCodeLine{144     push\_back\_fill\_helper(al, elt);}
\DoxyCodeLine{145     ++num\_edges;}
\DoxyCodeLine{146     if constexpr (edge\_list\_t::edge\_directedness == directedness::undirected) \{}
\DoxyCodeLine{147       std::swap(std::get<0>(elt), std::get<1>(elt));}
\DoxyCodeLine{148       push\_back\_fill\_helper(al, elt);}
\DoxyCodeLine{149       ++num\_edges;}
\DoxyCodeLine{150     \}}
\DoxyCodeLine{151   \});}
\DoxyCodeLine{152 }
\DoxyCodeLine{153   al.close\_for\_push\_back();}
\DoxyCodeLine{154 }
\DoxyCodeLine{155   \textcolor{keywordflow}{return} num\_edges;}
\DoxyCodeLine{156 \}}
\DoxyCodeLine{157 }
\DoxyCodeLine{158 }
\DoxyCodeLine{159 \textcolor{keyword}{template} <\textcolor{keyword}{class} Vector1, \textcolor{keyword}{class} Vector2, \textcolor{keyword}{class} Perm>}
\DoxyCodeLine{160 \textcolor{keywordtype}{void} permute(\textcolor{keyword}{const} Vector1\& vec1, Vector2\& vec2, \textcolor{keyword}{const} Perm\& perm) \{}
\DoxyCodeLine{161   tbb::parallel\_for(tbb::blocked\_range(0ul, perm.size()), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{162     for (auto i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{163       vec2[i] = vec1[perm[i]];}
\DoxyCodeLine{164     \}}
\DoxyCodeLine{165   \});}
\DoxyCodeLine{166 \}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t, adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{class }Perm, \textcolor{keywordtype}{size\_t}... Is>}
\DoxyCodeLine{169 \textcolor{keywordtype}{void} permute\_helper(edge\_list\_t\& el, adjacency\_t\& cs, std::index\_sequence<Is...> is, \textcolor{keyword}{const} Perm\& perm) \{}
\DoxyCodeLine{170   (..., (permute(std::get<Is + 2>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)), std::get<Is + 1>(cs.to\_be\_indexed\_), perm)));}
\DoxyCodeLine{171 \}}
\DoxyCodeLine{172 }
\DoxyCodeLine{173 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t, adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{class }Perm, \textcolor{keywordtype}{size\_t}... Is>}
\DoxyCodeLine{174 \textcolor{keywordtype}{void} permute\_helper\_all(edge\_list\_t\& el, adjacency\_t\& cs, std::index\_sequence<Is...> is, \textcolor{keyword}{const} Perm\& perm) \{}
\DoxyCodeLine{175   (..., (permute(std::get<Is + 1>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)), std::get<Is>(cs.to\_be\_indexed\_), perm)));}
\DoxyCodeLine{176 \}}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 }
\DoxyCodeLine{179 }
\DoxyCodeLine{180 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t, adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{class }T, \textcolor{keyword}{class }Perm, \textcolor{keywordtype}{size\_t}... Is>}
\DoxyCodeLine{181 \textcolor{keywordtype}{void} permute\_helper(edge\_list\_t\& el, adjacency\_t\& cs, std::index\_sequence<Is...> is, T\& Tmp, Perm\& perm) \{}
\DoxyCodeLine{182   (..., (permute(std::get<Is + 2>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(Tmp)),std::get<Is + 1>(cs.to\_be\_indexed\_), perm)));}
\DoxyCodeLine{183 \}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 }
\DoxyCodeLine{186 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t, adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{class }ExecutionPolicy = default\_execution\_policy, \textcolor{keywordtype}{size\_t}... Is>}
\DoxyCodeLine{187 \textcolor{keywordtype}{void} fill\_helper(edge\_list\_t\& el, adjacency\_t\& cs, std::index\_sequence<Is...> is, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{188   (..., (std::copy(policy, std::get<Is + 2>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)).begin(),}
\DoxyCodeLine{189                    std::get<Is + 2>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)).end(), std::get<Is + 1>(cs.to\_be\_indexed\_).begin())));}
\DoxyCodeLine{190 \}}
\DoxyCodeLine{191 }
\DoxyCodeLine{192 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t, adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{class }ExecutionPolicy = default\_execution\_policy, \textcolor{keywordtype}{size\_t}... Is>}
\DoxyCodeLine{193 \textcolor{keywordtype}{void} copy\_helper(edge\_list\_t\& el, adjacency\_t\& cs, std::index\_sequence<Is...> is, \textcolor{keywordtype}{size\_t} offset, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{194   (..., (std::copy(policy, std::get<Is + 2>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)).begin(),}
\DoxyCodeLine{195                    std::get<Is + 2>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)).end(), std::get<Is + 1>(cs.to\_be\_indexed\_).begin()+offset)));}
\DoxyCodeLine{196 \}}
\DoxyCodeLine{197 }
\DoxyCodeLine{198 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t, adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{class }T, \textcolor{keyword}{class }ExecutionPolicy = default\_execution\_policy, \textcolor{keywordtype}{size\_t}... Is>}
\DoxyCodeLine{199 \textcolor{keywordtype}{void} fill\_helper\_tmp(edge\_list\_t\& el, adjacency\_t\& cs, std::index\_sequence<Is...> is, T\& Tmp, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{200   (..., (std::copy(policy, std::get<Is + 2>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(Tmp)).begin(),}
\DoxyCodeLine{201                    std::get<Is + 2>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(Tmp)).end(), std::get<Is + 1>(cs.to\_be\_indexed\_).begin())));}
\DoxyCodeLine{202 \}}
\DoxyCodeLine{203 }
\DoxyCodeLine{218 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{class} Int, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{219 \textcolor{keywordtype}{void} fill\_directed(edge\_list\_t\& el, Int N, adjacency\_t\& cs, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{220 }
\DoxyCodeLine{221   \textcolor{keyword}{auto} degree = degrees<idx>(el);}
\DoxyCodeLine{222 }
\DoxyCodeLine{223   cs.indices\_.resize(N + 1);}
\DoxyCodeLine{224   cs.indices\_[0] = 0;}
\DoxyCodeLine{225   std::inclusive\_scan(policy, degree.begin(), degree.end(), cs.indices\_.begin() + 1);}
\DoxyCodeLine{226   cs.to\_be\_indexed\_.resize(el.size());}
\DoxyCodeLine{227   }
\DoxyCodeLine{228 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{229 }
\DoxyCodeLine{230   sort\_by<idx>(el);  \textcolor{comment}{// Need to do this in a way that will let us have const el}}
\DoxyCodeLine{231                      \textcolor{comment}{// If not, we should steal (move) the vectors rather than copy}}
\DoxyCodeLine{232 }
\DoxyCodeLine{233   \textcolor{comment}{// Copy kdx (the other index)}}
\DoxyCodeLine{234   \textcolor{keyword}{const} \textcolor{keywordtype}{int} kdx = (idx + 1) \% 2;}
\DoxyCodeLine{235 }
\DoxyCodeLine{236   std::copy(policy, std::get<kdx>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)).begin(),}
\DoxyCodeLine{237         std::get<kdx>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)).end(), std::get<0>(cs.to\_be\_indexed\_).begin());}
\DoxyCodeLine{238   }
\DoxyCodeLine{239   \textcolor{comment}{// Copy properties}}
\DoxyCodeLine{240   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::tuple\_size<typename edge\_list\_t::attributes\_t>::value > 0) \{}
\DoxyCodeLine{241     fill\_helper(el, cs, std::make\_integer\_sequence<\textcolor{keywordtype}{size\_t}, std::tuple\_size<typename edge\_list\_t::attributes\_t>::value>(), policy);}
\DoxyCodeLine{242   \}}
\DoxyCodeLine{243 }
\DoxyCodeLine{244   \textcolor{comment}{// auto perm = proxysort(std::get<idx>(el));}}
\DoxyCodeLine{245   \textcolor{comment}{// permute(cs.to\_be\_indexed\_, perm, policy);}}
\DoxyCodeLine{246 }
\DoxyCodeLine{247 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{248   \textcolor{comment}{// Best: parallel insertion sort -\/-\/ need concurrent container safe for push\_at}}
\DoxyCodeLine{249 }
\DoxyCodeLine{250 }
\DoxyCodeLine{251   \textcolor{comment}{// Better yet}}
\DoxyCodeLine{252   \textcolor{keyword}{const} \textcolor{keywordtype}{int} kdx = (idx + 1) \% 2;}
\DoxyCodeLine{253   std::copy(policy, std::get<kdx>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)).begin(),}
\DoxyCodeLine{254         std::get<kdx>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)).end(), std::get<0>(cs.to\_be\_indexed\_).begin());}
\DoxyCodeLine{255   }
\DoxyCodeLine{256   \textcolor{comment}{// Copy properties}}
\DoxyCodeLine{257   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::tuple\_size<typename edge\_list\_t::attributes\_t>::value > 0) \{}
\DoxyCodeLine{258     fill\_helper(el, cs, std::make\_integer\_sequence<\textcolor{keywordtype}{size\_t}, std::tuple\_size<typename edge\_list\_t::attributes\_t>::value>(), policy);}
\DoxyCodeLine{259   \}}
\DoxyCodeLine{260 }
\DoxyCodeLine{261 }
\DoxyCodeLine{262   \textcolor{comment}{// which is faster?}}
\DoxyCodeLine{263   std::vector<nw::graph::vertex\_id\_t<adjacency\_t>> tmp(std::get<idx>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(el)));}
\DoxyCodeLine{264 }
\DoxyCodeLine{265   \textcolor{comment}{// this dumps core for some reason}}
\DoxyCodeLine{266   \textcolor{comment}{//std::vector<nw::graph::vertex\_id\_t<adjacency\_t>> tmp(std::get<idx>(dynamic\_cast<typename edge\_list\_t::base\&>(el)).size());}}
\DoxyCodeLine{267   \textcolor{comment}{//std::copy(policy, std::get<idx>(dynamic\_cast<typename edge\_list\_t::base\&>(el)).begin(),}}
\DoxyCodeLine{268   \textcolor{comment}{//        std::get<kdx>(dynamic\_cast<typename edge\_list\_t::base\&>(el)).end(), tmp.begin());}}
\DoxyCodeLine{269 }
\DoxyCodeLine{270   \textcolor{keyword}{auto} a = make\_zipped(tmp, cs.to\_be\_indexed\_);}
\DoxyCodeLine{271   std::sort(policy, a.begin(), a.end(), [](\textcolor{keyword}{auto} \&\&a, \textcolor{keyword}{auto}\&\&b) \{ return std::get<0>(a) < std::get<0>(b); \});}
\DoxyCodeLine{272 }
\DoxyCodeLine{273 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{274 \}}
\DoxyCodeLine{275 }
\DoxyCodeLine{276 }
\DoxyCodeLine{277 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} Int, adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{278 \textcolor{keywordtype}{void} fill\_undirected(edge\_list\_t\& el, Int N, adjacency\_t\& cs, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{279   \textcolor{comment}{//if the edge is undirected, it means the edge list must be a unipartite graph}}
\DoxyCodeLine{280   assert(is\_unipartite<typename edge\_list\_t::unipartite\_graph\_base>::value);}
\DoxyCodeLine{281 }
\DoxyCodeLine{282 \textcolor{preprocessor}{\#if 1}}
\DoxyCodeLine{283 }
\DoxyCodeLine{284   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<edge\_list\_t>;}
\DoxyCodeLine{285 }
\DoxyCodeLine{286   std::vector<vertex\_id\_type> Tmp(2*el.size());}
\DoxyCodeLine{287   \textcolor{keyword}{const} \textcolor{keywordtype}{int} kdx = (idx + 1) \% 2;}
\DoxyCodeLine{288 }
\DoxyCodeLine{289   std::copy(policy, std::get<idx>(el).begin(), std::get<idx>(el).end(), Tmp.begin());}
\DoxyCodeLine{290   std::copy(policy, std::get<kdx>(el).begin(), std::get<kdx>(el).end(), Tmp.begin()+el.size());}
\DoxyCodeLine{291 }
\DoxyCodeLine{292   \{}
\DoxyCodeLine{293     std::vector<vertex\_id\_type> degrees(N);}
\DoxyCodeLine{294     cs.indices\_.resize(N + 1);}
\DoxyCodeLine{295     cs.indices\_[0] = 0;}
\DoxyCodeLine{296     std::for\_each(\textcolor{comment}{/* policy, */}  Tmp.begin(), Tmp.end(), [\&](\textcolor{keyword}{auto}\&\& i) \{ ++degrees[i]; \});}
\DoxyCodeLine{297     std::inclusive\_scan(policy, degrees.begin(), degrees.end(), cs.indices\_.begin() + 1);}
\DoxyCodeLine{298   \}}
\DoxyCodeLine{299 }
\DoxyCodeLine{300   cs.to\_be\_indexed\_.resize(Tmp.size());}
\DoxyCodeLine{301 }
\DoxyCodeLine{302   std::copy(policy, std::get<kdx>(el).begin(), std::get<kdx>(el).end(), std::get<0>(cs.to\_be\_indexed\_).begin());}
\DoxyCodeLine{303   std::copy(policy, std::get<idx>(el).begin(), std::get<idx>(el).end(), std::get<0>(cs.to\_be\_indexed\_).begin()+el.size());}
\DoxyCodeLine{304 }
\DoxyCodeLine{305   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::tuple\_size<typename edge\_list\_t::attributes\_t>::value > 0) \{}
\DoxyCodeLine{306     copy\_helper(el, cs, std::make\_integer\_sequence<\textcolor{keywordtype}{size\_t}, std::tuple\_size<typename edge\_list\_t::attributes\_t>::value>(), 0, policy);}
\DoxyCodeLine{307   \}}
\DoxyCodeLine{308   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::tuple\_size<typename edge\_list\_t::attributes\_t>::value > 0) \{}
\DoxyCodeLine{309     copy\_helper(el, cs, std::make\_integer\_sequence<\textcolor{keywordtype}{size\_t}, std::tuple\_size<typename edge\_list\_t::attributes\_t>::value>(), el.size(), policy);}
\DoxyCodeLine{310   \}}
\DoxyCodeLine{311 }
\DoxyCodeLine{312   \textcolor{keyword}{auto} a = make\_zipped(Tmp, cs.to\_be\_indexed\_);}
\DoxyCodeLine{313   std::sort(policy, a.begin(), a.end(), [](\textcolor{keyword}{auto} \&\&a, \textcolor{keyword}{auto}\&\&b) \{ return std::get<0>(a) < std::get<0>(b); \});}
\DoxyCodeLine{314 }
\DoxyCodeLine{315 \textcolor{preprocessor}{\#else  }}
\DoxyCodeLine{316 }
\DoxyCodeLine{317 }
\DoxyCodeLine{318   \textcolor{keyword}{typename} edge\_list\_t::directed\_type Tmp(N);    \textcolor{comment}{// directedness doesn't matter for the Tmp, so just use same type as el}}
\DoxyCodeLine{319                                                  \textcolor{comment}{// EXCEPT -\/-\/ degrees does something different if undirected}}
\DoxyCodeLine{320 }
\DoxyCodeLine{321   Tmp.resize(2 * el.size());}
\DoxyCodeLine{322   }
\DoxyCodeLine{323   std::copy(policy, el.begin(), el.end(), Tmp.begin());}
\DoxyCodeLine{324   }
\DoxyCodeLine{325   std::transform(policy, el.begin(), el.end(), Tmp.begin() + el.size(), [\&](\textcolor{keyword}{auto}\&\& elt) \{}
\DoxyCodeLine{326     auto flt = elt;}
\DoxyCodeLine{327     std::swap(std::get<0>(flt), std::get<1>(flt));}
\DoxyCodeLine{328     return flt;}
\DoxyCodeLine{329   \});}
\DoxyCodeLine{330   }
\DoxyCodeLine{331   sort\_by<idx>(Tmp);    \textcolor{comment}{// stable\_sort may allocate extra memory}}
\DoxyCodeLine{332 }
\DoxyCodeLine{333   \{}
\DoxyCodeLine{334     \textcolor{keyword}{auto} degree = degrees<idx>(Tmp);    \textcolor{comment}{// Can have a fast version if we know it is sorted -\/-\/ using equal\_range}}
\DoxyCodeLine{335     cs.indices\_.resize(N + 1);}
\DoxyCodeLine{336     std::inclusive\_scan(policy, degree.begin(), degree.end(), cs.indices\_.begin() + 1);}
\DoxyCodeLine{337   \}}
\DoxyCodeLine{338 }
\DoxyCodeLine{339   cs.to\_be\_indexed\_.resize(Tmp.size());}
\DoxyCodeLine{340   }
\DoxyCodeLine{341   \textcolor{keyword}{const} \textcolor{keywordtype}{int} kdx = (idx + 1) \% 2;}
\DoxyCodeLine{342   std::copy(policy, std::get<kdx>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(Tmp)).begin(),}
\DoxyCodeLine{343         std::get<kdx>(\textcolor{keyword}{dynamic\_cast<}typename edge\_list\_t::base\&\textcolor{keyword}{>}(Tmp)).end(), std::get<0>(cs.to\_be\_indexed\_).begin());}
\DoxyCodeLine{344   }
\DoxyCodeLine{345   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::tuple\_size<typename edge\_list\_t::attributes\_t>::value > 0) \{}
\DoxyCodeLine{346     fill\_helper\_tmp(el, cs, std::make\_integer\_sequence<\textcolor{keywordtype}{size\_t}, std::tuple\_size<typename edge\_list\_t::attributes\_t>::value>(), Tmp, policy);}
\DoxyCodeLine{347   \}}
\DoxyCodeLine{348 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{349 \}}
\DoxyCodeLine{350 }
\DoxyCodeLine{351 }
\DoxyCodeLine{352 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{353 \textcolor{keyword}{auto} fill(edge\_list\_t\& el, adjacency\_t\& cs, \textcolor{keywordtype}{bool} sort\_adjacency = \textcolor{keyword}{false}, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{354   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (edge\_list\_t::edge\_directedness == nw::graph::directedness::directed) \{}
\DoxyCodeLine{355     fill\_directed<idx>(el, num\_vertices(el), cs, policy);}
\DoxyCodeLine{356   \} \textcolor{keywordflow}{else} \{    \textcolor{comment}{// undirected -\/-\/ this cannot be a bipartite graph}}
\DoxyCodeLine{357     fill\_undirected<idx>(el, num\_vertices(el), cs, policy);}
\DoxyCodeLine{358   \}}
\DoxyCodeLine{359   \textcolor{keywordflow}{if} (sort\_adjacency) \{}
\DoxyCodeLine{360     \textcolor{comment}{//make adjacency sorted}}
\DoxyCodeLine{361     cs.sort\_to\_be\_indexed();}
\DoxyCodeLine{362   \}}
\DoxyCodeLine{363   \textcolor{keywordflow}{return} cs.to\_be\_indexed\_.size();}
\DoxyCodeLine{364 \}}
\DoxyCodeLine{365 }
\DoxyCodeLine{366 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, adjacency\_list\_graph adjacency\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{367 \textcolor{keyword}{auto} fill(edge\_list\_t\& el, adjacency\_t\& cs, directedness dir, \textcolor{keywordtype}{bool} sort\_adjacency = \textcolor{keyword}{false}, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{368   \textcolor{keywordflow}{if} (dir == nw::graph::directedness::directed) \{}
\DoxyCodeLine{369     fill\_directed<idx>(el, num\_vertices(el), cs, policy);}
\DoxyCodeLine{370   \} \textcolor{keywordflow}{else} \{    \textcolor{comment}{// undirected -\/-\/ this cannot be a bipartite graph}}
\DoxyCodeLine{371     fill\_undirected<idx>(el, num\_vertices(el), cs, policy);}
\DoxyCodeLine{372   \}}
\DoxyCodeLine{373   \textcolor{keywordflow}{if} (sort\_adjacency) \{}
\DoxyCodeLine{374     \textcolor{comment}{//make adjacency sorted}}
\DoxyCodeLine{375     cs.sort\_to\_be\_indexed();}
\DoxyCodeLine{376   \}}
\DoxyCodeLine{377   \textcolor{keywordflow}{return} cs.to\_be\_indexed\_.size();}
\DoxyCodeLine{378 \}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph bi\_edge\_list\_t, adjacency\_list\_graph biadjacency\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{381 \textcolor{keyword}{auto} fill\_biadjacency(bi\_edge\_list\_t\& el, biadjacency\_t\& cs, \textcolor{keywordtype}{bool} sort\_adjacency = \textcolor{keyword}{false}, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{382   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (bi\_edge\_list\_t::edge\_directedness == nw::graph::directedness::directed) \{}
\DoxyCodeLine{383     fill\_directed<idx>(el, num\_vertices(el, idx), cs, policy);}
\DoxyCodeLine{384   \} \textcolor{keywordflow}{else} \{    \textcolor{comment}{// undirected -\/-\/ this cannot be a bipartite graph}}
\DoxyCodeLine{385     fill\_undirected<idx>(el, num\_vertices(el, idx), cs, policy);}
\DoxyCodeLine{386   \}}
\DoxyCodeLine{387   \textcolor{keywordflow}{if} (sort\_adjacency) \{}
\DoxyCodeLine{388     \textcolor{comment}{//make adjacency sorted}}
\DoxyCodeLine{389     cs.sort\_to\_be\_indexed();}
\DoxyCodeLine{390   \}}
\DoxyCodeLine{391   \textcolor{keywordflow}{return} cs.to\_be\_indexed\_.size();}
\DoxyCodeLine{392 \}}
\DoxyCodeLine{393 }
\DoxyCodeLine{394 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t>}
\DoxyCodeLine{395 \textcolor{keywordtype}{void} swap\_to\_triangular(edge\_list\_t\& el, succession cessor) \{}
\DoxyCodeLine{396   \textcolor{keywordflow}{if} (cessor == succession::predecessor) \{}
\DoxyCodeLine{397     swap\_to\_triangular<idx, edge\_list\_t, succession::predecessor>(el);}
\DoxyCodeLine{398   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cessor == succession::successor) \{}
\DoxyCodeLine{399     swap\_to\_triangular<idx, edge\_list\_t, succession::successor>(el);}
\DoxyCodeLine{400   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{401     std::cout << \textcolor{stringliteral}{"{}Bad succession: "{}} << std::endl;}
\DoxyCodeLine{402   \}}
\DoxyCodeLine{403 \}}
\DoxyCodeLine{404 }
\DoxyCodeLine{405 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t>}
\DoxyCodeLine{406 \textcolor{keywordtype}{void} swap\_to\_triangular(edge\_list\_t\& el, \textcolor{keyword}{const} std::string\& cessor = \textcolor{stringliteral}{"{}predecessor"{}}) \{}
\DoxyCodeLine{407   \textcolor{keywordflow}{if} (cessor == \textcolor{stringliteral}{"{}predecessor"{}}) \{}
\DoxyCodeLine{408     swap\_to\_triangular<idx, edge\_list\_t, succession::predecessor>(el);}
\DoxyCodeLine{409   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cessor == \textcolor{stringliteral}{"{}successor"{}}) \{}
\DoxyCodeLine{410     swap\_to\_triangular<idx, edge\_list\_t, succession::successor>(el);}
\DoxyCodeLine{411   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{412     std::cout << \textcolor{stringliteral}{"{}Bad succession: "{}} + cessor << std::endl;}
\DoxyCodeLine{413   \}}
\DoxyCodeLine{414 \}}
\DoxyCodeLine{415 }
\DoxyCodeLine{416 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, succession cessor = succession::predecessor, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{417 \textcolor{keywordtype}{void} swap\_to\_triangular(edge\_list\_t\& el, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{418 }
\DoxyCodeLine{419   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} ((idx == 0 \&\& cessor == succession::predecessor) || (idx == 1 \&\& cessor == succession::successor)) \{}
\DoxyCodeLine{420     std::for\_each(policy, el.begin(), el.end(), [](\textcolor{keyword}{auto}\&\& f) \{}
\DoxyCodeLine{421       if (std::get<0>(f) < std::get<1>(f)) \{}
\DoxyCodeLine{422         std::swap(std::get<0>(f), std::get<1>(f));}
\DoxyCodeLine{423       \}}
\DoxyCodeLine{424     \});}
\DoxyCodeLine{425   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} ((idx == 0 \&\& cessor == succession::successor) || (idx == 1 \&\& cessor == succession::predecessor)) \{}
\DoxyCodeLine{426     std::for\_each(policy, el.begin(), el.end(), [](\textcolor{keyword}{auto}\&\& f) \{}
\DoxyCodeLine{427       if (std::get<1>(f) < std::get<0>(f)) \{}
\DoxyCodeLine{428         std::swap(std::get<1>(f), std::get<0>(f));}
\DoxyCodeLine{429       \}}
\DoxyCodeLine{430     \});}
\DoxyCodeLine{431   \}}
\DoxyCodeLine{432 \}}
\DoxyCodeLine{433 }
\DoxyCodeLine{434 \textcolor{comment}{// Make entries unique -\/-\/ in place -\/-\/ remove adjacent redundancies}}
\DoxyCodeLine{435 \textcolor{comment}{// Requires entries to be sorted in both dimensions}}
\DoxyCodeLine{436 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{437 \textcolor{keywordtype}{void} uniq(edge\_list\_t\& el, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{438 }
\DoxyCodeLine{439   \textcolor{keyword}{auto} past\_the\_end = std::unique(policy, el.begin(), el.end(),}
\DoxyCodeLine{440                                   [](\textcolor{keyword}{auto}\&\& x, \textcolor{keyword}{auto}\&\& y) \{ return std::get<0>(x) == std::get<0>(y) \&\& std::get<1>(x) == std::get<1>(y); \});}
\DoxyCodeLine{441 }
\DoxyCodeLine{442   \textcolor{comment}{// el.erase(past\_the\_end, el.end());}}
\DoxyCodeLine{443   el.resize(past\_the\_end -\/ el.begin());}
\DoxyCodeLine{444 \}}
\DoxyCodeLine{445 }
\DoxyCodeLine{446 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t>}
\DoxyCodeLine{447 \textcolor{keywordtype}{void} remove\_self\_loops(edge\_list\_t\& el) \{}
\DoxyCodeLine{448   \textcolor{keyword}{auto} past\_the\_end =}
\DoxyCodeLine{449       std::remove\_if(\textcolor{comment}{/*std::execution::par\_unseq,*/} el.begin(), el.end(), [](\textcolor{keyword}{auto}\&\& x) \{ return std::get<0>(x) == std::get<1>(x); \});}
\DoxyCodeLine{450   \textcolor{comment}{// el.erase(past\_the\_end, el.end());}}
\DoxyCodeLine{451   el.resize(past\_the\_end -\/ el.begin());}
\DoxyCodeLine{452 \}}
\DoxyCodeLine{453 }
\DoxyCodeLine{454 }
\DoxyCodeLine{455 \textcolor{keyword}{template}<degree\_enumerable\_graph Graph, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{456 \textcolor{keyword}{auto} degrees(\textcolor{keyword}{const} Graph\& graph, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{457   std::vector<vertex\_id\_t<Graph>> degree\_v(num\_vertices(graph));}
\DoxyCodeLine{458   }
\DoxyCodeLine{459   tbb::parallel\_for(tbb::blocked\_range(0ul, degree\_v.size()), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{460     for (auto i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{461       degree\_v[i] = degree(graph[i]);}
\DoxyCodeLine{462     \}}
\DoxyCodeLine{463   \});}
\DoxyCodeLine{464   \textcolor{keywordflow}{return} degree\_v;}
\DoxyCodeLine{465 \}}
\DoxyCodeLine{466 }
\DoxyCodeLine{467 }
\DoxyCodeLine{468 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} d\_\textcolor{keywordtype}{id}x = 0, edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{469 \textcolor{keyword}{requires}(is\_unipartite<typename edge\_list\_t::unipartite\_graph\_base>::value)}
\DoxyCodeLine{470 \textcolor{keyword}{auto} degrees(edge\_list\_t\& el, ExecutionPolicy\&\& policy = \{\}) \textcolor{keyword}{requires}(!degree\_enumerable\_graph<edge\_list\_t>) \{}
\DoxyCodeLine{471 }
\DoxyCodeLine{472   \textcolor{keywordtype}{size\_t} d\_size = 0;}
\DoxyCodeLine{473   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (is\_unipartite<typename edge\_list\_t::unipartite\_graph\_base>::value) \{}
\DoxyCodeLine{474     \textcolor{comment}{//for unipartite graph}}
\DoxyCodeLine{475     d\_size = num\_vertices(el);}
\DoxyCodeLine{476   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{477     \textcolor{comment}{//for bipartite graph}}
\DoxyCodeLine{478     d\_size = num\_vertices(el, d\_idx);}
\DoxyCodeLine{479   \}}
\DoxyCodeLine{480   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} edge\_list\_t::vertex\_id\_type;}
\DoxyCodeLine{481   }
\DoxyCodeLine{482   std::vector<vertex\_id\_type> degree(d\_size);}
\DoxyCodeLine{483 }
\DoxyCodeLine{484   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (edge\_list\_t::edge\_directedness == directedness::directed) \{}
\DoxyCodeLine{485     std::vector<std::atomic<vertex\_id\_type>> tmp(degree.size());}
\DoxyCodeLine{486 }
\DoxyCodeLine{487     std::for\_each(policy, el.begin(), el.end(), [\&](\textcolor{keyword}{auto}\&\& x) \{ ++tmp[std::get<d\_idx>(x)]; \});}
\DoxyCodeLine{488 }
\DoxyCodeLine{489     std::copy(policy, tmp.begin(), tmp.end(), degree.begin());}
\DoxyCodeLine{490 }
\DoxyCodeLine{491   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (edge\_list\_t::edge\_directedness == directedness::undirected) \{}
\DoxyCodeLine{492     std::vector<std::atomic<vertex\_id\_type>> tmp(degree.size());}
\DoxyCodeLine{493 }
\DoxyCodeLine{494     std::for\_each(policy, el.begin(), el.end(), [\&](\textcolor{keyword}{auto}\&\& x) \{}
\DoxyCodeLine{495       ++tmp[std::get<0>(x)];}
\DoxyCodeLine{496       ++tmp[std::get<1>(x)];}
\DoxyCodeLine{497     \});}
\DoxyCodeLine{498     std::copy(policy, tmp.begin(), tmp.end(), degree.begin());}
\DoxyCodeLine{499   \}}
\DoxyCodeLine{500   \textcolor{keywordflow}{return} degree;}
\DoxyCodeLine{501 \}}
\DoxyCodeLine{502 }
\DoxyCodeLine{503 \textcolor{comment}{//for bipartite graph}}
\DoxyCodeLine{504 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} d\_\textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{505 \textcolor{keyword}{requires}(\textcolor{keyword}{false} == is\_unipartite<typename edge\_list\_t::bipartite\_graph\_base>::value)}
\DoxyCodeLine{506 \textcolor{keyword}{auto} degrees(edge\_list\_t\& el, ExecutionPolicy\&\& policy = \{\}) \textcolor{keyword}{requires}(!degree\_enumerable\_graph<edge\_list\_t>) \{}
\DoxyCodeLine{507 }
\DoxyCodeLine{508   \textcolor{keywordtype}{size\_t} d\_size = num\_vertices(el, d\_idx);}
\DoxyCodeLine{509   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} edge\_list\_t::vertex\_id\_type;}
\DoxyCodeLine{510   }
\DoxyCodeLine{511   std::vector<vertex\_id\_type> degree(d\_size);}
\DoxyCodeLine{512 }
\DoxyCodeLine{513   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (edge\_list\_t::edge\_directedness == directedness::directed) \{}
\DoxyCodeLine{514     std::vector<std::atomic<vertex\_id\_type>> tmp(degree.size());}
\DoxyCodeLine{515 }
\DoxyCodeLine{516     std::for\_each(policy, el.begin(), el.end(), [\&](\textcolor{keyword}{auto}\&\& x) \{ ++tmp[std::get<d\_idx>(x)]; \});}
\DoxyCodeLine{517 }
\DoxyCodeLine{518     std::copy(policy, tmp.begin(), tmp.end(), degree.begin());}
\DoxyCodeLine{519 }
\DoxyCodeLine{520   \}}
\DoxyCodeLine{521   \textcolor{keywordflow}{return} degree;}
\DoxyCodeLine{522 \}}
\DoxyCodeLine{523 }
\DoxyCodeLine{524 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x = 0, edge\_list\_graph edge\_list\_t>}
\DoxyCodeLine{525 \textcolor{keyword}{auto} perm\_by\_degree(edge\_list\_t\& el, std::string direction = \textcolor{stringliteral}{"{}ascending"{}}) \{}
\DoxyCodeLine{526   \textcolor{keyword}{auto} degree = degrees<idx>(el);}
\DoxyCodeLine{527   \textcolor{keywordflow}{return} perm\_by\_degree<idx>(el, degree, direction);}
\DoxyCodeLine{528 \}}
\DoxyCodeLine{529 }
\DoxyCodeLine{530 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x = 0, edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} Vector, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{531 \textcolor{keyword}{auto} perm\_by\_degree(edge\_list\_t\& el, \textcolor{keyword}{const} Vector\& degree, std::string direction = \textcolor{stringliteral}{"{}ascending"{}}, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{532 }
\DoxyCodeLine{533   std::vector<typename edge\_list\_t::vertex\_id\_type> perm(degree.size());}
\DoxyCodeLine{534 }
\DoxyCodeLine{535   tbb::parallel\_for(tbb::blocked\_range(0ul, perm.size()), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{536     for (auto i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{537       perm[i] = i;}
\DoxyCodeLine{538     \}}
\DoxyCodeLine{539   \});}
\DoxyCodeLine{540 }
\DoxyCodeLine{541   \textcolor{keyword}{auto} d = degree.begin();}
\DoxyCodeLine{542 }
\DoxyCodeLine{543   \textcolor{keywordflow}{if} (direction == \textcolor{stringliteral}{"{}descending"{}}) \{}
\DoxyCodeLine{544     std::sort(policy, perm.begin(), perm.end(), [\&](\textcolor{keyword}{auto} a, \textcolor{keyword}{auto} b) \{ return d[a] > d[b]; \});}
\DoxyCodeLine{545   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (direction == \textcolor{stringliteral}{"{}ascending"{}}) \{}
\DoxyCodeLine{546     std::sort(policy, perm.begin(), perm.end(), [\&](\textcolor{keyword}{auto} a, \textcolor{keyword}{auto} b) \{ return d[a] < d[b]; \});}
\DoxyCodeLine{547   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{548     std::cout << \textcolor{stringliteral}{"{}Unknown direction: "{}} << direction << std::endl;}
\DoxyCodeLine{549   \}}
\DoxyCodeLine{550 }
\DoxyCodeLine{551   \textcolor{keywordflow}{return} perm;}
\DoxyCodeLine{552 \}}
\DoxyCodeLine{553 }
\DoxyCodeLine{565 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} Vector, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{566 \textcolor{keyword}{requires}(\textcolor{keyword}{true} == is\_unipartite<typename edge\_list\_t::unipartite\_graph\_base>::value)}
\DoxyCodeLine{567 \textcolor{keyword}{auto} relabel(edge\_list\_t\& el, \textcolor{keyword}{const} Vector\& perm, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{568   std::vector<typename edge\_list\_t::vertex\_id\_type> iperm(perm.size());}
\DoxyCodeLine{569 }
\DoxyCodeLine{570   tbb::parallel\_for(tbb::blocked\_range(0ul, iperm.size()), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{571     for (auto i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{572       iperm[perm[i]] = i;}
\DoxyCodeLine{573     \}}
\DoxyCodeLine{574   \});}
\DoxyCodeLine{575 }
\DoxyCodeLine{576   std::for\_each(policy, el.begin(), el.end(), [\&](\textcolor{keyword}{auto}\&\& x) \{}
\DoxyCodeLine{577     std::get<0>(x) = iperm[std::get<0>(x)];}
\DoxyCodeLine{578     std::get<1>(x) = iperm[std::get<1>(x)];}
\DoxyCodeLine{579   \});}
\DoxyCodeLine{580   \textcolor{keywordflow}{return} iperm;}
\DoxyCodeLine{581 \}}
\DoxyCodeLine{582 }
\DoxyCodeLine{595 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} Vector, \textcolor{keyword}{class} ExecutionPolicy = default\_execution\_policy>}
\DoxyCodeLine{596 \textcolor{keyword}{requires}(\textcolor{keyword}{false} == is\_unipartite<typename edge\_list\_t::bipartite\_graph\_base>::value)}
\DoxyCodeLine{597 \textcolor{keyword}{auto} relabel(edge\_list\_t\& el, \textcolor{keyword}{const} Vector\& perm, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{598   std::vector<typename edge\_list\_t::vertex\_id\_type> iperm(perm.size());}
\DoxyCodeLine{599 }
\DoxyCodeLine{600   tbb::parallel\_for(tbb::blocked\_range(0ul, iperm.size()), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{601     for (auto i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{602       iperm[perm[i]] = i;}
\DoxyCodeLine{603     \}}
\DoxyCodeLine{604   \});}
\DoxyCodeLine{605 }
\DoxyCodeLine{606   std::for\_each(policy, el.begin(), el.end(), [\&](\textcolor{keyword}{auto}\&\& x) \{}
\DoxyCodeLine{607     std::get<idx>(x) = iperm[std::get<idx>(x)];}
\DoxyCodeLine{608   \});}
\DoxyCodeLine{609   \textcolor{keywordflow}{return} iperm;}
\DoxyCodeLine{610 \}}
\DoxyCodeLine{611 }
\DoxyCodeLine{621 \textcolor{keyword}{template} <edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} Vector = std::vector<\textcolor{keywordtype}{int}>>}
\DoxyCodeLine{622 \textcolor{keyword}{requires}(is\_unipartite<typename edge\_list\_t::unipartite\_graph\_base>::value)}
\DoxyCodeLine{623 \textcolor{keywordtype}{void} relabel\_by\_degree(edge\_list\_t\& el, std::string direction = \textcolor{stringliteral}{"{}ascending"{}}, \textcolor{keyword}{const} Vector\& degree = std::vector<int>(0)) \{}
\DoxyCodeLine{624 }
\DoxyCodeLine{625   std::vector<typename edge\_list\_t::vertex\_id\_type> perm =}
\DoxyCodeLine{626       degree.size() == 0 ? perm\_by\_degree<0>(el, direction) : perm\_by\_degree<0>(el, degree, direction);}
\DoxyCodeLine{627 }
\DoxyCodeLine{628   relabel(el, perm);}
\DoxyCodeLine{629 \}}
\DoxyCodeLine{630 }
\DoxyCodeLine{642 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t, \textcolor{keyword}{class} Vector = std::vector<\textcolor{keywordtype}{int}>>}
\DoxyCodeLine{643 \textcolor{keyword}{requires}(is\_unipartite<typename edge\_list\_t::unipartite\_graph\_base>::value)}
\DoxyCodeLine{644 \textcolor{keyword}{auto} relabel\_by\_degree(edge\_list\_t\& el, std::string direction = \textcolor{stringliteral}{"{}ascending"{}}, \textcolor{keyword}{const} Vector\& degree = std::vector<int>(0)) \{}
\DoxyCodeLine{645 }
\DoxyCodeLine{646   std::vector<typename edge\_list\_t::vertex\_id\_type> perm =}
\DoxyCodeLine{647       degree.size() == 0 ? perm\_by\_degree<idx>(el, direction) : perm\_by\_degree<idx>(el, degree, direction);}
\DoxyCodeLine{648   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (\textcolor{keyword}{true} == is\_unipartite<typename edge\_list\_t::unipartite\_graph\_base>::value) \{  \textcolor{comment}{// Compress idx}}
\DoxyCodeLine{649     \textcolor{comment}{//unipartite graph relabels both endpoints of the edge}}
\DoxyCodeLine{650     \textcolor{keywordflow}{return} relabel(el, perm);}
\DoxyCodeLine{651     \textcolor{comment}{//return perm;}}
\DoxyCodeLine{652   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{653     \textcolor{comment}{//bipartite graph relabels one endponit of the edge}}
\DoxyCodeLine{654     \textcolor{keywordflow}{return} relabel<idx>(el, perm);}
\DoxyCodeLine{655   \}}
\DoxyCodeLine{656 \}}
\DoxyCodeLine{657 }
\DoxyCodeLine{661 \textcolor{keyword}{template} <std::ranges::random\_access\_range R>}
\DoxyCodeLine{662 \textcolor{keyword}{auto} make\_index\_map(\textcolor{keyword}{const} R\& range) \{}
\DoxyCodeLine{663   \textcolor{keyword}{using} value\_type = std::ranges::range\_value\_t<R>;}
\DoxyCodeLine{664 }
\DoxyCodeLine{665   std::map<value\_type, size\_t> the\_map;}
\DoxyCodeLine{666   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size(range); ++i) \{}
\DoxyCodeLine{667     the\_map[range[i]] = i;}
\DoxyCodeLine{668   \}}
\DoxyCodeLine{669   \textcolor{keywordflow}{return} the\_map;}
\DoxyCodeLine{670 \}}
\DoxyCodeLine{671 }
\DoxyCodeLine{675 \textcolor{keyword}{template} <\textcolor{keyword}{class }M, std::ranges::random\_access\_range E, }
\DoxyCodeLine{676 \textcolor{keyword}{class }Edge = \textcolor{keyword}{decltype}(std::tuple\_cat(std::tuple<size\_t, size\_t>())),}
\DoxyCodeLine{677 \textcolor{keyword}{class} EdgeList = std::vector<Edge>>}
\DoxyCodeLine{678 \textcolor{keyword}{auto} make\_plain\_edges(M\& map, \textcolor{keyword}{const} E\& edges) \{}
\DoxyCodeLine{679   EdgeList index\_edges;}
\DoxyCodeLine{680 }
\DoxyCodeLine{681   \textcolor{keywordflow}{for} (Edge\&\& e : edges) \{}
\DoxyCodeLine{682     std::apply([\&](\textcolor{keyword}{auto}\&\& u, \textcolor{keyword}{auto}\&\& v, \textcolor{keyword}{auto}... props\_) \{ index\_edges.push\_back(std::make\_tuple(map[u], map[v])); \}, e);}
\DoxyCodeLine{683   \}}
\DoxyCodeLine{684 }
\DoxyCodeLine{685   \textcolor{keywordflow}{return} index\_edges;}
\DoxyCodeLine{686 \}}
\DoxyCodeLine{687 }
\DoxyCodeLine{691 \textcolor{keyword}{template} <\textcolor{keyword}{class }M, std::ranges::random\_access\_range E,}
\DoxyCodeLine{692           \textcolor{keyword}{class }Edge = \textcolor{keyword}{decltype}(std::tuple\_cat(std::tuple<size\_t, size\_t>(), props(E()[0]))),}
\DoxyCodeLine{693           \textcolor{keyword}{class} EdgeList = std::vector<Edge>>}
\DoxyCodeLine{694 \textcolor{keyword}{auto} make\_property\_edges(M\& map, \textcolor{keyword}{const} E\& edges) \{}
\DoxyCodeLine{695   EdgeList index\_edges;}
\DoxyCodeLine{696 }
\DoxyCodeLine{697   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& e : edges) \{}
\DoxyCodeLine{698     std::apply([\&](\textcolor{keyword}{auto}\&\& u, \textcolor{keyword}{auto}\&\& v, \textcolor{keyword}{auto}... props\_) \{ index\_edges.push\_back(std::make\_tuple(map[u], map[v], props\_...)); \}, e);}
\DoxyCodeLine{699   \}}
\DoxyCodeLine{700 }
\DoxyCodeLine{701   \textcolor{keywordflow}{return} index\_edges;}
\DoxyCodeLine{702 \}}
\DoxyCodeLine{703 }
\DoxyCodeLine{707 \textcolor{keyword}{template} <\textcolor{keyword}{class} I = std::vector<std::tuple<\textcolor{keywordtype}{size\_t}, \textcolor{keywordtype}{size\_t}, \textcolor{keywordtype}{size\_t}>>, \textcolor{keyword}{class} M, std::ranges::random\_access\_range E>}
\DoxyCodeLine{708 \textcolor{keyword}{auto} make\_index\_edges(M\& map, \textcolor{keyword}{const} E\& edges) \{}
\DoxyCodeLine{709 }
\DoxyCodeLine{710   \textcolor{keyword}{auto} index\_edges = I();}
\DoxyCodeLine{711 }
\DoxyCodeLine{712   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size(edges); ++i) \{}
\DoxyCodeLine{713 }
\DoxyCodeLine{714     \textcolor{keyword}{auto} left  = std::get<0>(edges[i]);}
\DoxyCodeLine{715     \textcolor{keyword}{auto} right = std::get<1>(edges[i]);}
\DoxyCodeLine{716 }
\DoxyCodeLine{717     index\_edges.push\_back(std::make\_tuple(map[left], map[right], i));}
\DoxyCodeLine{718   \}}
\DoxyCodeLine{719 }
\DoxyCodeLine{720   \textcolor{keywordflow}{return} index\_edges;}
\DoxyCodeLine{721 \}}
\DoxyCodeLine{722 }
\DoxyCodeLine{726 \textcolor{keyword}{template} <std::ranges::random\_access\_range V, std::ranges::random\_access\_range E, adjacency\_list\_graph Graph = std::vector<std::vector<\textcolor{keywordtype}{size\_t}>>>}
\DoxyCodeLine{727 \textcolor{keyword}{auto} make\_plain\_graph(\textcolor{keyword}{const} V\& vertices, \textcolor{keyword}{const} E\& edges, \textcolor{keywordtype}{bool} directed = \textcolor{keyword}{true}, \textcolor{keywordtype}{size\_t} idx = 0) \{}
\DoxyCodeLine{728   \textcolor{keyword}{auto} vertex\_map  = make\_index\_map(vertices);}
\DoxyCodeLine{729   \textcolor{keyword}{auto} index\_edges = make\_plain\_edges(vertex\_map, edges);}
\DoxyCodeLine{730 }
\DoxyCodeLine{731   Graph G(size(vertices));}
\DoxyCodeLine{732   push\_back\_fill(index\_edges, G, directed, idx);}
\DoxyCodeLine{733 }
\DoxyCodeLine{734   \textcolor{keywordflow}{return} G;}
\DoxyCodeLine{735 \}}
\DoxyCodeLine{736 }
\DoxyCodeLine{740 \textcolor{keyword}{template} <std::ranges::random\_access\_range V, std::ranges::random\_access\_range E,}
\DoxyCodeLine{741           adjacency\_list\_graph Graph = std::vector<std::vector<std::tuple<size\_t, size\_t>>>>}
\DoxyCodeLine{742 \textcolor{keyword}{auto} make\_index\_graph(\textcolor{keyword}{const} V\& vertices, \textcolor{keyword}{const} E\& edges, \textcolor{keywordtype}{bool} directed = \textcolor{keyword}{true}, \textcolor{keywordtype}{size\_t} idx = 0) \{}
\DoxyCodeLine{743 }
\DoxyCodeLine{744   \textcolor{keyword}{auto} vertex\_map  = make\_index\_map(vertices);}
\DoxyCodeLine{745   \textcolor{keyword}{auto} index\_edges = make\_index\_edges(vertex\_map, edges);}
\DoxyCodeLine{746 }
\DoxyCodeLine{747   Graph G(size(vertices));}
\DoxyCodeLine{748 }
\DoxyCodeLine{749   push\_back\_fill(index\_edges, G, directed, idx);}
\DoxyCodeLine{750 }
\DoxyCodeLine{751   \textcolor{keywordflow}{return} G;}
\DoxyCodeLine{752 \}}
\DoxyCodeLine{756 \textcolor{keyword}{template} <std::ranges::random\_access\_range V, std::ranges::forward\_range E,}
\DoxyCodeLine{757           adjacency\_list\_graph Graph = std::vector<std::vector<\textcolor{keyword}{decltype}(std::tuple\_cat(std::make\_tuple(\textcolor{keywordtype}{size\_t}\{\}), props(*(begin(E\{\})))))>>>}
\DoxyCodeLine{758 \textcolor{keyword}{auto} make\_property\_graph(\textcolor{keyword}{const} V\& vertices, \textcolor{keyword}{const} E\& edges, \textcolor{keywordtype}{bool} directed = \textcolor{keyword}{true}, \textcolor{keywordtype}{size\_t} idx = 0) \{}
\DoxyCodeLine{759 }
\DoxyCodeLine{760   \textcolor{keyword}{auto} vertex\_map     = make\_index\_map(vertices);}
\DoxyCodeLine{761   \textcolor{keyword}{auto} property\_edges = make\_property\_edges(vertex\_map, edges);}
\DoxyCodeLine{762 }
\DoxyCodeLine{763   Graph G(size(vertices));}
\DoxyCodeLine{764 }
\DoxyCodeLine{765   push\_back\_fill(property\_edges, G, directed, idx);}
\DoxyCodeLine{766 }
\DoxyCodeLine{767   \textcolor{keywordflow}{return} G;}
\DoxyCodeLine{768 \}}
\DoxyCodeLine{769 }
\DoxyCodeLine{773 \textcolor{keyword}{template} <\textcolor{keyword}{class} I = std::vector<std::tuple<\textcolor{keywordtype}{size\_t}, \textcolor{keywordtype}{size\_t}>>, std::ranges::random\_access\_range V, std::ranges::random\_access\_range E>}
\DoxyCodeLine{774 \textcolor{keyword}{auto} data\_to\_graph\_edge\_list(\textcolor{keyword}{const} V\& left\_vertices, \textcolor{keyword}{const} V\& right\_vertices, \textcolor{keyword}{const} E\& edges) \{}
\DoxyCodeLine{775 }
\DoxyCodeLine{776   \textcolor{keyword}{auto} left\_map  = make\_index\_map(left\_vertices);}
\DoxyCodeLine{777   \textcolor{keyword}{auto} right\_map = make\_index\_map(right\_vertices);}
\DoxyCodeLine{778 }
\DoxyCodeLine{779   std::vector<std::tuple<size\_t, size\_t>> index\_edges;}
\DoxyCodeLine{780 }
\DoxyCodeLine{781   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size(edges); ++i) \{}
\DoxyCodeLine{782 }
\DoxyCodeLine{783     \textcolor{keyword}{auto} left  = std::get<0>(edges[i]);}
\DoxyCodeLine{784     \textcolor{keyword}{auto} right = std::get<1>(edges[i]);}
\DoxyCodeLine{785 }
\DoxyCodeLine{786     index\_edges.push\_back(\{left\_map[left], right\_map[right]\});}
\DoxyCodeLine{787   \}}
\DoxyCodeLine{788 }
\DoxyCodeLine{789   \textcolor{keywordflow}{return} index\_edges;}
\DoxyCodeLine{790 \}}
\DoxyCodeLine{791 }
\DoxyCodeLine{792 \textcolor{keyword}{template} <std::ranges::random\_access\_range V1, std::ranges::random\_access\_range V2, std::ranges::random\_access\_range E,}
\DoxyCodeLine{793           adjacency\_list\_graph Graph = std::vector<std::vector<\textcolor{keyword}{decltype}(std::tuple\_cat(std::make\_tuple(\textcolor{keywordtype}{size\_t}\{\}), props(*(begin(E\{\})))))>>>}
\DoxyCodeLine{794 \textcolor{keyword}{auto} make\_plain\_bipartite\_graph(\textcolor{keyword}{const} V1\& left\_vertices, \textcolor{keyword}{const} V2\& right\_vertices, \textcolor{keyword}{const} E\& edges, \textcolor{keywordtype}{size\_t} idx = 0) \{}
\DoxyCodeLine{795 }
\DoxyCodeLine{796   \textcolor{keyword}{auto} index\_edges = data\_to\_graph\_edge\_list(left\_vertices, right\_vertices, edges);}
\DoxyCodeLine{797   \textcolor{keyword}{auto} graph\_size  = idx == 0 ? size(left\_vertices) : size(right\_vertices);}
\DoxyCodeLine{798 }
\DoxyCodeLine{799   Graph G(size(left\_vertices));}
\DoxyCodeLine{800   push\_back\_fill(index\_edges, G, \textcolor{keyword}{true}, idx);}
\DoxyCodeLine{801 }
\DoxyCodeLine{802   \textcolor{keywordflow}{return} G;}
\DoxyCodeLine{803 \}}
\DoxyCodeLine{804 }
\DoxyCodeLine{805 \textcolor{keyword}{template} <std::ranges::random\_access\_range V1, std::ranges::random\_access\_range V2, std::ranges::random\_access\_range E,}
\DoxyCodeLine{806           \textcolor{keyword}{class }Graph = std::vector<std::vector<size\_t>>>}
\DoxyCodeLine{807 \textcolor{keyword}{auto} make\_plain\_bipartite\_graphs(\textcolor{keyword}{const} V1\& left\_vertices, \textcolor{keyword}{const} V2\& right\_vertices, \textcolor{keyword}{const} E\& edges) \{}
\DoxyCodeLine{808 }
\DoxyCodeLine{809   \textcolor{keyword}{auto} index\_edges = data\_to\_graph\_edge\_list<>(left\_vertices, right\_vertices, edges);}
\DoxyCodeLine{810 }
\DoxyCodeLine{811   Graph G(size(left\_vertices));}
\DoxyCodeLine{812   Graph H(size(right\_vertices));}
\DoxyCodeLine{813 }
\DoxyCodeLine{814   push\_back\_fill(index\_edges, G, \textcolor{keyword}{true}, 0);}
\DoxyCodeLine{815   push\_back\_fill(index\_edges, H, \textcolor{keyword}{true}, 1);}
\DoxyCodeLine{816 }
\DoxyCodeLine{817   \textcolor{keywordflow}{return} make\_tuple(G, H);}
\DoxyCodeLine{818 \}}
\DoxyCodeLine{819 }
\DoxyCodeLine{820 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} \textcolor{keywordtype}{id}x = 0, \textcolor{keyword}{class} Graph = std::vector<std::vector<\textcolor{keywordtype}{size\_t}>>, std::ranges::random\_access\_range V,}
\DoxyCodeLine{821           std::ranges::random\_access\_range E>}
\DoxyCodeLine{822 \textcolor{keyword}{auto} make\_bipartite\_graph(\textcolor{keyword}{const} V\& left\_vertices, \textcolor{keyword}{const} V\& right\_vertices, \textcolor{keyword}{const} E\& edges) \{}
\DoxyCodeLine{823 }
\DoxyCodeLine{824   \textcolor{keyword}{auto} index\_edges = data\_to\_graph\_edge\_list(left\_vertices, right\_vertices, edges);}
\DoxyCodeLine{825   \textcolor{keyword}{auto} graph\_size  = idx == 0 ? size(left\_vertices) : size(right\_vertices);}
\DoxyCodeLine{826 }
\DoxyCodeLine{827   Graph G(size(left\_vertices));}
\DoxyCodeLine{828   push\_back\_fill(index\_edges, G, \textcolor{keyword}{true}, idx);}
\DoxyCodeLine{829 }
\DoxyCodeLine{830   \textcolor{keywordflow}{return} G;}
\DoxyCodeLine{831 \}}
\DoxyCodeLine{832 }
\DoxyCodeLine{833 \textcolor{keyword}{template} <std::ranges::random\_access\_range V, std::ranges::random\_access\_range E,}
\DoxyCodeLine{834           adjacency\_list\_graph Graph = std::vector<std::vector<\textcolor{keyword}{decltype}(std::tuple\_cat(std::make\_tuple(\textcolor{keywordtype}{size\_t}\{\}), props(*(begin(E\{\})))))>>>}
\DoxyCodeLine{835 \textcolor{keyword}{auto} make\_bipartite\_graphs(\textcolor{keyword}{const} V\& left\_vertices, \textcolor{keyword}{const} V\& right\_vertices, \textcolor{keyword}{const} E\& edges) \{}
\DoxyCodeLine{836 }
\DoxyCodeLine{837   \textcolor{keyword}{auto} index\_edges = data\_to\_graph\_edge\_list<>(left\_vertices, right\_vertices, edges);}
\DoxyCodeLine{838 }
\DoxyCodeLine{839   Graph G(size(left\_vertices));}
\DoxyCodeLine{840   Graph H(size(right\_vertices));}
\DoxyCodeLine{841 }
\DoxyCodeLine{842   push\_back\_fill(index\_edges, G, \textcolor{keyword}{true}, 0);}
\DoxyCodeLine{843   push\_back\_fill(index\_edges, H, \textcolor{keyword}{true}, 1);}
\DoxyCodeLine{844 }
\DoxyCodeLine{845   \textcolor{keywordflow}{return} make\_tuple(G, H);}
\DoxyCodeLine{846 \}}
\DoxyCodeLine{847 }
\DoxyCodeLine{848 \textcolor{keyword}{template} <\textcolor{keyword}{class} Graph1, \textcolor{keyword}{class} Graph2, \textcolor{keyword}{class} IndexGraph = std::vector<std::vector<std::tuple<\textcolor{keywordtype}{size\_t}, \textcolor{keywordtype}{size\_t}>>>>}
\DoxyCodeLine{849 \textcolor{keyword}{auto} join(\textcolor{keyword}{const} Graph1\& G, \textcolor{keyword}{const} Graph2\& H) \{}
\DoxyCodeLine{850 }
\DoxyCodeLine{851   std::vector<std::tuple<size\_t, size\_t, size\_t>> s\_overlap;}
\DoxyCodeLine{852 }
\DoxyCodeLine{853   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < H.size(); ++i) \{}
\DoxyCodeLine{854     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& k : H[i]) \{}
\DoxyCodeLine{855       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& j : G[target(H, k)]) \{}
\DoxyCodeLine{856         \textcolor{keywordflow}{if} (target(G, j) != i) \{}
\DoxyCodeLine{857           s\_overlap.push\_back(\{i, target(G, j), target(H, k)\});}
\DoxyCodeLine{858         \}}
\DoxyCodeLine{859       \}}
\DoxyCodeLine{860     \}}
\DoxyCodeLine{861   \}}
\DoxyCodeLine{862 }
\DoxyCodeLine{863   IndexGraph L(size(H));}
\DoxyCodeLine{864   push\_back\_fill(s\_overlap, L, \textcolor{keyword}{true}, 0);}
\DoxyCodeLine{865 }
\DoxyCodeLine{866   \textcolor{keywordflow}{return} L;}
\DoxyCodeLine{867 \}}
\DoxyCodeLine{868 }
\DoxyCodeLine{869 }
\DoxyCodeLine{870 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{871 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{872 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// NW\_GRAPH\_BUILD\_HPP}}

\end{DoxyCode}
