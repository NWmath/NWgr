\hypertarget{experimental_2algorithms_2page__rank_8hpp_source}{}\doxysection{page\+\_\+rank.\+hpp}
\label{experimental_2algorithms_2page__rank_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/experimental/algorithms/page\_rank.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/experimental/algorithms/page\_rank.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_PAGE\_RANK\_EXPERIMENTAL\_HPP}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define NW\_GRAPH\_PAGE\_RANK\_EXPERIMENTAL\_HPP}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <future>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_concepts.hpp"{}}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include "{}nwgraph/algorithms/page\_rank.hpp"{}}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/edge\_range.hpp"{}}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include "{}nwgraph/containers/compressed.hpp"{}}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include "{}nwgraph/edge\_list.hpp"{}}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include "{}nwgraph/util/parallel\_for.hpp"{}}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/vertex\_range.hpp"{}}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{33 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{36 \textcolor{comment}{//****************************************************************************}}
\DoxyCodeLine{37 \textcolor{keyword}{template}<\textcolor{keyword}{typename} GraphT, \textcolor{keyword}{typename} RealT = \textcolor{keywordtype}{double}>}
\DoxyCodeLine{38 \textcolor{keywordtype}{void} page\_rank\_range\_for(GraphT\& graph, std::vector<RealT>\& page\_rank, RealT damping\_factor = 0.85, RealT threshold = 1.e-\/4,}
\DoxyCodeLine{39                          \textcolor{keywordtype}{size\_t} max\_iters = std::numeric\_limits<unsigned int>::max()) \{}
\DoxyCodeLine{41 }
\DoxyCodeLine{42   RealT \textcolor{keyword}{const} scaled\_teleport((1. -\/ damping\_factor) / (RealT)graph.size());}
\DoxyCodeLine{43 }
\DoxyCodeLine{44   \textcolor{comment}{// degree-\/normalize the rows of the graph and scale by damping factor}}
\DoxyCodeLine{45   std::vector<RealT> odegree(out\_degree<GraphT, RealT>(graph));}
\DoxyCodeLine{46 }
\DoxyCodeLine{47   edge\_list<directed, RealT> edges(0);}
\DoxyCodeLine{48   edges.open\_for\_push\_back();}
\DoxyCodeLine{49   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} [i, j, v] : make\_edge\_range<0>(graph)) \{}
\DoxyCodeLine{50     edges.push\_back(i, j, v * (damping\_factor / odegree[i]));}
\DoxyCodeLine{51     \textcolor{comment}{//v *= (damping\_factor/out\_degree[i]);}}
\DoxyCodeLine{52   \}}
\DoxyCodeLine{53   edges.close\_for\_push\_back();}
\DoxyCodeLine{54   adjacency<0, RealT> M(edges);}
\DoxyCodeLine{55 }
\DoxyCodeLine{56   \textcolor{comment}{// initialize page rank to 1/N}}
\DoxyCodeLine{57   std::vector<RealT> old\_rank(graph.size(), 1. / (RealT)graph.size());}
\DoxyCodeLine{58 }
\DoxyCodeLine{59   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter\_num = 0; iter\_num < max\_iters; ++iter\_num) \{}
\DoxyCodeLine{60     std::fill(page\_rank.begin(), page\_rank.end(), 0.0);}
\DoxyCodeLine{61 }
\DoxyCodeLine{62     \textcolor{comment}{// compute new rank (transpose the graph): PR\_i = M' * PR\_i-\/1}}
\DoxyCodeLine{63     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& [i, j, v] : make\_edge\_range<0>(M)) \{}
\DoxyCodeLine{64       page\_rank[i] += v * old\_rank[j];}
\DoxyCodeLine{65     \}}
\DoxyCodeLine{66 }
\DoxyCodeLine{67     \textcolor{comment}{// add scaled teleport term: (1 -\/ damping\_factor)/N}}
\DoxyCodeLine{68     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& rank\_val : page\_rank) \{}
\DoxyCodeLine{69       rank\_val += scaled\_teleport;}
\DoxyCodeLine{70     \}}
\DoxyCodeLine{71 }
\DoxyCodeLine{72     \textcolor{comment}{// Test for convergence, compute squared error}}
\DoxyCodeLine{73     RealT squared\_error(0.);}
\DoxyCodeLine{74     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} idx = 0; idx < page\_rank.size(); ++idx) \{}
\DoxyCodeLine{75       RealT tmp = page\_rank[idx] -\/ old\_rank[idx];}
\DoxyCodeLine{76       squared\_error += tmp * tmp;}
\DoxyCodeLine{77     \}}
\DoxyCodeLine{78 }
\DoxyCodeLine{79     \textcolor{comment}{//std::cout << "{}Iteration "{} << iter\_num << "{}: sq\_err = "{}}}
\DoxyCodeLine{80     \textcolor{comment}{//          << squared\_error/((RealT)graph.size()) << std::endl;}}
\DoxyCodeLine{81 }
\DoxyCodeLine{82     \textcolor{keywordflow}{if} (squared\_error / ((RealT)graph.size()) < threshold) \textcolor{keywordflow}{break};}
\DoxyCodeLine{83 }
\DoxyCodeLine{84     old\_rank.swap(page\_rank);}
\DoxyCodeLine{85   \}}
\DoxyCodeLine{86 \}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real = \textcolor{keywordtype}{double}>}
\DoxyCodeLine{91 \textcolor{keywordtype}{void} page\_rank\_vc(\textcolor{keyword}{const} Graph\& graph, std::vector<Real>\& page\_rank, \textcolor{keyword}{const} Real damping\_factor = 0.85, \textcolor{keyword}{const} Real threshold = 1.e-\/4,}
\DoxyCodeLine{92                   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_iters = std::numeric\_limits<unsigned int>::max()) \{}
\DoxyCodeLine{93   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{94 }
\DoxyCodeLine{95   \textcolor{keyword}{const} Real init\_score = 1.0 / page\_rank.size();}
\DoxyCodeLine{96   \textcolor{keyword}{const} Real base\_score = (1.0 -\/ damping\_factor) / page\_rank.size();}
\DoxyCodeLine{97 }
\DoxyCodeLine{98   std::fill(page\_rank.begin(), page\_rank.end(), init\_score);}
\DoxyCodeLine{99   std::vector<vertex\_id\_type> degrees(page\_rank.size());}
\DoxyCodeLine{100   \textcolor{comment}{//  for (auto\&\& [i, j, v] : make\_edge\_range<0>(graph)) \{}}
\DoxyCodeLine{101   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& [i, j] : edge\_range(graph)) \{}
\DoxyCodeLine{102     ++degrees[j];}
\DoxyCodeLine{103   \}}
\DoxyCodeLine{104 }
\DoxyCodeLine{105   std::vector<Real> outgoing\_contrib(page\_rank.size());}
\DoxyCodeLine{106 }
\DoxyCodeLine{107   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{108     \textcolor{keywordtype}{double} error = 0;}
\DoxyCodeLine{109 }
\DoxyCodeLine{110     std::transform(page\_rank.begin(), page\_rank.end(), degrees.begin(), outgoing\_contrib.begin(), [\&](\textcolor{keyword}{auto}\&\& x, \textcolor{keyword}{auto}\&\& y) \{}
\DoxyCodeLine{111       ;}
\DoxyCodeLine{112       return x / (y + 0);}
\DoxyCodeLine{113     \});}
\DoxyCodeLine{114 }
\DoxyCodeLine{115     \textcolor{keywordtype}{size\_t} len  = graph.indices\_.size() -\/ 1;}
\DoxyCodeLine{116     \textcolor{keyword}{auto}   ptrs = graph.indices\_;}
\DoxyCodeLine{117     \textcolor{keyword}{auto}   idxs = std::get<0>(graph.to\_be\_indexed\_);}
\DoxyCodeLine{118 }
\DoxyCodeLine{119     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < len; ++i) \{}
\DoxyCodeLine{120       Real z = 0;}
\DoxyCodeLine{121       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} j = ptrs[i]; j < ptrs[i + 1]; ++j) \{}
\DoxyCodeLine{122         z += outgoing\_contrib[idxs[j]];}
\DoxyCodeLine{123       \}}
\DoxyCodeLine{124       \textcolor{keyword}{auto} old\_rank = page\_rank[i];}
\DoxyCodeLine{125       page\_rank[i]  = base\_score + damping\_factor * z;}
\DoxyCodeLine{126       error += fabs(page\_rank[i] -\/ old\_rank);}
\DoxyCodeLine{127     \}}
\DoxyCodeLine{128 }
\DoxyCodeLine{129     std::cout << iter << \textcolor{stringliteral}{"{} "{}} << error << std::endl;}
\DoxyCodeLine{130     \textcolor{keywordflow}{if} (error < threshold) \textcolor{keywordflow}{break};}
\DoxyCodeLine{131   \}}
\DoxyCodeLine{132 \}}
\DoxyCodeLine{133 }
\DoxyCodeLine{134 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real = \textcolor{keywordtype}{double}>}
\DoxyCodeLine{135 \textcolor{keywordtype}{void} page\_rank\_v1(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees, std::vector<Real>\& page\_rank,}
\DoxyCodeLine{136                   \textcolor{keyword}{const} Real damping\_factor = 0.85, \textcolor{keyword}{const} Real threshold = 1.e-\/4,}
\DoxyCodeLine{137                   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_iters = std::numeric\_limits<unsigned int>::max()) \{}
\DoxyCodeLine{138   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{139 }
\DoxyCodeLine{140   \textcolor{keyword}{const} Real init\_score = 1.0 / page\_rank.size();}
\DoxyCodeLine{141   \textcolor{keyword}{const} Real base\_score = (1.0 -\/ damping\_factor) / page\_rank.size();}
\DoxyCodeLine{142 }
\DoxyCodeLine{143   std::fill(page\_rank.begin(), page\_rank.end(), init\_score);}
\DoxyCodeLine{144 }
\DoxyCodeLine{145   std::vector<Real> outgoing\_contrib(page\_rank.size());}
\DoxyCodeLine{146 }
\DoxyCodeLine{147   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{148 }
\DoxyCodeLine{149     \textcolor{keywordtype}{double} error = 0;}
\DoxyCodeLine{150 }
\DoxyCodeLine{151     std::transform(page\_rank.begin(), page\_rank.end(), degrees.begin(), outgoing\_contrib.begin(), [\&](\textcolor{keyword}{auto}\&\& x, \textcolor{keyword}{auto}\&\& y) \{}
\DoxyCodeLine{152       ;}
\DoxyCodeLine{153       return x / (y + 0);}
\DoxyCodeLine{154     \});}
\DoxyCodeLine{155 }
\DoxyCodeLine{156 }
\DoxyCodeLine{157     \textcolor{keywordflow}{for} (vertex\_id\_type i = 0; i < page\_rank.size(); ++i) \{}
\DoxyCodeLine{158       Real z = 0;}
\DoxyCodeLine{159       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} j = graph[i].begin(); j != graph[i].end(); ++j) \{}
\DoxyCodeLine{160         z += outgoing\_contrib[std::get<0>(*j)];}
\DoxyCodeLine{161       \}}
\DoxyCodeLine{162       \textcolor{keyword}{auto} old\_rank = page\_rank[i];}
\DoxyCodeLine{163       page\_rank[i]  = base\_score + damping\_factor * z;}
\DoxyCodeLine{164       error += fabs(page\_rank[i] -\/ old\_rank);}
\DoxyCodeLine{165     \}}
\DoxyCodeLine{166 }
\DoxyCodeLine{167     \textcolor{comment}{//std::cout << iter << "{} "{} << error << std::endl;}}
\DoxyCodeLine{168 }
\DoxyCodeLine{169     \textcolor{keywordflow}{if} (error < threshold) \textcolor{keywordflow}{break};}
\DoxyCodeLine{170   \}}
\DoxyCodeLine{171 \}}
\DoxyCodeLine{172 }
\DoxyCodeLine{173 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real = \textcolor{keywordtype}{double}>}
\DoxyCodeLine{174 \textcolor{keywordtype}{void} page\_rank\_v2(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees, std::vector<Real>\& page\_rank,}
\DoxyCodeLine{175                   \textcolor{keyword}{const} Real damping\_factor = 0.85, \textcolor{keyword}{const} Real threshold = 1.e-\/4,}
\DoxyCodeLine{176                   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_iters = std::numeric\_limits<unsigned int>::max()) \{}
\DoxyCodeLine{177   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{178 }
\DoxyCodeLine{179   \textcolor{keyword}{const} Real init\_score = 1.0 / page\_rank.size();}
\DoxyCodeLine{180   \textcolor{keyword}{const} Real base\_score = (1.0 -\/ damping\_factor) / page\_rank.size();}
\DoxyCodeLine{181 }
\DoxyCodeLine{182   std::fill(page\_rank.begin(), page\_rank.end(), init\_score);}
\DoxyCodeLine{183 }
\DoxyCodeLine{184   std::vector<Real> outgoing\_contrib(page\_rank.size());}
\DoxyCodeLine{185 }
\DoxyCodeLine{186   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{187 }
\DoxyCodeLine{188     \textcolor{keywordtype}{double} error = 0;}
\DoxyCodeLine{189 }
\DoxyCodeLine{190 }
\DoxyCodeLine{191     \textcolor{keywordflow}{for} (vertex\_id\_type i = 0; i < page\_rank.size(); ++i) \{}
\DoxyCodeLine{192       Real z = 0;}
\DoxyCodeLine{193       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} j = graph[i].begin(); j != graph[i].end(); ++j) \{}
\DoxyCodeLine{194         z += outgoing\_contrib[std::get<0>(*j)];}
\DoxyCodeLine{195       \}}
\DoxyCodeLine{196       \textcolor{keyword}{auto} old\_rank = page\_rank[i];}
\DoxyCodeLine{197       page\_rank[i]  = base\_score + damping\_factor * z;}
\DoxyCodeLine{198       error += fabs(page\_rank[i] -\/ old\_rank);}
\DoxyCodeLine{199       outgoing\_contrib[i] = page\_rank[i] / (Real)degrees[i];    \textcolor{comment}{// Gauss-\/Seidel}}
\DoxyCodeLine{200     \}}
\DoxyCodeLine{201     std::cout << iter << \textcolor{stringliteral}{"{} "{}} << error << std::endl;}
\DoxyCodeLine{202     \textcolor{keywordflow}{if} (error < threshold) \textcolor{keywordflow}{break};}
\DoxyCodeLine{203   \}}
\DoxyCodeLine{204 \}}
\DoxyCodeLine{205 }
\DoxyCodeLine{206 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real = \textcolor{keywordtype}{double}>}
\DoxyCodeLine{207 \textcolor{keywordtype}{void} page\_rank\_v4(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees, std::vector<Real>\& page\_rank,}
\DoxyCodeLine{208                   \textcolor{keyword}{const} Real damping\_factor = 0.85, \textcolor{keyword}{const} Real threshold = 1.e-\/4,}
\DoxyCodeLine{209                   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_iters = std::numeric\_limits<unsigned int>::max(), \textcolor{keywordtype}{size\_t} num\_threads = 1) \{}
\DoxyCodeLine{210   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{211 }
\DoxyCodeLine{212   \textcolor{keyword}{const} Real init\_score = 1.0 / page\_rank.size();}
\DoxyCodeLine{213   \textcolor{keyword}{const} Real base\_score = (1.0 -\/ damping\_factor) / page\_rank.size();}
\DoxyCodeLine{214 }
\DoxyCodeLine{215   std::fill(std::execution::par\_unseq, page\_rank.begin(), page\_rank.end(), init\_score);}
\DoxyCodeLine{216 }
\DoxyCodeLine{217   std::vector<Real>                outgoing\_contrib(page\_rank.size());}
\DoxyCodeLine{218   std::vector<std::future<double>> futures(num\_threads);}
\DoxyCodeLine{219 }
\DoxyCodeLine{220   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{221 }
\DoxyCodeLine{222     std::transform(std::execution::par\_unseq, page\_rank.begin(), page\_rank.end(), degrees.begin(), outgoing\_contrib.begin(),}
\DoxyCodeLine{223                    [\&](\textcolor{keyword}{auto}\&\& x, \textcolor{keyword}{auto}\&\& y) \{}
\DoxyCodeLine{224                      ;}
\DoxyCodeLine{225                      return x / (y + 0);}
\DoxyCodeLine{226                    \});}
\DoxyCodeLine{227 }
\DoxyCodeLine{228 }
\DoxyCodeLine{229     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} thread = 0; thread < num\_threads; ++thread) \{}
\DoxyCodeLine{230       futures[thread] = std::async(}
\DoxyCodeLine{231           std::launch::async,}
\DoxyCodeLine{232           [\&](\textcolor{keywordtype}{size\_t} thread) \{}
\DoxyCodeLine{233             \textcolor{keywordtype}{double} error = 0;}
\DoxyCodeLine{234 }
\DoxyCodeLine{235             \textcolor{keywordflow}{for} (vertex\_id\_type i = thread; i < page\_rank.size(); i += num\_threads) \{}
\DoxyCodeLine{236               Real z = 0;}
\DoxyCodeLine{237               \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} j = graph[i].begin(); j != graph[i].end(); ++j) \{}
\DoxyCodeLine{238                 z += outgoing\_contrib[std::get<0>(*j)];}
\DoxyCodeLine{239                 \textcolor{comment}{// for (auto\&\& [j] : G[i]) \{}}
\DoxyCodeLine{240                 \textcolor{comment}{// z += outgoing\_contrib[j];}}
\DoxyCodeLine{241               \}}
\DoxyCodeLine{242               \textcolor{keyword}{auto} old\_rank = page\_rank[i];}
\DoxyCodeLine{243               page\_rank[i]  = base\_score + damping\_factor * z;}
\DoxyCodeLine{244               error += fabs(page\_rank[i] -\/ old\_rank);}
\DoxyCodeLine{245             \}}
\DoxyCodeLine{246             \textcolor{keywordflow}{return} error;}
\DoxyCodeLine{247           \},}
\DoxyCodeLine{248           thread);}
\DoxyCodeLine{249     \}}
\DoxyCodeLine{250     \textcolor{keywordtype}{double} error = 0;}
\DoxyCodeLine{251     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < num\_threads; ++i) \{}
\DoxyCodeLine{252       error += futures[i].get();}
\DoxyCodeLine{253     \}}
\DoxyCodeLine{254 }
\DoxyCodeLine{255     std::cout << iter << \textcolor{stringliteral}{"{} "{}} << error << std::endl;}
\DoxyCodeLine{256     \textcolor{keywordflow}{if} (error < threshold) \textcolor{keywordflow}{break};}
\DoxyCodeLine{257   \}}
\DoxyCodeLine{258 \}}
\DoxyCodeLine{259 }
\DoxyCodeLine{260 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real = \textcolor{keywordtype}{double}>}
\DoxyCodeLine{261 [[gnu::noinline]] \textcolor{keywordtype}{void} page\_rank\_v6(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees,}
\DoxyCodeLine{262                                     std::vector<Real>\& page\_rank, \textcolor{keyword}{const} Real damping\_factor = 0.85, \textcolor{keyword}{const} Real threshold = 1.e-\/4,}
\DoxyCodeLine{263                                     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_iters = std::numeric\_limits<unsigned int>::max(), \textcolor{keywordtype}{size\_t} num\_threads = 1) \{}
\DoxyCodeLine{264 }
\DoxyCodeLine{265   \textcolor{keyword}{const} Real init\_score = 1.0 / page\_rank.size();}
\DoxyCodeLine{266   \textcolor{keyword}{const} Real base\_score = (1.0 -\/ damping\_factor) / page\_rank.size();}
\DoxyCodeLine{267 }
\DoxyCodeLine{268   std::fill(std::execution::par\_unseq, page\_rank.begin(), page\_rank.end(), init\_score);}
\DoxyCodeLine{269 }
\DoxyCodeLine{270   \textcolor{keyword}{auto} per = edge\_range(graph);}
\DoxyCodeLine{271 }
\DoxyCodeLine{272   std::vector<Real> outgoing\_contrib(page\_rank.size());}
\DoxyCodeLine{273   std::vector<Real> old\_rank(page\_rank.size());}
\DoxyCodeLine{274   std::vector<Real> z(page\_rank.size());}
\DoxyCodeLine{275 }
\DoxyCodeLine{276   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{277 }
\DoxyCodeLine{278     std::transform(std::execution::par\_unseq, page\_rank.begin(), page\_rank.end(), degrees.begin(), outgoing\_contrib.begin(),}
\DoxyCodeLine{279                    [\&](\textcolor{keyword}{auto}\&\& x, \textcolor{keyword}{auto}\&\& y) \{ return x / (y + 0); \});}
\DoxyCodeLine{280 }
\DoxyCodeLine{281 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{282     \textcolor{keywordtype}{double} error = tbb::parallel\_reduce(per, [\&](\textcolor{keyword}{auto}\&\& r, Real init) \{}
\DoxyCodeLine{283       Real z = std::transform\_reduce(r.begin(), r.end(), Real(0.0), std::plus<Real>(),}
\DoxyCodeLine{284                                      [\&] (\textcolor{keyword}{auto}\&\& j) \{ \}}
\DoxyCodeLine{285                                      \}, std::plus<Real>());}
\DoxyCodeLine{286 }
\DoxyCodeLine{287       counting\_iterator<vertex\_id\_type>(0), counting\_iterator<vertex\_id\_type>(page\_rank.size()), Real(0.0), std::plus<Real>(),}
\DoxyCodeLine{288 }
\DoxyCodeLine{289       [\&](\textcolor{keyword}{auto} i) \{}
\DoxyCodeLine{290         Real z        = std::transform\_reduce(std::execution::seq, G[i].begin(), G[i].end(), Real(0.0), std::plus<Real>(),}
\DoxyCodeLine{291                                               [\&](\textcolor{keyword}{auto}\&\& j) \{ \textcolor{keywordflow}{return} outgoing\_contrib[std::get<0>(j)]; \});}
\DoxyCodeLine{292         \textcolor{keyword}{auto} old\_rank = page\_rank[i];}
\DoxyCodeLine{293         page\_rank[i]  = base\_score + damping\_factor * z;}
\DoxyCodeLine{294         \textcolor{keywordflow}{return} fabs(page\_rank[i] -\/ old\_rank);}
\DoxyCodeLine{295       \});}
\DoxyCodeLine{296 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{297 }
\DoxyCodeLine{298     std::fill(std::execution::par\_unseq, z.begin(), z.end(), Real(0));}
\DoxyCodeLine{299 }
\DoxyCodeLine{300     tbb::parallel\_for(per, [\&](\textcolor{keyword}{auto}\&\& x) \{}
\DoxyCodeLine{301       std::for\_each(x.begin(), x.end(), [\&](\textcolor{keyword}{auto}\&\& elt) \{}
\DoxyCodeLine{302         auto\&\& [i, j] = elt;}
\DoxyCodeLine{303         z[i] += outgoing\_contrib[j];}
\DoxyCodeLine{304       \});}
\DoxyCodeLine{305     \});}
\DoxyCodeLine{306 }
\DoxyCodeLine{307     std::swap(page\_rank, old\_rank);}
\DoxyCodeLine{308 }
\DoxyCodeLine{309     std::transform(std::execution::par\_unseq, z.begin(), z.end(), page\_rank.begin(), [\&](\textcolor{keyword}{auto}\&\& a) \{ return base\_score + damping\_factor * a; \});}
\DoxyCodeLine{310     \textcolor{keywordtype}{double} error = std::transform\_reduce(std::execution::par\_unseq, page\_rank.begin(), page\_rank.end(), old\_rank.begin(), 0.0,}
\DoxyCodeLine{311                                          std::plus<Real>(), [\&](\textcolor{keyword}{auto}\&\& a, \textcolor{keyword}{auto}\&\& b) \{ return fabs(a -\/ b); \});}
\DoxyCodeLine{312 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{313     std::cout << iter << \textcolor{stringliteral}{"{} "{}} << error << std::endl;}
\DoxyCodeLine{314     \textcolor{keywordflow}{if} (error < threshold) \textcolor{keywordflow}{break};}
\DoxyCodeLine{315   \}}
\DoxyCodeLine{316 \}}
\DoxyCodeLine{317 }
\DoxyCodeLine{318 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real = \textcolor{keywordtype}{double}>}
\DoxyCodeLine{319 \textcolor{keywordtype}{void} page\_rank\_v7(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees, std::vector<Real>\& page\_rank,}
\DoxyCodeLine{320                   \textcolor{keyword}{const} Real damping\_factor = 0.85, \textcolor{keyword}{const} Real threshold = 1.e-\/4,}
\DoxyCodeLine{321                   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_iters = std::numeric\_limits<unsigned int>::max(), \textcolor{keywordtype}{size\_t} num\_threads = 1) \{}
\DoxyCodeLine{322   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{323 }
\DoxyCodeLine{324   \textcolor{keyword}{const} Real init\_score = 1.0 / page\_rank.size();}
\DoxyCodeLine{325   \textcolor{keyword}{const} Real base\_score = (1.0 -\/ damping\_factor) / page\_rank.size();}
\DoxyCodeLine{326 }
\DoxyCodeLine{327   \{}
\DoxyCodeLine{328     \mbox{\hyperlink{classnw_1_1util_1_1life__timer}{nw::util::life\_timer}} \_(\textcolor{stringliteral}{"{}fill"{}});}
\DoxyCodeLine{329 }
\DoxyCodeLine{330     std::fill(std::execution::par\_unseq, page\_rank.begin(), page\_rank.end(), init\_score);}
\DoxyCodeLine{331   \}}
\DoxyCodeLine{332   std::vector<Real> outgoing\_contrib(page\_rank.size());}
\DoxyCodeLine{333 }
\DoxyCodeLine{334   \{}
\DoxyCodeLine{335     \mbox{\hyperlink{classnw_1_1util_1_1life__timer}{nw::util::life\_timer}} \_(\textcolor{stringliteral}{"{}iters"{}});}
\DoxyCodeLine{336     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{337 }
\DoxyCodeLine{338       std::transform(std::execution::par, page\_rank.begin(), page\_rank.end(), degrees.begin(), outgoing\_contrib.begin(),}
\DoxyCodeLine{339                      [\&](\textcolor{keyword}{auto}\&\& x, \textcolor{keyword}{auto}\&\& y) \{}
\DoxyCodeLine{340                        ;}
\DoxyCodeLine{341                        return x / (y + 0);}
\DoxyCodeLine{342                      \});}
\DoxyCodeLine{343 }
\DoxyCodeLine{344 }
\DoxyCodeLine{345       \textcolor{keywordtype}{double} error = std::transform\_reduce(std::execution::par\_unseq, counting\_iterator<vertex\_id\_type>(0),}
\DoxyCodeLine{346                                            counting\_iterator<vertex\_id\_type>(page\_rank.size()), Real(0.0), std::plus<Real>(),}
\DoxyCodeLine{347 }
\DoxyCodeLine{348                                            [\&](\textcolor{keyword}{auto} i) \{}
\DoxyCodeLine{349                                              Real z = tbb::parallel\_reduce(}
\DoxyCodeLine{350                                                  graph[i], Real(0.0),}
\DoxyCodeLine{351                                                  [\&](\textcolor{keyword}{auto}\&\& j, \textcolor{keyword}{const} Real\& foo) \{}
\DoxyCodeLine{352                                                    \textcolor{keywordflow}{return} foo + std::transform\_reduce(}
\DoxyCodeLine{353                                                                     std::execution::seq, j.begin(), j.end(), Real(0.0), std::plus<Real>(),}
\DoxyCodeLine{354                                                                     [\&](\textcolor{keyword}{auto}\&\& a) \{ \textcolor{keywordflow}{return} outgoing\_contrib[std::get<0>(a)]; \});}
\DoxyCodeLine{355                                                  \},}
\DoxyCodeLine{356                                                  std::plus<Real>());}
\DoxyCodeLine{357                                              \textcolor{keyword}{auto} old\_rank = page\_rank[i];}
\DoxyCodeLine{358                                              page\_rank[i]  = base\_score + damping\_factor * z;}
\DoxyCodeLine{359                                              \textcolor{keywordflow}{return} fabs(page\_rank[i] -\/ old\_rank);}
\DoxyCodeLine{360                                            \});}
\DoxyCodeLine{361       std::cout << iter << \textcolor{stringliteral}{"{} "{}} << error << std::endl;}
\DoxyCodeLine{362       \textcolor{keywordflow}{if} (error < threshold) \textcolor{keywordflow}{break};}
\DoxyCodeLine{363     \}}
\DoxyCodeLine{364   \}}
\DoxyCodeLine{365 \}}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real = \textcolor{keywordtype}{double}>}
\DoxyCodeLine{368 \textcolor{keywordtype}{void} page\_rank\_v8(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees, std::vector<Real>\& page\_rank,}
\DoxyCodeLine{369                   \textcolor{keyword}{const} Real damping\_factor = 0.85, \textcolor{keyword}{const} Real threshold = 1.e-\/4,}
\DoxyCodeLine{370                   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_iters = std::numeric\_limits<unsigned int>::max(), \textcolor{keywordtype}{size\_t} num\_threads = 1) \{}
\DoxyCodeLine{371   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{372 }
\DoxyCodeLine{373   \textcolor{keyword}{const} Real init\_score = 1.0 / page\_rank.size();}
\DoxyCodeLine{374   \textcolor{keyword}{const} Real base\_score = (1.0 -\/ damping\_factor) / page\_rank.size();}
\DoxyCodeLine{375 }
\DoxyCodeLine{376   std::fill(std::execution::par\_unseq, page\_rank.begin(), page\_rank.end(), init\_score);}
\DoxyCodeLine{377 }
\DoxyCodeLine{378   std::vector<Real> outgoing\_contrib(page\_rank.size());}
\DoxyCodeLine{379 }
\DoxyCodeLine{380   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{381 }
\DoxyCodeLine{382     std::transform(std::execution::par\_unseq, page\_rank.begin(), page\_rank.end(), degrees.begin(), outgoing\_contrib.begin(),}
\DoxyCodeLine{383                    [\&](\textcolor{keyword}{auto}\&\& x, \textcolor{keyword}{auto}\&\& y) \{}
\DoxyCodeLine{384                      ;}
\DoxyCodeLine{385                      return x / (y + 0);}
\DoxyCodeLine{386                    \});}
\DoxyCodeLine{387 }
\DoxyCodeLine{388 }
\DoxyCodeLine{389     \textcolor{keywordtype}{double} error =}
\DoxyCodeLine{390         std::transform\_reduce(std::execution::par\_unseq, counting\_iterator<vertex\_id\_type>(0),}
\DoxyCodeLine{391                               counting\_iterator<vertex\_id\_type>(page\_rank.size()), Real(0.0), std::plus<Real>(),}
\DoxyCodeLine{392 }
\DoxyCodeLine{393                               [\&](\textcolor{keyword}{auto} i) \{}
\DoxyCodeLine{394                                 Real z        = std::transform\_reduce(std::execution::par\_unseq, graph[i].begin(), graph[i].end(), Real(0.0),}
\DoxyCodeLine{395                                                                std::plus<Real>(), [\&](\textcolor{keyword}{auto}\&\& j) \{ \textcolor{keywordflow}{return} outgoing\_contrib[std::get<0>(j)]; \});}
\DoxyCodeLine{396                                 \textcolor{keyword}{auto} old\_rank = page\_rank[i];}
\DoxyCodeLine{397                                 page\_rank[i]  = base\_score + damping\_factor * z;}
\DoxyCodeLine{398                                 \textcolor{keywordflow}{return} fabs(page\_rank[i] -\/ old\_rank);}
\DoxyCodeLine{399                               \});}
\DoxyCodeLine{400     std::cout << iter << \textcolor{stringliteral}{"{} "{}} << error << std::endl;}
\DoxyCodeLine{401     \textcolor{keywordflow}{if} (error < threshold) \textcolor{keywordflow}{break};}
\DoxyCodeLine{402   \}}
\DoxyCodeLine{403 \}}
\DoxyCodeLine{404 }
\DoxyCodeLine{405 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real>}
\DoxyCodeLine{406 [[gnu::noinline]] \textcolor{keywordtype}{void} page\_rank\_v9(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees,}
\DoxyCodeLine{407                                     std::vector<Real>\& page\_rank, Real damping\_factor, Real threshold, \textcolor{keywordtype}{size\_t} max\_iters, \textcolor{keywordtype}{size\_t} num\_threads) \{}
\DoxyCodeLine{408   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{409 }
\DoxyCodeLine{410   std::size\_t N          = page\_rank.size();}
\DoxyCodeLine{411   Real        init\_score = 1.0 / N;}
\DoxyCodeLine{412   Real        base\_score = (1.0 -\/ damping\_factor) / N;}
\DoxyCodeLine{413 }
\DoxyCodeLine{414   std::fill(std::execution::par\_unseq, page\_rank.begin(), page\_rank.end(), init\_score);}
\DoxyCodeLine{415   std::unique\_ptr<Real[]> outgoing\_contrib(\textcolor{keyword}{new} Real[N]);}
\DoxyCodeLine{416 }
\DoxyCodeLine{417   page\_rank::trace(\textcolor{stringliteral}{"{}iter"{}}, \textcolor{stringliteral}{"{}error"{}}, \textcolor{stringliteral}{"{}time"{}}, \textcolor{stringliteral}{"{}outgoing"{}});}
\DoxyCodeLine{418 }
\DoxyCodeLine{419   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{420     \textcolor{keyword}{auto}\&\& [outgoing] = page\_rank::time\_op([\&] \{}
\DoxyCodeLine{421       std::transform(std::execution::par\_unseq, page\_rank.begin(), page\_rank.end(), degrees.begin(), \&outgoing\_contrib[0],}
\DoxyCodeLine{422                      [\&](\textcolor{keyword}{auto}\&\& x, \textcolor{keyword}{auto}\&\& y) \{ return x / y; \});}
\DoxyCodeLine{423     \});}
\DoxyCodeLine{424 }
\DoxyCodeLine{425 }
\DoxyCodeLine{426     \textcolor{keyword}{auto}\&\& [time, error] = page\_rank::time\_op([\&] \{}
\DoxyCodeLine{427       \textcolor{keywordflow}{return} std::transform\_reduce(std::execution::par\_unseq, counting\_iterator<vertex\_id\_type>(0), counting\_iterator<vertex\_id\_type>(N),}
\DoxyCodeLine{428                                    Real(0.0), std::plus\{\}, [\&](\textcolor{keyword}{auto}\&\& i) \{}
\DoxyCodeLine{429                                      Real z = 0.0;}
\DoxyCodeLine{430                                      \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& j : graph[i]) \{}
\DoxyCodeLine{431                                        z += outgoing\_contrib[std::get<0>(j)];}
\DoxyCodeLine{432                                      \}}
\DoxyCodeLine{433                                      \textcolor{keyword}{auto} old\_rank = page\_rank[i];}
\DoxyCodeLine{434                                      page\_rank[i]  = base\_score + damping\_factor * z;}
\DoxyCodeLine{435                                      \textcolor{keywordflow}{return} fabs(page\_rank[i] -\/ old\_rank);}
\DoxyCodeLine{436                                    \});}
\DoxyCodeLine{437     \});}
\DoxyCodeLine{438 }
\DoxyCodeLine{439     page\_rank::trace(iter, error, time, outgoing);}
\DoxyCodeLine{440 }
\DoxyCodeLine{441     \textcolor{keywordflow}{if} (error < threshold) \{}
\DoxyCodeLine{442       \textcolor{keywordflow}{return};}
\DoxyCodeLine{443     \}}
\DoxyCodeLine{444   \}}
\DoxyCodeLine{445 \}}
\DoxyCodeLine{446 }
\DoxyCodeLine{447 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real>}
\DoxyCodeLine{448 [[gnu::noinline]] \textcolor{keywordtype}{void} page\_rank\_v10(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees,}
\DoxyCodeLine{449                                      std::vector<Real>\& page\_rank, Real damping\_factor, Real threshold, \textcolor{keywordtype}{size\_t} max\_iters, \textcolor{keywordtype}{size\_t} num\_threads) \{}
\DoxyCodeLine{450   std::size\_t N          = graph.size();}
\DoxyCodeLine{451   Real        init\_score = 1.0 / N;}
\DoxyCodeLine{452   Real        base\_score = (1.0 -\/ damping\_factor) / N;}
\DoxyCodeLine{453 }
\DoxyCodeLine{454   \{}
\DoxyCodeLine{455     \mbox{\hyperlink{classnw_1_1util_1_1life__timer}{nw::util::life\_timer}} \_(\textcolor{stringliteral}{"{}init page rank"{}});}
\DoxyCodeLine{456 }
\DoxyCodeLine{457     \textcolor{comment}{// Initialize the page rank.}}
\DoxyCodeLine{458     tbb::parallel\_for(tbb::blocked\_range(0ul, N), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{459       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{460         page\_rank[i] = init\_score;}
\DoxyCodeLine{461       \}}
\DoxyCodeLine{462     \});}
\DoxyCodeLine{463   \}}
\DoxyCodeLine{464 }
\DoxyCodeLine{465   std::unique\_ptr<Real[]> outgoing\_contrib(\textcolor{keyword}{new} Real[N]);}
\DoxyCodeLine{466 }
\DoxyCodeLine{467   page\_rank::trace(\textcolor{stringliteral}{"{}iter"{}}, \textcolor{stringliteral}{"{}error"{}}, \textcolor{stringliteral}{"{}time"{}}, \textcolor{stringliteral}{"{}outgoing"{}});}
\DoxyCodeLine{468 }
\DoxyCodeLine{469   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{470     \textcolor{keyword}{auto}\&\& [outgoing] = page\_rank::time\_op([\&] \{}
\DoxyCodeLine{471       tbb::parallel\_for(tbb::blocked\_range(0ul, N), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{472         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{473           outgoing\_contrib[i] = page\_rank[i] / degrees[i];}
\DoxyCodeLine{474         \}}
\DoxyCodeLine{475       \});}
\DoxyCodeLine{476     \});}
\DoxyCodeLine{477 }
\DoxyCodeLine{478     \textcolor{keyword}{auto}\&\& [time, error] = page\_rank::time\_op([\&] \{}
\DoxyCodeLine{479       \textcolor{keywordflow}{return} tbb::parallel\_reduce(}
\DoxyCodeLine{480           tbb::blocked\_range(0ul, N), 0.0,}
\DoxyCodeLine{481           [\&](\textcolor{keyword}{auto}\&\& r, \textcolor{keyword}{auto} partial\_sum) \{}
\DoxyCodeLine{482             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{483               Real z = 0.0;}
\DoxyCodeLine{484               for (auto\&\& j : graph[i]) \{}
\DoxyCodeLine{485                 z += outgoing\_contrib[std::get<0>(j)];}
\DoxyCodeLine{486               \}}
\DoxyCodeLine{487               \textcolor{keyword}{auto} old\_rank = page\_rank[i];}
\DoxyCodeLine{488               page\_rank[i]  = base\_score + damping\_factor * z;}
\DoxyCodeLine{489               partial\_sum += fabs(page\_rank[i] -\/ old\_rank);}
\DoxyCodeLine{490             \}}
\DoxyCodeLine{491             \textcolor{keywordflow}{return} partial\_sum;}
\DoxyCodeLine{492           \},}
\DoxyCodeLine{493           std::plus\{\});}
\DoxyCodeLine{494     \});}
\DoxyCodeLine{495 }
\DoxyCodeLine{496     page\_rank::trace(iter, error, time, outgoing);}
\DoxyCodeLine{497 }
\DoxyCodeLine{498     \textcolor{keywordflow}{if} (error < threshold) \{}
\DoxyCodeLine{499       \textcolor{keywordflow}{return};}
\DoxyCodeLine{500     \}}
\DoxyCodeLine{501   \}}
\DoxyCodeLine{502 \}}
\DoxyCodeLine{503 }
\DoxyCodeLine{504 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real>}
\DoxyCodeLine{505 [[gnu::noinline]] \textcolor{keywordtype}{void} page\_rank\_v12(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees,}
\DoxyCodeLine{506                                      std::vector<Real>\& page\_rank, Real damping\_factor, Real threshold, \textcolor{keywordtype}{size\_t} max\_iters, \textcolor{keywordtype}{size\_t} num\_threads) \{}
\DoxyCodeLine{507   std::size\_t N          = graph.size();}
\DoxyCodeLine{508   Real        init\_score = 1.0 / N;}
\DoxyCodeLine{509   Real        base\_score = (1.0 -\/ damping\_factor) / N;}
\DoxyCodeLine{510 }
\DoxyCodeLine{511   \{}
\DoxyCodeLine{512     \mbox{\hyperlink{classnw_1_1util_1_1life__timer}{nw::util::life\_timer}} \_(\textcolor{stringliteral}{"{}init page rank"{}});}
\DoxyCodeLine{513 }
\DoxyCodeLine{514     \textcolor{comment}{// Initialize the page rank.}}
\DoxyCodeLine{515     tbb::parallel\_for(tbb::blocked\_range(0ul, N), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{516       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{517         page\_rank[i] = init\_score;}
\DoxyCodeLine{518       \}}
\DoxyCodeLine{519     \});}
\DoxyCodeLine{520   \}}
\DoxyCodeLine{521 }
\DoxyCodeLine{522   std::unique\_ptr<Real[]> outgoing\_contrib(\textcolor{keyword}{new} Real[N]);}
\DoxyCodeLine{523 }
\DoxyCodeLine{524   page\_rank::trace(\textcolor{stringliteral}{"{}iter"{}}, \textcolor{stringliteral}{"{}error"{}}, \textcolor{stringliteral}{"{}time"{}}, \textcolor{stringliteral}{"{}outgoing"{}});}
\DoxyCodeLine{525 }
\DoxyCodeLine{526   tbb::parallel\_for(tbb::blocked\_range(0ul, N), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{527     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{528       outgoing\_contrib[i] = page\_rank[i] / degrees[i];}
\DoxyCodeLine{529     \}}
\DoxyCodeLine{530   \});}
\DoxyCodeLine{531 }
\DoxyCodeLine{532   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{533 }
\DoxyCodeLine{534     \textcolor{keyword}{auto}\&\& [time, error] = page\_rank::time\_op([\&] \{}
\DoxyCodeLine{535       \textcolor{keywordflow}{return} tbb::parallel\_reduce(}
\DoxyCodeLine{536           tbb::blocked\_range(0ul, N), 0.0,}
\DoxyCodeLine{537           [\&](\textcolor{keyword}{auto}\&\& r, \textcolor{keyword}{auto} partial\_sum) \{}
\DoxyCodeLine{538             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{539               Real z = 0.0;}
\DoxyCodeLine{540               for (auto\&\& j : graph[i]) \{}
\DoxyCodeLine{541                 if (outgoing\_contrib[std::get<0>(j)] > threshold) \{}
\DoxyCodeLine{542                   z += outgoing\_contrib[std::get<0>(j)];}
\DoxyCodeLine{543                 \}}
\DoxyCodeLine{544               \}}
\DoxyCodeLine{545               \textcolor{keyword}{auto} old\_rank = page\_rank[i];}
\DoxyCodeLine{546               page\_rank[i]  = base\_score + damping\_factor * z;}
\DoxyCodeLine{547               partial\_sum += fabs(page\_rank[i] -\/ old\_rank);}
\DoxyCodeLine{548               outgoing\_contrib[i] = page\_rank[i] / (Real)degrees[i];}
\DoxyCodeLine{549             \}}
\DoxyCodeLine{550             \textcolor{keywordflow}{return} partial\_sum;}
\DoxyCodeLine{551           \},}
\DoxyCodeLine{552           std::plus\{\});}
\DoxyCodeLine{553     \});}
\DoxyCodeLine{554 }
\DoxyCodeLine{555     page\_rank::trace(iter, error, time, 0);}
\DoxyCodeLine{556 }
\DoxyCodeLine{557     \textcolor{keywordflow}{if} (error < threshold) \{}
\DoxyCodeLine{558       \textcolor{keywordflow}{return};}
\DoxyCodeLine{559     \}}
\DoxyCodeLine{560   \}}
\DoxyCodeLine{561 \}}
\DoxyCodeLine{562 }
\DoxyCodeLine{563 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real>}
\DoxyCodeLine{564 [[gnu::noinline]] \textcolor{keywordtype}{void} page\_rank\_v3(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees,}
\DoxyCodeLine{565                                     std::vector<Real>\& page\_rank, Real damping\_factor, Real threshold, \textcolor{keywordtype}{size\_t} max\_iters) \{}
\DoxyCodeLine{566   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{567 }
\DoxyCodeLine{568   std::size\_t N          = graph.size();}
\DoxyCodeLine{569   Real        init\_score = 1.0 / N;}
\DoxyCodeLine{570   Real        base\_score = (1.0 -\/ damping\_factor) / N;}
\DoxyCodeLine{571 }
\DoxyCodeLine{572   std::vector<Real> delta(N);}
\DoxyCodeLine{573   std::vector<Real> residual(N);}
\DoxyCodeLine{574 }
\DoxyCodeLine{575   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < N; ++i) \{}
\DoxyCodeLine{576     page\_rank[i] = 0.0;}
\DoxyCodeLine{577     delta[i]     = 0.0;}
\DoxyCodeLine{578     residual[i]  = 1.0 -\/ damping\_factor;    \textcolor{comment}{// Own contribution in the first iteration}}
\DoxyCodeLine{579   \}}
\DoxyCodeLine{580 }
\DoxyCodeLine{581   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{582 }
\DoxyCodeLine{583     \textcolor{keywordtype}{bool} changed = \textcolor{keyword}{false};}
\DoxyCodeLine{584 }
\DoxyCodeLine{585     Real           max\_residual = 0, max\_value = 0;}
\DoxyCodeLine{586     vertex\_id\_type max\_degree = 0;}
\DoxyCodeLine{587 }
\DoxyCodeLine{588     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} src = 0; src < N; ++src) \{}
\DoxyCodeLine{589       delta[src]   = 0;}
\DoxyCodeLine{590       max\_degree   = std::max(degrees[src], max\_degree);}
\DoxyCodeLine{591       max\_residual = std::max(residual[src], max\_residual);}
\DoxyCodeLine{592       \textcolor{keywordflow}{if} (residual[src] > threshold) \{}
\DoxyCodeLine{593         max\_value        = std::max(max\_value, page\_rank[src]);}
\DoxyCodeLine{594         Real oldResidual = residual[src];}
\DoxyCodeLine{595         residual[src]    = 0.0;}
\DoxyCodeLine{596         page\_rank[src] += oldResidual;}
\DoxyCodeLine{597         \textcolor{keywordflow}{if} (degrees[src] > 0) \{}
\DoxyCodeLine{598           delta[src] = oldResidual * damping\_factor / (Real)degrees[src];}
\DoxyCodeLine{599           changed    = \textcolor{keyword}{true};}
\DoxyCodeLine{600         \}}
\DoxyCodeLine{601       \}}
\DoxyCodeLine{602     \}}
\DoxyCodeLine{603 }
\DoxyCodeLine{604     Real next\_max = 0;}
\DoxyCodeLine{605 }
\DoxyCodeLine{606     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < N; ++i) \{}
\DoxyCodeLine{607       Real sum = 0.0;}
\DoxyCodeLine{608       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& j : graph[i]) \{}
\DoxyCodeLine{609         \textcolor{keywordflow}{if} (delta[std::get<0>(j)] > 0) \{}
\DoxyCodeLine{610           sum += delta[std::get<0>(j)];}
\DoxyCodeLine{611         \}}
\DoxyCodeLine{612       \}}
\DoxyCodeLine{613       next\_max = std::max(next\_max, sum);}
\DoxyCodeLine{614       \textcolor{keywordflow}{if} (sum > 0) \{}
\DoxyCodeLine{615         residual[i] = sum;}
\DoxyCodeLine{616       \}}
\DoxyCodeLine{617     \}}
\DoxyCodeLine{618 }
\DoxyCodeLine{619     std::cout << iter << \textcolor{stringliteral}{"{}: "{}} << max\_residual << \textcolor{stringliteral}{"{}, "{}} << next\_max << \textcolor{stringliteral}{"{}, "{}} << max\_value << \textcolor{stringliteral}{"{}, "{}} << max\_degree << std::endl;}
\DoxyCodeLine{620 }
\DoxyCodeLine{621     \textcolor{keywordflow}{if} (!changed) \{    \textcolor{comment}{// termination condition}}
\DoxyCodeLine{622       \textcolor{keywordflow}{break};}
\DoxyCodeLine{623     \}}
\DoxyCodeLine{624   \}}
\DoxyCodeLine{625 \}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real>}
\DoxyCodeLine{628 [[gnu::noinline]] \textcolor{keywordtype}{void} page\_rank\_v13(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees,}
\DoxyCodeLine{629                                      std::vector<Real>\& page\_rank, Real damping\_factor, Real threshold, \textcolor{keywordtype}{size\_t} max\_iters, \textcolor{keywordtype}{size\_t} num\_threads) \{}
\DoxyCodeLine{630   std::size\_t N          = graph.size();}
\DoxyCodeLine{631   Real        init\_score = 1.0 / N;}
\DoxyCodeLine{632   Real        base\_score = (1.0 -\/ damping\_factor) / N;}
\DoxyCodeLine{633 }
\DoxyCodeLine{634   std::vector<Real> delta(N);}
\DoxyCodeLine{635   std::vector<Real> residual(N);}
\DoxyCodeLine{636 }
\DoxyCodeLine{637   \{}
\DoxyCodeLine{638     \mbox{\hyperlink{classnw_1_1util_1_1life__timer}{nw::util::life\_timer}} \_(\textcolor{stringliteral}{"{}init data structures"{}});}
\DoxyCodeLine{639 }
\DoxyCodeLine{640     \textcolor{comment}{// Initialize the page rank.}}
\DoxyCodeLine{641     tbb::parallel\_for(tbb::blocked\_range(0ul, N), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{642       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{643         page\_rank[i] = 0.0;}
\DoxyCodeLine{644         delta[i]     = 0.0;}
\DoxyCodeLine{645         residual[i]  = 1.0 -\/ damping\_factor;    \textcolor{comment}{// Own contribution in the first iteration}}
\DoxyCodeLine{646       \}}
\DoxyCodeLine{647     \});}
\DoxyCodeLine{648   \}}
\DoxyCodeLine{649 }
\DoxyCodeLine{650 }
\DoxyCodeLine{651   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{652     \textcolor{keywordtype}{bool} changed = \textcolor{keyword}{false};}
\DoxyCodeLine{653 }
\DoxyCodeLine{654     \textcolor{keyword}{auto}\&\& [outgoing] = page\_rank::time\_op([\&] \{}
\DoxyCodeLine{655       tbb::parallel\_for(tbb::blocked\_range(0ul, N), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{656         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} src = r.begin(), e = r.end(); src != e; ++src) \{}
\DoxyCodeLine{657           delta[src] = 0;}
\DoxyCodeLine{658           if (residual[src] > threshold) \{}
\DoxyCodeLine{659             Real oldResidual = residual[src];}
\DoxyCodeLine{660             page\_rank[src] += oldResidual;}
\DoxyCodeLine{661             residual[src] = 0.0;}
\DoxyCodeLine{662             if (degrees[src] > 0) \{}
\DoxyCodeLine{663               delta[src] = oldResidual * damping\_factor / degrees[src];}
\DoxyCodeLine{664               changed    = true;}
\DoxyCodeLine{665             \}}
\DoxyCodeLine{666           \}}
\DoxyCodeLine{667         \}}
\DoxyCodeLine{668       \});}
\DoxyCodeLine{669     \});}
\DoxyCodeLine{670 }
\DoxyCodeLine{671     \textcolor{keyword}{auto}\&\& [time] = page\_rank::time\_op([\&] \{}
\DoxyCodeLine{672       tbb::parallel\_for(tbb::blocked\_range(0ul, N), [\&](\textcolor{keyword}{auto}\&\& r) \{}
\DoxyCodeLine{673         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = r.begin(), e = r.end(); i != e; ++i) \{}
\DoxyCodeLine{674 }
\DoxyCodeLine{675           Real sum = 0.0;}
\DoxyCodeLine{676           for (auto\&\& j : graph[i]) \{}
\DoxyCodeLine{677             if (delta[std::get<0>(j)] > 0) \{}
\DoxyCodeLine{678               sum += delta[std::get<0>(j)];}
\DoxyCodeLine{679             \}}
\DoxyCodeLine{680           \}}
\DoxyCodeLine{681           if (sum > 0) \{}
\DoxyCodeLine{682             residual[i] = sum;}
\DoxyCodeLine{683           \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{684             residual[i] = 0;}
\DoxyCodeLine{685         \}}
\DoxyCodeLine{686       \});}
\DoxyCodeLine{687     \});}
\DoxyCodeLine{688 }
\DoxyCodeLine{689     page\_rank::trace(iter, 0, time, outgoing);}
\DoxyCodeLine{690 }
\DoxyCodeLine{691     \textcolor{keywordflow}{if} (!changed) \{    \textcolor{comment}{// termination condition}}
\DoxyCodeLine{692       \textcolor{keywordflow}{break};}
\DoxyCodeLine{693     \}}
\DoxyCodeLine{694   \}}
\DoxyCodeLine{695 \}}
\DoxyCodeLine{696 }
\DoxyCodeLine{697 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Real>}
\DoxyCodeLine{698 [[gnu::noinline]] std::size\_t page\_rank\_v14(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& degrees,}
\DoxyCodeLine{699                                             std::vector<Real>\& page\_rank, Real damping\_factor, Real threshold, \textcolor{keywordtype}{size\_t} max\_iters) \{}
\DoxyCodeLine{700   std::size\_t N          = graph.size();}
\DoxyCodeLine{701   Real        init\_score = 1.0 / N;}
\DoxyCodeLine{702   Real        base\_score = (1.0 -\/ damping\_factor) / N;}
\DoxyCodeLine{703 }
\DoxyCodeLine{704   std::unique\_ptr<Real[]> outgoing\_contrib(\textcolor{keyword}{new} Real[N]);}
\DoxyCodeLine{705 }
\DoxyCodeLine{706   tbb::parallel\_for(0ul, N, [\&](\textcolor{keyword}{auto}\&\& i) \{}
\DoxyCodeLine{707     page\_rank[i]        = init\_score;}
\DoxyCodeLine{708     outgoing\_contrib[i] = init\_score / degrees[i];}
\DoxyCodeLine{709   \});}
\DoxyCodeLine{710 }
\DoxyCodeLine{711   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} iter = 0; iter < max\_iters; ++iter) \{}
\DoxyCodeLine{712     Real error = nw::graph::parallel\_reduce(}
\DoxyCodeLine{713         tbb::blocked\_range(0ul, N),}
\DoxyCodeLine{714         [\&](\textcolor{keyword}{auto}\&\& u) \{}
\DoxyCodeLine{715           Real z = 0.0;}
\DoxyCodeLine{716           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& elt : graph[u]) \{}
\DoxyCodeLine{717             \textcolor{keyword}{auto} v = target(graph, elt);}
\DoxyCodeLine{718             z += outgoing\_contrib[v];}
\DoxyCodeLine{719           \}}
\DoxyCodeLine{720           Real old\_rank       = page\_rank[u];}
\DoxyCodeLine{721           page\_rank[u]        = base\_score + damping\_factor * z;}
\DoxyCodeLine{722           outgoing\_contrib[u] = page\_rank[u] / degrees[u];}
\DoxyCodeLine{723           \textcolor{keywordflow}{return} fabs(page\_rank[u] -\/ old\_rank);}
\DoxyCodeLine{724         \},}
\DoxyCodeLine{725         std::plus\{\}, 0.0);}
\DoxyCodeLine{726 }
\DoxyCodeLine{727     \textcolor{keywordflow}{if} (error < threshold) \{}
\DoxyCodeLine{728       \textcolor{keywordflow}{return} iter;}
\DoxyCodeLine{729     \}}
\DoxyCodeLine{730   \}}
\DoxyCodeLine{731   \textcolor{keywordflow}{return} max\_iters;}
\DoxyCodeLine{732 \}}
\DoxyCodeLine{733 }
\DoxyCodeLine{734 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{735 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{736 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{//  NW\_GRAPH\_PAGE\_RANK\_EXPERIMENTAL\_HPP}}

\end{DoxyCode}
