\hypertarget{algorithms_2bfs_8hpp_source}{}\doxysection{bfs.\+hpp}
\label{algorithms_2bfs_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/bfs.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/bfs.hpp}}
\mbox{\hyperlink{algorithms_2bfs_8hpp}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese}}
\DoxyCodeLine{11 \textcolor{comment}{//     Xu Tony Liu  }}
\DoxyCodeLine{12 \textcolor{comment}{//}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_BFS\_HPP}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#define NW\_GRAPH\_BFS\_HPP}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}nwgraph/containers/compressed.hpp"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_concepts.hpp"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_traits.hpp"{}}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}nwgraph/util/AtomicBitVector.hpp"{}}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include "{}nwgraph/util/atomic.hpp"{}}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include "{}nwgraph/util/parallel\_for.hpp"{}}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/neighbor\_range.hpp"{}}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/cyclic\_range\_adapter.hpp"{}}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/vertex\_range.hpp"{}}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <queue>}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <tbb/concurrent\_queue.h>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <tbb/concurrent\_vector.h>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <tbb/parallel\_for\_each.h>}}
\DoxyCodeLine{31 }
\DoxyCodeLine{39 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{40 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{41   }
\DoxyCodeLine{42 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, adjacency\_list\_graph GraphT>}
\DoxyCodeLine{43 \textcolor{keywordtype}{bool} BFSVerifier(\textcolor{keyword}{const} Graph\& g, GraphT\& g\_t, vertex\_id\_t<Graph> source, std::vector<vertex\_id\_t<Graph>>\& parent) \{}
\DoxyCodeLine{44   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<Graph>;}
\DoxyCodeLine{45 }
\DoxyCodeLine{46   std::vector<vertex\_id\_type> depth(num\_vertices(g), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{47   depth[source] = 0;}
\DoxyCodeLine{48   std::vector<vertex\_id\_type> to\_visit;}
\DoxyCodeLine{49   to\_visit.reserve(num\_vertices(g));}
\DoxyCodeLine{50   to\_visit.push\_back(source);}
\DoxyCodeLine{51   \textcolor{keyword}{auto} out\_neigh = g.begin();}
\DoxyCodeLine{52   \textcolor{keyword}{auto} in\_neigh  = g\_t.begin();}
\DoxyCodeLine{53   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = to\_visit.begin(); it != to\_visit.end(); it++) \{}
\DoxyCodeLine{54     vertex\_id\_type u = *it;}
\DoxyCodeLine{55     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} edge : out\_neigh[u]) \{}
\DoxyCodeLine{56       vertex\_id\_type v = target(g, edge);}
\DoxyCodeLine{57       \textcolor{comment}{//vertex\_id\_type v = std::get<0>(edge);}}
\DoxyCodeLine{58       \textcolor{keywordflow}{if} (depth[v] == std::numeric\_limits<vertex\_id\_type>::max()) \{}
\DoxyCodeLine{59         depth[v] = depth[u] + 1;}
\DoxyCodeLine{60         to\_visit.push\_back(v);}
\DoxyCodeLine{61       \}}
\DoxyCodeLine{62     \}}
\DoxyCodeLine{63   \}}
\DoxyCodeLine{64   \textcolor{keywordflow}{for} (vertex\_id\_type u = 0; u < num\_vertices(g); ++u) \{}
\DoxyCodeLine{65     \textcolor{keywordflow}{if} ((depth[u] != std::numeric\_limits<vertex\_id\_type>::max()) \&\& (parent[u] != std::numeric\_limits<vertex\_id\_type>::max())) \{}
\DoxyCodeLine{66       \textcolor{keywordflow}{if} (u == source) \{}
\DoxyCodeLine{67         \textcolor{keywordflow}{if} (!((parent[u] == u) \&\& (depth[u] == 0))) \{}
\DoxyCodeLine{68           std::cout << \textcolor{stringliteral}{"{}Source wrong "{}} << u << \textcolor{stringliteral}{"{} "{}} << parent[u] << \textcolor{stringliteral}{"{} "{}} << depth[u] << std::endl;}
\DoxyCodeLine{69           \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{70         \}}
\DoxyCodeLine{71         \textcolor{keywordflow}{continue};}
\DoxyCodeLine{72       \}}
\DoxyCodeLine{73       \textcolor{keywordtype}{bool} parent\_found = \textcolor{keyword}{false};}
\DoxyCodeLine{74       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} edge : in\_neigh[u]) \{}
\DoxyCodeLine{75         vertex\_id\_type v = target(g\_t, edge);}
\DoxyCodeLine{76         \textcolor{keywordflow}{if} (v == parent[u]) \{}
\DoxyCodeLine{77           \textcolor{comment}{//if(it != out\_neigh[v].end()) \{}}
\DoxyCodeLine{78           \textcolor{keywordflow}{if} (depth[v] != depth[u] -\/ 1) \{}
\DoxyCodeLine{79             std::cout << \textcolor{stringliteral}{"{}Wrong depths for "{}} << u << \textcolor{stringliteral}{"{} \& "{}} << v << std::endl;}
\DoxyCodeLine{80             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{81           \}}
\DoxyCodeLine{82           parent\_found = \textcolor{keyword}{true};}
\DoxyCodeLine{83           \textcolor{keywordflow}{break};}
\DoxyCodeLine{84         \}}
\DoxyCodeLine{85       \}}
\DoxyCodeLine{86       \textcolor{keywordflow}{if} (!parent\_found) \{}
\DoxyCodeLine{87         std::cout << \textcolor{stringliteral}{"{}Couldn't find edge from "{}} << parent[u] << \textcolor{stringliteral}{"{} to "{}} << u << std::endl;}
\DoxyCodeLine{88         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{89       \}}
\DoxyCodeLine{90     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (depth[u] != parent[u]) \{}
\DoxyCodeLine{91       std::cout << \textcolor{stringliteral}{"{}Reachability mismatch "{}} << u << \textcolor{stringliteral}{"{} "{}} << depth[u] << \textcolor{stringliteral}{"{} "{}} << parent[u] << std::endl;}
\DoxyCodeLine{92       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{93     \}}
\DoxyCodeLine{94   \}}
\DoxyCodeLine{95   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{96 \}}
\DoxyCodeLine{106 \textcolor{keyword}{template} <adjacency\_list\_graph Graph>}
\DoxyCodeLine{107 \textcolor{keyword}{auto} \mbox{\hyperlink{algorithms_2bfs_8hpp_aa6bf3758d8503e6e98efaa2f9f335223}{bfs\_v0}}(\textcolor{keyword}{const} Graph\& graph, vertex\_id\_t<Graph> root) \{}
\DoxyCodeLine{108   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<Graph>;}
\DoxyCodeLine{109 }
\DoxyCodeLine{110   std::deque<vertex\_id\_type>  q1, q2;}
\DoxyCodeLine{111   std::vector<vertex\_id\_type> level(num\_vertices(graph), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{112   std::vector<vertex\_id\_type> parents(num\_vertices(graph), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{113   \textcolor{keywordtype}{size\_t}                      lvl = 0;}
\DoxyCodeLine{114 }
\DoxyCodeLine{115   q1.push\_back(root);}
\DoxyCodeLine{116   level[root]   = lvl++;}
\DoxyCodeLine{117   parents[root] = root;}
\DoxyCodeLine{118 }
\DoxyCodeLine{119   \textcolor{keywordflow}{while} (!q1.empty()) \{}
\DoxyCodeLine{120 }
\DoxyCodeLine{121     std::for\_each(q1.begin(), q1.end(), [\&](vertex\_id\_type u) \{}
\DoxyCodeLine{122       std::for\_each(graph[u].begin(), graph[u].end(), [\&](auto\&\& x) \{}
\DoxyCodeLine{123         vertex\_id\_type v = target(graph, x);}
\DoxyCodeLine{124         if (level[v] == std::numeric\_limits<vertex\_id\_type>::max()) \{}
\DoxyCodeLine{125           q2.push\_back(v);}
\DoxyCodeLine{126           level[v]   = lvl;}
\DoxyCodeLine{127           parents[v] = u;}
\DoxyCodeLine{128         \}}
\DoxyCodeLine{129       \});}
\DoxyCodeLine{130     \});}
\DoxyCodeLine{131     std::swap(q1, q2);}
\DoxyCodeLine{132     q2.clear();}
\DoxyCodeLine{133     ++lvl;}
\DoxyCodeLine{134   \}}
\DoxyCodeLine{135   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{136 \}}
\DoxyCodeLine{137 }
\DoxyCodeLine{138 }
\DoxyCodeLine{149 \textcolor{keyword}{template} <adjacency\_list\_graph OutGraph, adjacency\_list\_graph InGraph>}
\DoxyCodeLine{150 [[gnu::noinline]] \textcolor{keyword}{auto} \mbox{\hyperlink{algorithms_2bfs_8hpp_a1c7b079bac5bfaf054717bb756b14878}{bfs\_v11}}(\textcolor{keyword}{const} OutGraph\& out\_graph, \textcolor{keyword}{const} InGraph\& in\_graph, vertex\_id\_t<OutGraph> root, \textcolor{keywordtype}{int} num\_bins = 32,}
\DoxyCodeLine{151                                \textcolor{keywordtype}{int} alpha = 15, \textcolor{keywordtype}{int} beta = 18) \{}
\DoxyCodeLine{152 }
\DoxyCodeLine{153   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<OutGraph>;}
\DoxyCodeLine{154 }
\DoxyCodeLine{155   \textcolor{keyword}{const} std::size\_t                                   n = nw::graph::pow2(nw::graph::ceil\_log2(num\_bins));}
\DoxyCodeLine{156   \textcolor{keyword}{const} std::size\_t                                   N = num\_vertices(out\_graph);}
\DoxyCodeLine{157   \textcolor{keyword}{const} std::size\_t                                   M = out\_graph.to\_be\_indexed\_.size();}
\DoxyCodeLine{158   std::vector<tbb::concurrent\_vector<vertex\_id\_type>> q1(n), q2(n);}
\DoxyCodeLine{159 }
\DoxyCodeLine{160   std::vector<vertex\_id\_type> parents(N);}
\DoxyCodeLine{161   \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}} front(N, \textcolor{keyword}{false});}
\DoxyCodeLine{162   \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}} curr(N);}
\DoxyCodeLine{163 }
\DoxyCodeLine{164   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto} null\_vertex = null\_vertex\_v<vertex\_id\_type>();}
\DoxyCodeLine{165   std::fill(std::execution::par\_unseq, parents.begin(), parents.end(), null\_vertex);}
\DoxyCodeLine{166 }
\DoxyCodeLine{167   std::uint64\_t edges\_to\_check = M;}
\DoxyCodeLine{168   std::uint64\_t scout\_count    = out\_graph[root].size();}
\DoxyCodeLine{169 }
\DoxyCodeLine{170   parents[root] = root;}
\DoxyCodeLine{171   q1[root \% n].push\_back(root);}
\DoxyCodeLine{172 }
\DoxyCodeLine{173   \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};}
\DoxyCodeLine{174   \textcolor{keywordflow}{while} (!done) \{}
\DoxyCodeLine{175     \textcolor{keywordflow}{if} (scout\_count > edges\_to\_check / alpha) \{}
\DoxyCodeLine{176       std::size\_t awake\_count = 0;}
\DoxyCodeLine{177       \textcolor{comment}{// Initialize the frontier bitmap from the frontier queues, and count the}}
\DoxyCodeLine{178       \textcolor{comment}{// number of non-\/zeros.}}
\DoxyCodeLine{179       \textcolor{comment}{/*}}
\DoxyCodeLine{180 \textcolor{comment}{      std::size\_t awake\_count = nw::graph::parallel\_for(}}
\DoxyCodeLine{181 \textcolor{comment}{          tbb::blocked\_range(0ul, q1.size()),}}
\DoxyCodeLine{182 \textcolor{comment}{          [\&](auto\&\& i) \{}}
\DoxyCodeLine{183 \textcolor{comment}{            auto\&\& q = q1[i];}}
\DoxyCodeLine{184 \textcolor{comment}{            std::for\_each(q.begin(), q.end(), [\&](auto\&\& u) \{ curr.atomic\_set(u); \});}}
\DoxyCodeLine{185 \textcolor{comment}{            return q.size();}}
\DoxyCodeLine{186 \textcolor{comment}{          \}, std::plus\{\}, 0ul);}}
\DoxyCodeLine{187 \textcolor{comment}{      */}}
\DoxyCodeLine{188       std::for\_each(std::execution::par\_unseq, q1.begin(), q1.end(), [\&](\textcolor{keyword}{auto}\&\& q) \{}
\DoxyCodeLine{189         nw::graph::fetch\_add(awake\_count, q.size());}
\DoxyCodeLine{190         std::for\_each(std::execution::par\_unseq, q.begin(), q.end(), [\&](auto\&\& u) \{ curr.atomic\_set(u); \});}
\DoxyCodeLine{191       \});}
\DoxyCodeLine{192 }
\DoxyCodeLine{193       std::size\_t old\_awake\_count = 0;}
\DoxyCodeLine{194       \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{195         old\_awake\_count = awake\_count;}
\DoxyCodeLine{196         std::swap(front, curr);}
\DoxyCodeLine{197         curr.\mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector_ae6f2f9f688910e6ec842382398b67163}{clear}}();}
\DoxyCodeLine{198 }
\DoxyCodeLine{199         awake\_count = tbb::parallel\_reduce(}
\DoxyCodeLine{200             tbb::blocked\_range(0ul, N), 0ul,}
\DoxyCodeLine{201             [\&](\textcolor{keyword}{auto}\&\& range, \textcolor{keyword}{auto} count) \{}
\DoxyCodeLine{202               \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& u = range.begin(), e = range.end(); u != e; ++u) \{}
\DoxyCodeLine{203                 if (null\_vertex == parents[u]) \{}
\DoxyCodeLine{204                   for (auto\&\& elt : in\_graph[u]) \{}
\DoxyCodeLine{205                     auto v = target(in\_graph, elt);}
\DoxyCodeLine{206                     if (front.get(v)) \{}
\DoxyCodeLine{207                       curr.atomic\_set(u);}
\DoxyCodeLine{208                       parents[u] = v;}
\DoxyCodeLine{209                       ++count;}
\DoxyCodeLine{210                       break;}
\DoxyCodeLine{211                     \}}
\DoxyCodeLine{212                   \}}
\DoxyCodeLine{213                 \}}
\DoxyCodeLine{214               \}}
\DoxyCodeLine{215               \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{216             \},}
\DoxyCodeLine{217             std::plus\{\});}
\DoxyCodeLine{218       \} \textcolor{keywordflow}{while} ((awake\_count >= old\_awake\_count) || (awake\_count > N / beta));}
\DoxyCodeLine{219 }
\DoxyCodeLine{220       \textcolor{keywordflow}{if} (awake\_count == 0) \{}
\DoxyCodeLine{221         \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{222       \}}
\DoxyCodeLine{223 }
\DoxyCodeLine{224       tbb::parallel\_for(curr.non\_zeros(nw::graph::pow2(15)), [\&](\textcolor{keyword}{auto}\&\& range) \{}
\DoxyCodeLine{225         for (auto \&\&i = range.begin(), e = range.end(); i != e; ++i) \{}
\DoxyCodeLine{226           q2[*i \% n].push\_back(*i);}
\DoxyCodeLine{227         \}}
\DoxyCodeLine{228       \});}
\DoxyCodeLine{229 }
\DoxyCodeLine{230       scout\_count = 1;}
\DoxyCodeLine{231     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{232       edges\_to\_check -\/= scout\_count;}
\DoxyCodeLine{233       \textcolor{comment}{/*}}
\DoxyCodeLine{234 \textcolor{comment}{      scout\_count = nw::graph::parallel\_for(}}
\DoxyCodeLine{235 \textcolor{comment}{          tbb::blocked\_range(0ul, q1.size()),}}
\DoxyCodeLine{236 \textcolor{comment}{          [\&](auto\&\& i) \{}}
\DoxyCodeLine{237 \textcolor{comment}{            auto\&\& q = q1[i];}}
\DoxyCodeLine{238 \textcolor{comment}{            return nw::graph::parallel\_for(}}
\DoxyCodeLine{239 \textcolor{comment}{                tbb::blocked\_range(0ul, q.size()),}}
\DoxyCodeLine{240 \textcolor{comment}{                [\&](auto\&\& i) \{}}
\DoxyCodeLine{241 \textcolor{comment}{                  auto\&\& u = q[i];}}
\DoxyCodeLine{242 \textcolor{comment}{                  return nw::graph::parallel\_for(}}
\DoxyCodeLine{243 \textcolor{comment}{                      out\_graph[u],}}
\DoxyCodeLine{244 \textcolor{comment}{                      [\&](auto\&\& v) \{}}
\DoxyCodeLine{245 \textcolor{comment}{                        auto curr\_val = parents[v];}}
\DoxyCodeLine{246 \textcolor{comment}{                        if (null\_vertex == curr\_val) \{}}
\DoxyCodeLine{247 \textcolor{comment}{                          if (nw::graph::cas(parents[v], curr\_val, u)) \{}}
\DoxyCodeLine{248 \textcolor{comment}{                            q2[u \% n].push\_back(v);}}
\DoxyCodeLine{249 \textcolor{comment}{                            return out\_graph[v].size();}}
\DoxyCodeLine{250 \textcolor{comment}{                          \}}}
\DoxyCodeLine{251 \textcolor{comment}{                        \}}}
\DoxyCodeLine{252 \textcolor{comment}{                        return 0ul;}}
\DoxyCodeLine{253 \textcolor{comment}{                      \},}}
\DoxyCodeLine{254 \textcolor{comment}{                      std::plus\{\}, 0ul);}}
\DoxyCodeLine{255 \textcolor{comment}{                \},}}
\DoxyCodeLine{256 \textcolor{comment}{                std::plus\{\}, 0ul);}}
\DoxyCodeLine{257 \textcolor{comment}{          \},}}
\DoxyCodeLine{258 \textcolor{comment}{          std::plus\{\}, 0ul);}}
\DoxyCodeLine{259 \textcolor{comment}{          */}}
\DoxyCodeLine{260         scout\_count = nw::graph::parallel\_reduce(}
\DoxyCodeLine{261           tbb::blocked\_range(0ul, q1.size()),}
\DoxyCodeLine{262           [\&](\textcolor{keyword}{auto}\&\& i) \{}
\DoxyCodeLine{263             auto\&\& q = q1[i];}
\DoxyCodeLine{264             return nw::graph::parallel\_reduce(}
\DoxyCodeLine{265                 tbb::blocked\_range(0ul, q.size()),}
\DoxyCodeLine{266                 [\&](auto\&\& i) \{}
\DoxyCodeLine{267                   size\_t count = 0;}
\DoxyCodeLine{268                   auto\&\& u = q[i];}
\DoxyCodeLine{269                   for (auto\&\& elt : out\_graph[u]) \{}
\DoxyCodeLine{270                     auto v = target(out\_graph, elt);}
\DoxyCodeLine{271                     auto curr\_val = parents[v];}
\DoxyCodeLine{272                     if (null\_vertex == curr\_val) \{}
\DoxyCodeLine{273                       if (nw::graph::cas(parents[v], curr\_val, u)) \{}
\DoxyCodeLine{274                         q2[u \% n].push\_back(v);}
\DoxyCodeLine{275                         count += out\_graph[v].size();}
\DoxyCodeLine{276                       \}}
\DoxyCodeLine{277                     \}}
\DoxyCodeLine{278                   \}}
\DoxyCodeLine{279                   return count;}
\DoxyCodeLine{280                 \}, std::plus\{\}, 0ul);}
\DoxyCodeLine{281         \}, std::plus\{\}, 0ul);}
\DoxyCodeLine{282     \}}
\DoxyCodeLine{283 }
\DoxyCodeLine{284     done = \textcolor{keyword}{true};}
\DoxyCodeLine{285     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& q : q2) \{}
\DoxyCodeLine{286       \textcolor{keywordflow}{if} (q.size() != 0) \{}
\DoxyCodeLine{287         done = \textcolor{keyword}{false};}
\DoxyCodeLine{288         \textcolor{keywordflow}{break};}
\DoxyCodeLine{289       \}}
\DoxyCodeLine{290     \}}
\DoxyCodeLine{291     std::swap(q1, q2);}
\DoxyCodeLine{292     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& q : q2) \{}
\DoxyCodeLine{293       q.clear();}
\DoxyCodeLine{294     \}}
\DoxyCodeLine{295     }
\DoxyCodeLine{296   \}}
\DoxyCodeLine{297 }
\DoxyCodeLine{298   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{299 \}}
\DoxyCodeLine{300 }
\DoxyCodeLine{301 }
\DoxyCodeLine{302 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{303 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{304 }
\DoxyCodeLine{305 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// NW\_GRAPH\_BFS\_HPP}}

\end{DoxyCode}
