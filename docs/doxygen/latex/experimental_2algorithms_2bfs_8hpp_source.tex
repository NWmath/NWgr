\hypertarget{experimental_2algorithms_2bfs_8hpp_source}{}\doxysection{bfs.\+hpp}
\label{experimental_2algorithms_2bfs_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/experimental/algorithms/bfs.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/experimental/algorithms/bfs.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese}}
\DoxyCodeLine{11 \textcolor{comment}{//     Xu Tony Liu  }}
\DoxyCodeLine{12 \textcolor{comment}{//}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_EXPERIMENTAL\_BFS\_HPP}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#define NW\_GRAPH\_EXPERIMENTAL\_BFS\_HPP}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}nwgraph/containers/compressed.hpp"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_traits.hpp"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}nwgraph/util/AtomicBitVector.hpp"{}}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}nwgraph/util/atomic.hpp"{}}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include "{}nwgraph/util/parallel\_for.hpp"{}}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/neighbor\_range.hpp"{}}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/cyclic\_range\_adapter.hpp"{}}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/vertex\_range.hpp"{}}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <queue>}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <tbb/concurrent\_queue.h>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <tbb/concurrent\_vector.h>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <tbb/parallel\_for\_each.h>}}
\DoxyCodeLine{30 }
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{33 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{keyword}{template} <adjacency\_list\_graph Graph>}
\DoxyCodeLine{36 \textcolor{keyword}{auto} bfs\_v4(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type root) \{}
\DoxyCodeLine{37   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type;}
\DoxyCodeLine{38 }
\DoxyCodeLine{39   tbb::concurrent\_queue<vertex\_id\_type> q1, q2;}
\DoxyCodeLine{40   std::vector                       level(graph.max() + 1, std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{41   std::vector                       parents(graph.max() + 1, std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{42   \textcolor{keywordtype}{size\_t}                            lvl = 0;}
\DoxyCodeLine{43 }
\DoxyCodeLine{44   q1.push(root);}
\DoxyCodeLine{45   level[root] = lvl++;}
\DoxyCodeLine{46 }
\DoxyCodeLine{47   \textcolor{keywordflow}{while} (!q1.empty()) \{}
\DoxyCodeLine{48 }
\DoxyCodeLine{49     std::for\_each(std::execution::par\_unseq, q1.unsafe\_begin(), q1.unsafe\_end(), [\&](vertex\_id\_type u) \{}
\DoxyCodeLine{50       std::for\_each(graph[u].begin(), graph[u].end(), [\&](auto\&\& x) \{}
\DoxyCodeLine{51         vertex\_id\_type v = target(graph, x);}
\DoxyCodeLine{52         if (level[v] == std::numeric\_limits<vertex\_id\_type>::max()) \{}
\DoxyCodeLine{53           q2.push(v);}
\DoxyCodeLine{54           level[v]   = lvl;}
\DoxyCodeLine{55           parents[v] = u;}
\DoxyCodeLine{56         \}}
\DoxyCodeLine{57       \});}
\DoxyCodeLine{58     \});}
\DoxyCodeLine{59     q1(q2);}
\DoxyCodeLine{60     \textcolor{comment}{//q1.internal\_swap(q2);}}
\DoxyCodeLine{61     q2.clear();}
\DoxyCodeLine{62 }
\DoxyCodeLine{63     ++lvl;}
\DoxyCodeLine{64   \}}
\DoxyCodeLine{65   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{66 \}}
\DoxyCodeLine{67 }
\DoxyCodeLine{68 \textcolor{keyword}{template} <adjacency\_list\_graph Graph>}
\DoxyCodeLine{69 \textcolor{keyword}{auto} bfs\_v6(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type root) \{}
\DoxyCodeLine{70   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type;}
\DoxyCodeLine{71 }
\DoxyCodeLine{72   tbb::concurrent\_vector<vertex\_id\_type> q1, q2;}
\DoxyCodeLine{73   std::vector<vertex\_id\_type>            level(num\_vertices(graph), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{74   std::vector<vertex\_id\_type>            parents(num\_vertices(graph), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{75   \textcolor{keywordtype}{size\_t}                                 lvl = 0;}
\DoxyCodeLine{76 }
\DoxyCodeLine{77   q1.push\_back(root);}
\DoxyCodeLine{78   level[root]   = lvl++;}
\DoxyCodeLine{79   parents[root] = root;}
\DoxyCodeLine{80 }
\DoxyCodeLine{81   \textcolor{keywordflow}{while} (!q1.empty()) \{}
\DoxyCodeLine{82     std::for\_each(q1.begin(), q1.end(), [\&](vertex\_id\_type u) \{}
\DoxyCodeLine{83       std::for\_each(graph[u].begin(), graph[u].end(), [\&](auto\&\& x) \{}
\DoxyCodeLine{84         vertex\_id\_type v = target(graph, x);}
\DoxyCodeLine{85         if (level[v] == std::numeric\_limits<vertex\_id\_type>::max()) \{}
\DoxyCodeLine{86           q2.push\_back(v);}
\DoxyCodeLine{87           level[v]   = lvl;}
\DoxyCodeLine{88           parents[v] = u;}
\DoxyCodeLine{89         \}}
\DoxyCodeLine{90       \});}
\DoxyCodeLine{91     \});}
\DoxyCodeLine{92     std::swap(q1, q2);}
\DoxyCodeLine{93     q2.clear();}
\DoxyCodeLine{94     ++lvl;}
\DoxyCodeLine{95   \}}
\DoxyCodeLine{96   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{97 \}}
\DoxyCodeLine{98 }
\DoxyCodeLine{99 \textcolor{keyword}{template} <adjacency\_list\_graph Graph>}
\DoxyCodeLine{100 \textcolor{keyword}{auto} bfs\_v7(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type root) \{}
\DoxyCodeLine{101   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type;}
\DoxyCodeLine{102 }
\DoxyCodeLine{103   tbb::concurrent\_vector<vertex\_id\_type>   q1, q2;}
\DoxyCodeLine{104   std::vector<std::atomic<vertex\_id\_type>> level(num\_vertices(graph));}
\DoxyCodeLine{105   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < graph.size(); ++i) \{}
\DoxyCodeLine{106     level[i] = std::numeric\_limits<vertex\_id\_type>::max();}
\DoxyCodeLine{107   \}}
\DoxyCodeLine{108   std::vector parents(num\_vertices(graph), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{109   \textcolor{keywordtype}{size\_t}      lvl = 0;}
\DoxyCodeLine{110 }
\DoxyCodeLine{111   q1.push\_back(root);}
\DoxyCodeLine{112   level[root]   = lvl++;}
\DoxyCodeLine{113   parents[root] = root;}
\DoxyCodeLine{114 }
\DoxyCodeLine{115   \textcolor{keywordflow}{while} (!q1.empty()) \{}
\DoxyCodeLine{116     std::for\_each(std::execution::par\_unseq, q1.begin(), q1.end(), [\&](vertex\_id\_type u) \{}
\DoxyCodeLine{117       std::for\_each(graph[u].begin(), graph[u].end(), [\&](auto\&\& x) \{}
\DoxyCodeLine{118         vertex\_id\_type v = target(graph, x);}
\DoxyCodeLine{119         vertex\_id\_type old\_lvl = level[v];}
\DoxyCodeLine{120         vertex\_id\_type new\_lvl = lvl;}
\DoxyCodeLine{121         if (new\_lvl < old\_lvl) \{}
\DoxyCodeLine{122           bool changed = true;}
\DoxyCodeLine{123           while (!level[v].compare\_exchange\_strong(old\_lvl, new\_lvl)) \{}
\DoxyCodeLine{124             if (old\_lvl <= new\_lvl) \{}
\DoxyCodeLine{125               changed = false;}
\DoxyCodeLine{126               break;}
\DoxyCodeLine{127             \}}
\DoxyCodeLine{128           \}}
\DoxyCodeLine{129           if (changed) \{}
\DoxyCodeLine{130             q2.push\_back(v);}
\DoxyCodeLine{131             parents[v] = u;}
\DoxyCodeLine{132           \}}
\DoxyCodeLine{133         \}}
\DoxyCodeLine{134       \});}
\DoxyCodeLine{135     \});}
\DoxyCodeLine{136     std::swap(q1, q2);}
\DoxyCodeLine{137     q2.clear();}
\DoxyCodeLine{138 }
\DoxyCodeLine{139     ++lvl;}
\DoxyCodeLine{140   \}}
\DoxyCodeLine{141   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{142 \}}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 \textcolor{keyword}{template} <adjacency\_list\_graph Graph>}
\DoxyCodeLine{145 \textcolor{keyword}{auto} bfs\_v8(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type root) \{}
\DoxyCodeLine{146 }
\DoxyCodeLine{147   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type;}
\DoxyCodeLine{148 }
\DoxyCodeLine{149   tbb::concurrent\_queue<vertex\_id\_type> q[2];\textcolor{comment}{// q1, q2;}}
\DoxyCodeLine{150   std::vector                       level(num\_vertices(graph), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{151   std::vector                       parents(num\_vertices(graph), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{152   \textcolor{keywordtype}{size\_t}                            lvl = 0;}
\DoxyCodeLine{153 }
\DoxyCodeLine{154   \textcolor{keywordtype}{bool} cur = \textcolor{keyword}{false};}
\DoxyCodeLine{155   q[cur].push(root);}
\DoxyCodeLine{156   \textcolor{comment}{//q1.push(root);}}
\DoxyCodeLine{157   level[root]   = lvl++;}
\DoxyCodeLine{158   parents[root] = root;}
\DoxyCodeLine{159 }
\DoxyCodeLine{160   \textcolor{keywordflow}{while} (!q[cur].empty()) \{}
\DoxyCodeLine{161 }
\DoxyCodeLine{162     std::for\_each(std::execution::par\_unseq, q[cur].unsafe\_begin(), q[cur].unsafe\_end(), [\&](vertex\_id\_type u) \{}
\DoxyCodeLine{163       std::for\_each(std::execution::par\_unseq, graph[u].begin(), graph[u].end(), [\&](\textcolor{keyword}{auto}\&\& x) \{}
\DoxyCodeLine{164         vertex\_id\_type v = target(graph, x);}
\DoxyCodeLine{165         \textcolor{keywordflow}{if} (level[v] == std::numeric\_limits<vertex\_id\_type>::max()) \{}
\DoxyCodeLine{166           q[!cur].push(v);}
\DoxyCodeLine{167           level[v]   = lvl;}
\DoxyCodeLine{168           parents[v] = u;}
\DoxyCodeLine{169         \}}
\DoxyCodeLine{170       \});}
\DoxyCodeLine{171     \});}
\DoxyCodeLine{172     cur = !cur;}
\DoxyCodeLine{173     \textcolor{comment}{//q1.internal\_swap(q2);}}
\DoxyCodeLine{174     q[!cur].clear();}
\DoxyCodeLine{175 }
\DoxyCodeLine{176     ++lvl;}
\DoxyCodeLine{177   \}}
\DoxyCodeLine{178   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{179 \}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{keyword}{template} <adjacency\_list\_graph Graph>}
\DoxyCodeLine{182 \textcolor{keyword}{auto} bfs\_v9(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type root) \{}
\DoxyCodeLine{183   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type;}
\DoxyCodeLine{184 }
\DoxyCodeLine{185   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t}                                        num\_bins = 32;}
\DoxyCodeLine{186   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t}                                        bin\_mask = 0x1F;}
\DoxyCodeLine{187   std::vector<tbb::concurrent\_vector<vertex\_id\_type>> q1(num\_bins), q2(num\_bins);}
\DoxyCodeLine{188   std::vector                                         level(num\_vertices(graph), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{189   std::vector                                         parents(num\_vertices(graph), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{190   \textcolor{keywordtype}{size\_t}                                              lvl = 0;}
\DoxyCodeLine{191   parents[root]                                           = root;}
\DoxyCodeLine{192 }
\DoxyCodeLine{193   q1[0].push\_back(root);}
\DoxyCodeLine{194   level[root]   = lvl++;}
\DoxyCodeLine{195   parents[root] = root;}
\DoxyCodeLine{196 }
\DoxyCodeLine{197   \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};}
\DoxyCodeLine{198   \textcolor{keywordflow}{while} (!done) \{}
\DoxyCodeLine{199     std::for\_each(std::execution::par\_unseq, q1.begin(), q1.end(), [\&](\textcolor{keyword}{auto}\& q) \{}
\DoxyCodeLine{200       std::for\_each(std::execution::par\_unseq, q.begin(), q.end(), [\&](vertex\_id\_type u) \{}
\DoxyCodeLine{201         tbb::parallel\_for(graph[u], [\&](auto\&\& gu) \{}
\DoxyCodeLine{202           std::for\_each(gu.begin(), gu.end(), [\&](auto\&\& x) \{}
\DoxyCodeLine{203             vertex\_id\_type v = target(graph, x);}
\DoxyCodeLine{204             if (level[v] == std::numeric\_limits<vertex\_id\_type>::max()) \{}
\DoxyCodeLine{205               q2[u \& bin\_mask].push\_back(v);}
\DoxyCodeLine{206               level[v]   = lvl;}
\DoxyCodeLine{207               parents[v] = u;}
\DoxyCodeLine{208             \}}
\DoxyCodeLine{209           \});}
\DoxyCodeLine{210         \});}
\DoxyCodeLine{211       \});}
\DoxyCodeLine{212     \});}
\DoxyCodeLine{213 }
\DoxyCodeLine{214     done = \textcolor{keyword}{true};}
\DoxyCodeLine{215     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < num\_bins; ++i) \{}
\DoxyCodeLine{216       \textcolor{keywordflow}{if} (q2[i].size() != 0) \{}
\DoxyCodeLine{217         done = \textcolor{keyword}{false};}
\DoxyCodeLine{218         \textcolor{keywordflow}{break};}
\DoxyCodeLine{219       \}}
\DoxyCodeLine{220     \}}
\DoxyCodeLine{221 }
\DoxyCodeLine{222     std::swap(q1, q2);}
\DoxyCodeLine{223 }
\DoxyCodeLine{224     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < num\_bins; ++i) \{}
\DoxyCodeLine{225       q2[i].clear();}
\DoxyCodeLine{226     \}}
\DoxyCodeLine{227 }
\DoxyCodeLine{228     ++lvl;}
\DoxyCodeLine{229   \}}
\DoxyCodeLine{230   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{231 \}}
\DoxyCodeLine{232 }
\DoxyCodeLine{233 \textcolor{keyword}{template} <adjacency\_list\_graph Graph>}
\DoxyCodeLine{234 [[gnu::noinline]] \textcolor{keyword}{auto} bfs\_top\_down(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type root) \{}
\DoxyCodeLine{235   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{236 }
\DoxyCodeLine{237   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} std::size\_t                         num\_bins = 32;}
\DoxyCodeLine{238   \textcolor{keyword}{const} std::size\_t                                   N        = num\_vertices(graph);}
\DoxyCodeLine{239   std::vector<tbb::concurrent\_vector<vertex\_id\_type>> q1(num\_bins);}
\DoxyCodeLine{240   std::vector<tbb::concurrent\_vector<vertex\_id\_type>> q2(num\_bins);}
\DoxyCodeLine{241   std::vector<vertex\_id\_type>                         parents(N);}
\DoxyCodeLine{242 }
\DoxyCodeLine{243   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto} null\_vertex = null\_vertex\_v<vertex\_id\_type>();}
\DoxyCodeLine{244 }
\DoxyCodeLine{245   std::fill(std::execution::par\_unseq, parents.begin(), parents.end(), null\_vertex);}
\DoxyCodeLine{246 }
\DoxyCodeLine{247   q1[0].push\_back(root);}
\DoxyCodeLine{248   parents[root] = root;}
\DoxyCodeLine{249 }
\DoxyCodeLine{250   \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};}
\DoxyCodeLine{251   \textcolor{keywordflow}{while} (!done) \{}
\DoxyCodeLine{252     std::for\_each(std::execution::par\_unseq, q1.begin(), q1.end(), [\&](\textcolor{keyword}{auto}\&\& q) \{}
\DoxyCodeLine{253       std::for\_each(std::execution::par\_unseq, q.begin(), q.end(), [\&](auto\&\& u) \{}
\DoxyCodeLine{254         nw::graph::parallel\_for(graph[u], [\&](auto\&\& v) \{}
\DoxyCodeLine{255           if (nw::graph::relaxed(parents[v]) == null\_vertex) \{}
\DoxyCodeLine{256             nw::graph::relaxed(parents[v], u);}
\DoxyCodeLine{257             q2[u \% num\_bins].push\_back(v);}
\DoxyCodeLine{258           \}}
\DoxyCodeLine{259         \});}
\DoxyCodeLine{260       \});}
\DoxyCodeLine{261     \});}
\DoxyCodeLine{262 }
\DoxyCodeLine{263     done = \textcolor{keyword}{true};}
\DoxyCodeLine{264     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& q : q2) \{}
\DoxyCodeLine{265       \textcolor{keywordflow}{if} (q.size() != 0) \{}
\DoxyCodeLine{266         done = \textcolor{keyword}{false};}
\DoxyCodeLine{267         \textcolor{keywordflow}{break};}
\DoxyCodeLine{268       \}}
\DoxyCodeLine{269     \}}
\DoxyCodeLine{270 }
\DoxyCodeLine{271     std::swap(q1, q2);}
\DoxyCodeLine{272 }
\DoxyCodeLine{273     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& q : q2) \{}
\DoxyCodeLine{274       q.clear();}
\DoxyCodeLine{275     \}}
\DoxyCodeLine{276   \}}
\DoxyCodeLine{277   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{278 \}}
\DoxyCodeLine{279 }
\DoxyCodeLine{280 \textcolor{keyword}{template} <adjacency\_list\_graph Graph>}
\DoxyCodeLine{281 [[gnu::noinline]] \textcolor{keyword}{auto} bfs\_top\_down\_bitmap(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{typename} graph\_traits<Graph>::vertex\_id\_type root) \{}
\DoxyCodeLine{282   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<Graph>;}
\DoxyCodeLine{283 }
\DoxyCodeLine{284   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} std::size\_t                         num\_bins = 32;}
\DoxyCodeLine{285   \textcolor{keyword}{const} std::size\_t                                   N        = num\_vertices(graph);}
\DoxyCodeLine{286   std::vector<tbb::concurrent\_vector<vertex\_id\_type>> q1(num\_bins);}
\DoxyCodeLine{287   std::vector<tbb::concurrent\_vector<vertex\_id\_type>> q2(num\_bins);}
\DoxyCodeLine{288   std::vector<vertex\_id\_type>                         parents(N);}
\DoxyCodeLine{289   \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}}                          visited(N);}
\DoxyCodeLine{290 }
\DoxyCodeLine{291   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto} null\_vertex = null\_vertex\_v<vertex\_id\_type>();}
\DoxyCodeLine{292 }
\DoxyCodeLine{293   std::fill(std::execution::par\_unseq, parents.begin(), parents.end(), null\_vertex);}
\DoxyCodeLine{294 }
\DoxyCodeLine{295   q1[0].push\_back(root);}
\DoxyCodeLine{296   parents[root] = root;}
\DoxyCodeLine{297   visited.set(root);}
\DoxyCodeLine{298 }
\DoxyCodeLine{299   \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};}
\DoxyCodeLine{300   \textcolor{keywordflow}{while} (!done) \{}
\DoxyCodeLine{301     std::for\_each(std::execution::par\_unseq, q1.begin(), q1.end(), [\&](\textcolor{keyword}{auto}\&\& q) \{}
\DoxyCodeLine{302       std::for\_each(std::execution::par\_unseq, q.begin(), q.end(), [\&](auto\&\& u) \{}
\DoxyCodeLine{303         nw::graph::parallel\_for(graph[u], [\&](auto\&\& v) \{}
\DoxyCodeLine{304           if (visited.atomic\_get(v) == 0 \&\& visited.atomic\_set(v) == 0) \{}
\DoxyCodeLine{305             parents[v] = u;}
\DoxyCodeLine{306             q2[u \% num\_bins].push\_back(v);}
\DoxyCodeLine{307           \}}
\DoxyCodeLine{308         \});}
\DoxyCodeLine{309       \});}
\DoxyCodeLine{310     \});}
\DoxyCodeLine{311 }
\DoxyCodeLine{312     done = \textcolor{keyword}{true};}
\DoxyCodeLine{313     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& q : q2) \{}
\DoxyCodeLine{314       \textcolor{keywordflow}{if} (q.size() != 0) \{}
\DoxyCodeLine{315         done = \textcolor{keyword}{false};}
\DoxyCodeLine{316         \textcolor{keywordflow}{break};}
\DoxyCodeLine{317       \}}
\DoxyCodeLine{318     \}}
\DoxyCodeLine{319 }
\DoxyCodeLine{320     std::swap(q1, q2);}
\DoxyCodeLine{321 }
\DoxyCodeLine{322     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& q : q2) \{}
\DoxyCodeLine{323       q.clear();}
\DoxyCodeLine{324     \}}
\DoxyCodeLine{325   \}}
\DoxyCodeLine{326   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{327 \}}
\DoxyCodeLine{328 }
\DoxyCodeLine{329 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, adjacency\_list\_graph Transpose>}
\DoxyCodeLine{330 [[gnu::noinline]] \textcolor{keyword}{auto} bfs\_bottom\_up(\textcolor{keyword}{const} Graph\& g, \textcolor{keyword}{const} Transpose\& gx, vertex\_id\_t<Graph> root) \{}
\DoxyCodeLine{331   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<Graph>;}
\DoxyCodeLine{332 }
\DoxyCodeLine{333   \textcolor{keyword}{const} std::size\_t          N = num\_vertices(gx);}
\DoxyCodeLine{334   \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}} frontier(N);}
\DoxyCodeLine{335   \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}} next(N);}
\DoxyCodeLine{336 }
\DoxyCodeLine{337   std::vector<vertex\_id\_type> parents(N);}
\DoxyCodeLine{338 }
\DoxyCodeLine{339   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto} null\_vertex = null\_vertex\_v<vertex\_id\_type>();}
\DoxyCodeLine{340   std::fill(std::execution::par\_unseq, parents.begin(), parents.end(), null\_vertex);}
\DoxyCodeLine{341 }
\DoxyCodeLine{342   parents[root] = root;}
\DoxyCodeLine{343   next.set(root);}
\DoxyCodeLine{344   \textcolor{keywordflow}{for} (vertex\_id\_type n = 1; n != 0; n = tbb::parallel\_reduce(}
\DoxyCodeLine{345                                          tbb::blocked\_range(0ul, N), 0,}
\DoxyCodeLine{346                                          [\&](\textcolor{keyword}{auto}\&\&range, \textcolor{keyword}{auto} n) \{}
\DoxyCodeLine{347                                            \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \&\&v = range.begin(), e = range.end(); v != e; ++v) \{}
\DoxyCodeLine{348                                              if (parents[v] == null\_vertex) \{}
\DoxyCodeLine{349                                                for (auto\&\& elt : gx[v]) \{}
\DoxyCodeLine{350                                                  vertex\_id\_type u = target(g, elt);}
\DoxyCodeLine{351                                                  if (frontier.get(u)) \{}
\DoxyCodeLine{352                                                    next.atomic\_set(v);}
\DoxyCodeLine{353                                                    parents[v] = u;}
\DoxyCodeLine{354                                                    ++n;}
\DoxyCodeLine{355                                                    break;}
\DoxyCodeLine{356                                                  \}}
\DoxyCodeLine{357                                                \}}
\DoxyCodeLine{358                                              \}}
\DoxyCodeLine{359                                            \}}
\DoxyCodeLine{360                                            \textcolor{keywordflow}{return} n;}
\DoxyCodeLine{361                                          \},}
\DoxyCodeLine{362                                          std::plus\{\})) \{}
\DoxyCodeLine{363     std::swap(frontier, next);}
\DoxyCodeLine{364     next.clear();}
\DoxyCodeLine{365   \}}
\DoxyCodeLine{366   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{367 \}}
\DoxyCodeLine{368 }
\DoxyCodeLine{369 }
\DoxyCodeLine{370 \textcolor{keyword}{template}<adjacency\_list\_graph Graph>}
\DoxyCodeLine{371 \textcolor{keywordtype}{size\_t} BU\_step(\textcolor{keyword}{const} Graph\& g, std::vector<vertex\_id\_t<Graph>>\& parents,}
\DoxyCodeLine{372 \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector<>}}\& front, \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector<>}}\& next) \{}
\DoxyCodeLine{373   \textcolor{keywordtype}{size\_t} N = num\_vertices(g);    \textcolor{comment}{// number of nodes}}
\DoxyCodeLine{374   next.\mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector_ae6f2f9f688910e6ec842382398b67163}{clear}}();}
\DoxyCodeLine{375   \textcolor{keywordflow}{return} tbb::parallel\_reduce(}
\DoxyCodeLine{376       \mbox{\hyperlink{classnw_1_1graph_1_1neighbor__range}{nw::graph::neighbor\_range}}(g), 0ul,}
\DoxyCodeLine{377       [\&](\textcolor{keyword}{auto} \&\&range, \textcolor{keyword}{auto} n) \{}
\DoxyCodeLine{378         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& [u, neighbors] : range) \{}
\DoxyCodeLine{379           \textcolor{keywordflow}{if} (null\_vertex\_v<vertex\_id\_t<Graph>>() == parents[u]) \{}
\DoxyCodeLine{380             \textcolor{comment}{//if u has not found a parent (not visited)}}
\DoxyCodeLine{381             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& elt : neighbors) \{}
\DoxyCodeLine{382               \textcolor{keyword}{auto} v = target(g, elt);}
\DoxyCodeLine{383               \textcolor{keywordflow}{if} (front.\mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector_a23bc0b796e66d42abbab4aa60dad5a2d}{get}}(v)) \{}
\DoxyCodeLine{384                 \textcolor{comment}{//if v is not visited}}
\DoxyCodeLine{385                 next.\mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector_acfc0f928fbf09c9a33ec3bf472e19e72}{atomic\_set}}(u);}
\DoxyCodeLine{386                 parents[u] = v;}
\DoxyCodeLine{387                 ++n;}
\DoxyCodeLine{388                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{389               \}}
\DoxyCodeLine{390             \}}
\DoxyCodeLine{391           \}}
\DoxyCodeLine{392         \}}
\DoxyCodeLine{393         \textcolor{keywordflow}{return} n;}
\DoxyCodeLine{394       \}, std::plus\{\});}
\DoxyCodeLine{395 \}}
\DoxyCodeLine{396 }
\DoxyCodeLine{397 \textcolor{keyword}{template}<adjacency\_list\_graph Graph, \textcolor{keyword}{typename} Vector>}
\DoxyCodeLine{398 \textcolor{keywordtype}{size\_t} TD\_step(\textcolor{keyword}{const} Graph\& g, std::vector<vertex\_id\_t<Graph>>\& parents,}
\DoxyCodeLine{399 Vector\& cur, std::vector<Vector>\& next) \{}
\DoxyCodeLine{400   \textcolor{keywordtype}{size\_t} scout\_count = 0;}
\DoxyCodeLine{401   \textcolor{keywordtype}{size\_t} N = cur.size();}
\DoxyCodeLine{402   scout\_count = tbb::parallel\_reduce(}
\DoxyCodeLine{403     tbb::blocked\_range(0ul, N), 0ul,}
\DoxyCodeLine{404     [\&](\textcolor{keyword}{auto}\&\& range, \textcolor{keyword}{auto} n) \{}
\DoxyCodeLine{405       \textcolor{keywordtype}{int} worker\_index = tbb::this\_task\_arena::current\_thread\_index();}
\DoxyCodeLine{406       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& i = range.begin(), e = range.end(); i != e; ++i) \{}
\DoxyCodeLine{407         \textcolor{keyword}{auto} u = cur[i];}
\DoxyCodeLine{408         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& elt : g[u]) \{}
\DoxyCodeLine{409           \textcolor{keyword}{auto} v = target(g, elt);}
\DoxyCodeLine{410           \textcolor{keyword}{auto} curr\_val = parents[v];}
\DoxyCodeLine{411           \textcolor{keywordflow}{if} (null\_vertex\_v<vertex\_id\_t<Graph>>() == curr\_val) \{}
\DoxyCodeLine{412             \textcolor{comment}{//if u has not found a parent (not visited)}}
\DoxyCodeLine{413             \textcolor{keywordflow}{if} (nw::graph::cas(parents[v], curr\_val, u)) \{}
\DoxyCodeLine{414               next[worker\_index].push\_back(v);}
\DoxyCodeLine{415               n += g[v].size();}
\DoxyCodeLine{416             \}}
\DoxyCodeLine{417           \}}
\DoxyCodeLine{418         \}}
\DoxyCodeLine{419       \}}
\DoxyCodeLine{420       \textcolor{keywordflow}{return} n;}
\DoxyCodeLine{421   \}, std::plus\{\});}
\DoxyCodeLine{422   \textcolor{keywordflow}{return} scout\_count;}
\DoxyCodeLine{423 \}}
\DoxyCodeLine{424 \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{425 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} queue\_to\_bitmap(std::vector<T>\& queue, \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector<>}}\& bitmap) \{}
\DoxyCodeLine{426   std::for\_each(std::execution::par\_unseq, queue.begin(), queue.end(), [\&](\textcolor{keyword}{auto}\&\& u) \{ }
\DoxyCodeLine{427     bitmap.atomic\_set(u); }
\DoxyCodeLine{428   \});}
\DoxyCodeLine{429 \}}
\DoxyCodeLine{430 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Vector>}
\DoxyCodeLine{431 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} bitmap\_to\_queue(\mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector<>}}\& bitmap, std::vector<Vector>\& lqueue) \{}
\DoxyCodeLine{432   tbb::parallel\_for(bitmap.non\_zeros(nw::graph::pow2(15)), [\&](\textcolor{keyword}{auto}\&\& range) \{}
\DoxyCodeLine{433     int worker\_index = tbb::this\_task\_arena::current\_thread\_index();}
\DoxyCodeLine{434     for (auto\&\& i = range.begin(), e = range.end(); i != e; ++i) \{}
\DoxyCodeLine{435       lqueue[worker\_index].push\_back(*i);}
\DoxyCodeLine{436     \}}
\DoxyCodeLine{437   \});}
\DoxyCodeLine{438 \}}
\DoxyCodeLine{439 }
\DoxyCodeLine{440 \textcolor{comment}{/*}}
\DoxyCodeLine{441 \textcolor{comment}{* Flush thread-\/local queue to global queue}}
\DoxyCodeLine{442 \textcolor{comment}{*/}}
\DoxyCodeLine{443 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Vector>}
\DoxyCodeLine{444 \textcolor{keywordtype}{void} flush(std::vector<Vector>\& lqueue, Vector\& queue) \{}
\DoxyCodeLine{445   \textcolor{keywordtype}{size\_t} size = 0;}
\DoxyCodeLine{446   \textcolor{keywordtype}{size\_t} n = lqueue.size();}
\DoxyCodeLine{447   std::vector<size\_t> size\_array(n, 0);}
\DoxyCodeLine{448   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n; ++i) \{}
\DoxyCodeLine{449     \textcolor{comment}{//calculate the size of each thread-\/local frontier}}
\DoxyCodeLine{450     size\_array[i] = size;}
\DoxyCodeLine{451     \textcolor{comment}{//accumulate the total size of all thread-\/local frontiers}}
\DoxyCodeLine{452     size += lqueue[i].size();}
\DoxyCodeLine{453   \}}
\DoxyCodeLine{454   \textcolor{comment}{//resize 'queue'}}
\DoxyCodeLine{455   queue.resize(size); }
\DoxyCodeLine{456   std::for\_each(std::execution::par\_unseq, counting\_iterator(0ul), counting\_iterator(n), [\&](\textcolor{keyword}{auto} i) \{}
\DoxyCodeLine{457     \textcolor{comment}{//copy each thread-\/local queue to global queue based on their size offset}}
\DoxyCodeLine{458     \textcolor{keyword}{auto} begin = std::next(queue.begin(), size\_array[i]);}
\DoxyCodeLine{459     std::copy(std::execution::par\_unseq, lqueue[i].begin(), lqueue[i].end(), begin);}
\DoxyCodeLine{460     lqueue[i].clear();}
\DoxyCodeLine{461   \});}
\DoxyCodeLine{462 \}}
\DoxyCodeLine{463 }
\DoxyCodeLine{464 \textcolor{keyword}{template} <adjacency\_list\_graph OutGraph, adjacency\_list\_graph InGraph>}
\DoxyCodeLine{465 [[gnu::noinline]] \textcolor{keyword}{auto} bfs\_v1(\textcolor{keyword}{const} OutGraph\& out\_graph, \textcolor{keyword}{const} InGraph\& in\_graph, vertex\_id\_t<OutGraph> root, \textcolor{keywordtype}{int} num\_bins = 32,}
\DoxyCodeLine{466                                \textcolor{keywordtype}{int} alpha = 15, \textcolor{keywordtype}{int} beta = 18) \{}
\DoxyCodeLine{467 }
\DoxyCodeLine{468   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<OutGraph>;}
\DoxyCodeLine{469   \textcolor{keyword}{using} Vector = std::vector<vertex\_id\_type>;}
\DoxyCodeLine{470   \textcolor{keyword}{const} std::size\_t                                   n = nw::graph::pow2(nw::graph::ceil\_log2(num\_bins));}
\DoxyCodeLine{471   \textcolor{keyword}{const} std::size\_t                                   N = num\_vertices(out\_graph);}
\DoxyCodeLine{472   \textcolor{keyword}{const} std::size\_t                                   M = out\_graph.to\_be\_indexed\_.size();}
\DoxyCodeLine{473   Vector queue;}
\DoxyCodeLine{474   std::vector<Vector> lqueue(n);}
\DoxyCodeLine{475 }
\DoxyCodeLine{476   std::vector<vertex\_id\_type> parents(N);}
\DoxyCodeLine{477 }
\DoxyCodeLine{478   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto} null\_vertex = null\_vertex\_v<vertex\_id\_type>();}
\DoxyCodeLine{479   std::fill(std::execution::par\_unseq, parents.begin(), parents.end(), null\_vertex);}
\DoxyCodeLine{480 }
\DoxyCodeLine{481   std::uint64\_t edges\_to\_check = M;}
\DoxyCodeLine{482   std::uint64\_t scout\_count    = out\_graph[root].size();}
\DoxyCodeLine{483 }
\DoxyCodeLine{484   parents[root] = root;}
\DoxyCodeLine{485   queue.reserve(N);}
\DoxyCodeLine{486   queue.push\_back(root);}
\DoxyCodeLine{487 }
\DoxyCodeLine{488   \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}} front(N, \textcolor{keyword}{false});}
\DoxyCodeLine{489   \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}} curr(N);}
\DoxyCodeLine{490 }
\DoxyCodeLine{491   \textcolor{keywordflow}{while} (!queue.empty()) \{}
\DoxyCodeLine{492     \textcolor{keywordflow}{if} (scout\_count > edges\_to\_check / alpha) \{}
\DoxyCodeLine{493       std::size\_t                awake\_count = queue.size();}
\DoxyCodeLine{494       \textcolor{comment}{// Initialize the frontier bitmap from the frontier queues, and count the}}
\DoxyCodeLine{495       \textcolor{comment}{// number of non-\/zeros.}}
\DoxyCodeLine{496       queue\_to\_bitmap<vertex\_id\_type>(queue, curr);}
\DoxyCodeLine{497 }
\DoxyCodeLine{498       std::size\_t old\_awake\_count = 0;}
\DoxyCodeLine{499       \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{500         old\_awake\_count = awake\_count;}
\DoxyCodeLine{501         std::swap(front, curr);}
\DoxyCodeLine{502         curr.clear();}
\DoxyCodeLine{503 }
\DoxyCodeLine{504         awake\_count = tbb::parallel\_reduce(}
\DoxyCodeLine{505             tbb::blocked\_range(0ul, N), 0ul,}
\DoxyCodeLine{506             [\&](\textcolor{keyword}{auto}\&\& range, \textcolor{keyword}{auto} n) \{}
\DoxyCodeLine{507               \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& u = range.begin(), e = range.end(); u != e; ++u) \{}
\DoxyCodeLine{508                 if (null\_vertex == parents[u]) \{}
\DoxyCodeLine{509                   for (auto\&\& elt : in\_graph[u]) \{}
\DoxyCodeLine{510                     auto v = target(in\_graph, elt);}
\DoxyCodeLine{511                     if (front.get(v)) \{}
\DoxyCodeLine{512                       curr.atomic\_set(u);}
\DoxyCodeLine{513                       parents[u] = v;}
\DoxyCodeLine{514                       ++n;}
\DoxyCodeLine{515                       break;}
\DoxyCodeLine{516                     \}}
\DoxyCodeLine{517                   \}}
\DoxyCodeLine{518                 \}}
\DoxyCodeLine{519               \}}
\DoxyCodeLine{520               \textcolor{keywordflow}{return} n;}
\DoxyCodeLine{521             \}, std::plus\{\});}
\DoxyCodeLine{522       \} \textcolor{keywordflow}{while} ((awake\_count >= old\_awake\_count) || (awake\_count > N / beta));}
\DoxyCodeLine{523 }
\DoxyCodeLine{524       \textcolor{keywordflow}{if} (awake\_count == 0) \{}
\DoxyCodeLine{525         \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{526       \}}
\DoxyCodeLine{527 }
\DoxyCodeLine{528       bitmap\_to\_queue(curr, lqueue);}
\DoxyCodeLine{529       flush(lqueue, queue);}
\DoxyCodeLine{530 }
\DoxyCodeLine{531       scout\_count = 1;}
\DoxyCodeLine{532     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{533       edges\_to\_check -\/= scout\_count;}
\DoxyCodeLine{534       scout\_count = tbb::parallel\_reduce(tbb::blocked\_range(0ul, queue.size()), 0ul,}
\DoxyCodeLine{535                                          [\&](\textcolor{keyword}{auto}\&\&range, \textcolor{keyword}{auto} count) \{}
\DoxyCodeLine{536             int worker\_index = tbb::this\_task\_arena::current\_thread\_index();}
\DoxyCodeLine{537             for (auto\&\& i = range.begin(), e = range.end(); i != e; ++i) \{}
\DoxyCodeLine{538               auto u = queue[i];}
\DoxyCodeLine{539               for (auto\&\& elt : out\_graph[u]) \{}
\DoxyCodeLine{540                 auto v = target(out\_graph, elt);}
\DoxyCodeLine{541                 auto curr\_val = parents[v];}
\DoxyCodeLine{542                 if (null\_vertex == curr\_val) \{}
\DoxyCodeLine{543                   if (nw::graph::cas(parents[v], curr\_val, u)) \{}
\DoxyCodeLine{544                     lqueue[worker\_index].push\_back(v);}
\DoxyCodeLine{545                     count += out\_graph[v].size();}
\DoxyCodeLine{546                   \}}
\DoxyCodeLine{547                 \}}
\DoxyCodeLine{548               \}}
\DoxyCodeLine{549             \}}
\DoxyCodeLine{550             \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{551       \}, std::plus\{\});}
\DoxyCodeLine{552       flush(lqueue, queue);}
\DoxyCodeLine{553     \}}
\DoxyCodeLine{554   \}}
\DoxyCodeLine{555 }
\DoxyCodeLine{556   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{557 \}}
\DoxyCodeLine{558 }
\DoxyCodeLine{559 \textcolor{keyword}{template} <adjacency\_list\_graph OutGraph, adjacency\_list\_graph InGraph>}
\DoxyCodeLine{560 [[gnu::noinline]] \textcolor{keyword}{auto} bfs\_v2(\textcolor{keyword}{const} OutGraph\& out\_graph, \textcolor{keyword}{const} InGraph\& in\_graph, vertex\_id\_t<OutGraph> root, }
\DoxyCodeLine{561                               \textcolor{keywordtype}{int} num\_bins = 32, \textcolor{keywordtype}{int} alpha = 15, \textcolor{keywordtype}{int} beta = 18) \{}
\DoxyCodeLine{562 }
\DoxyCodeLine{563   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<OutGraph>;}
\DoxyCodeLine{564   \textcolor{keyword}{using} Vector = std::vector<vertex\_id\_type>;}
\DoxyCodeLine{565   \textcolor{keywordtype}{size\_t} n = nw::graph::pow2(nw::graph::ceil\_log2(num\_bins));}
\DoxyCodeLine{566   \textcolor{keywordtype}{size\_t} N = num\_vertices(out\_graph);}
\DoxyCodeLine{567   Vector parents(N);}
\DoxyCodeLine{568   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto} null\_vertex = null\_vertex\_v<vertex\_id\_type>();}
\DoxyCodeLine{569   std::fill(std::execution::par\_unseq, parents.begin(), parents.end(), null\_vertex);}
\DoxyCodeLine{570   parents[root] = root;}
\DoxyCodeLine{571   Vector frontier;}
\DoxyCodeLine{572   std::vector<Vector> nextfrontier(n);}
\DoxyCodeLine{573   frontier.reserve(N);}
\DoxyCodeLine{574   frontier.push\_back(root);}
\DoxyCodeLine{575   \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}} front(N, \textcolor{keyword}{false}), cur(N);}
\DoxyCodeLine{576   \textcolor{keywordtype}{size\_t} edges\_to\_check = out\_graph.to\_be\_indexed\_.size();}
\DoxyCodeLine{577   \textcolor{keywordtype}{size\_t} scout\_count = out\_graph[root].size();}
\DoxyCodeLine{578   }
\DoxyCodeLine{579   \textcolor{keywordflow}{while} (!frontier.empty()) \{}
\DoxyCodeLine{580     \textcolor{keywordflow}{if} (scout\_count > edges\_to\_check / alpha) \{}
\DoxyCodeLine{581       \textcolor{keywordtype}{size\_t} old\_awake\_count;}
\DoxyCodeLine{582       queue\_to\_bitmap<vertex\_id\_type>(frontier, front);}
\DoxyCodeLine{583       \textcolor{keywordtype}{size\_t} awake\_count = frontier.size();}
\DoxyCodeLine{584       \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{585         old\_awake\_count = awake\_count;}
\DoxyCodeLine{586         awake\_count = BU\_step(in\_graph, parents, front, cur);}
\DoxyCodeLine{587         std::swap(front, cur);}
\DoxyCodeLine{588       \} \textcolor{keywordflow}{while} ((awake\_count >= old\_awake\_count) || (awake\_count > N / beta));}
\DoxyCodeLine{589       bitmap\_to\_queue(front, nextfrontier);}
\DoxyCodeLine{590       flush(nextfrontier, frontier);}
\DoxyCodeLine{591       scout\_count = 1;}
\DoxyCodeLine{592     \}}
\DoxyCodeLine{593     \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{594       edges\_to\_check -\/= scout\_count;}
\DoxyCodeLine{595       scout\_count = TD\_step(out\_graph, parents, frontier, nextfrontier);}
\DoxyCodeLine{596       flush(nextfrontier, frontier);}
\DoxyCodeLine{597     \}}
\DoxyCodeLine{598   \}\textcolor{comment}{//while}}
\DoxyCodeLine{599 }
\DoxyCodeLine{600   \textcolor{keywordflow}{return} parents;}
\DoxyCodeLine{601 \}}
\DoxyCodeLine{602 }
\DoxyCodeLine{603 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{604 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{605 }
\DoxyCodeLine{606 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// NW\_GRAPH\_EXPERIMENTAL\_BFS\_HPP}}

\end{DoxyCode}
