\hypertarget{experimental_2algorithms_2betweenness__centrality_8hpp_source}{}\doxysection{betweenness\+\_\+centrality.\+hpp}
\label{experimental_2algorithms_2betweenness__centrality_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/experimental/algorithms/betweenness\_centrality.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/experimental/algorithms/betweenness\_centrality.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//     Luke D'Alessandro    }}
\DoxyCodeLine{12 \textcolor{comment}{//}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#ifndef BETWEENNESS\_EXPERIMENTAL\_CENTRALITY\_HPP}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#define BETWEENNESS\_EXPERIMENTAL\_CENTRALITY\_HPP}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/worklist.hpp"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}nwgraph/util/AtomicBitVector.hpp"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}nwgraph/util/atomic.hpp"{}}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}nwgraph/util/parallel\_for.hpp"{}}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include "{}nwgraph/util/util.hpp"{}}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{preprocessor}{\#if defined(CL\_SYCL\_LANGUAGE\_VERSION)}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <dpstd/algorithm>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <dpstd/execution>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <dpstd/numeric>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <execution>}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include <forward\_list>}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#include <future>}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#include <list>}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#include <mutex>}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#include <queue>}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#include <stack>}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#include <thread>}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{43 \textcolor{preprocessor}{\#include <unordered\_map>}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#include <unordered\_set>}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47 \textcolor{preprocessor}{\#include <tbb/concurrent\_queue.h>}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#include <tbb/concurrent\_vector.h>}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#include <tbb/parallel\_for\_each.h>}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{52 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1_spinlock}{Spinlock}} \{}
\DoxyCodeLine{55   std::atomic\_flag flag = ATOMIC\_FLAG\_INIT;}
\DoxyCodeLine{56 }
\DoxyCodeLine{57 \textcolor{keyword}{public}:}
\DoxyCodeLine{58   \textcolor{keywordtype}{void} lock() \{}
\DoxyCodeLine{59     \textcolor{keywordflow}{while} (flag.test\_and\_set(std::memory\_order\_acquire)) \{}
\DoxyCodeLine{60     \}}
\DoxyCodeLine{61   \}}
\DoxyCodeLine{62 }
\DoxyCodeLine{63   \textcolor{keywordtype}{void} unlock() \{ flag.clear(std::memory\_order\_release); \}}
\DoxyCodeLine{64 \};}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} score\_t = \textcolor{keywordtype}{float}, \textcolor{keyword}{typename} accum\_t = \textcolor{keywordtype}{size\_t}>}
\DoxyCodeLine{67 std::vector<score\_t> approx\_betweenness\_brandes(\textcolor{keyword}{const} Graph\& A, std::vector<typename Graph::vertex\_id\_type>\& sources) \{}
\DoxyCodeLine{68   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{69 }
\DoxyCodeLine{70   \textcolor{keywordtype}{size\_t}               n\_vtx = A.size();}
\DoxyCodeLine{71   std::vector<score\_t> centrality(n\_vtx, 0);}
\DoxyCodeLine{72 }
\DoxyCodeLine{73   std::stack<vertex\_id\_type> S;}
\DoxyCodeLine{74   std::queue<vertex\_id\_type> Q;}
\DoxyCodeLine{75   std::vector<accum\_t>       path\_counts(n\_vtx);}
\DoxyCodeLine{76   std::vector<score\_t>       d(n\_vtx);}
\DoxyCodeLine{77 }
\DoxyCodeLine{78   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& s : sources) \{}
\DoxyCodeLine{79     path\_counts.assign(n\_vtx, 0);}
\DoxyCodeLine{80     d.assign(n\_vtx, -\/1);}
\DoxyCodeLine{81     std::vector<std::list<size\_t>> P(n\_vtx);}
\DoxyCodeLine{82 }
\DoxyCodeLine{83     path\_counts[s] = 1;}
\DoxyCodeLine{84     d[s]           = 0;}
\DoxyCodeLine{85     Q.push(s);}
\DoxyCodeLine{86 }
\DoxyCodeLine{87     \textcolor{keywordflow}{while} (!Q.empty()) \{}
\DoxyCodeLine{88       \textcolor{keyword}{auto} v = Q.front();}
\DoxyCodeLine{89       Q.pop();}
\DoxyCodeLine{90       S.push(v);}
\DoxyCodeLine{91       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner = A[v].begin(); inner != A[v].end(); ++inner) \{}
\DoxyCodeLine{92         \textcolor{keyword}{auto} w = target(A, *inner);}
\DoxyCodeLine{93         \textcolor{comment}{//auto w = std::get<0>(*inner);}}
\DoxyCodeLine{94         \textcolor{keywordflow}{if} (d[w] < 0) \{}
\DoxyCodeLine{95           Q.push(w);}
\DoxyCodeLine{96           d[w] = d[v] + 1;}
\DoxyCodeLine{97         \}}
\DoxyCodeLine{98         \textcolor{keywordflow}{if} (d[w] == (d[v] + 1)) \{}
\DoxyCodeLine{99           path\_counts[w] += path\_counts[v];}
\DoxyCodeLine{100           P[w].push\_back(v);}
\DoxyCodeLine{101         \}}
\DoxyCodeLine{102       \}}
\DoxyCodeLine{103     \}}
\DoxyCodeLine{104 }
\DoxyCodeLine{105     std::vector<score\_t> delta(n\_vtx, 0);}
\DoxyCodeLine{106     \textcolor{keywordflow}{while} (!S.empty()) \{}
\DoxyCodeLine{107       \textcolor{keyword}{auto} w = S.top();}
\DoxyCodeLine{108       S.pop();}
\DoxyCodeLine{109       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = P[w].begin(); it != P[w].end(); ++it) \{}
\DoxyCodeLine{110         delta[*it] += \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(path\_counts[*it]) / \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(path\_counts[w]) * (1 + delta[w]);}
\DoxyCodeLine{111       \}}
\DoxyCodeLine{112       \textcolor{keywordflow}{if} (w != s) \{}
\DoxyCodeLine{113         centrality[w] += delta[w];}
\DoxyCodeLine{114       \}}
\DoxyCodeLine{115     \}}
\DoxyCodeLine{116   \}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118   score\_t largest = *std::max\_element(centrality.begin(), centrality.end());}
\DoxyCodeLine{119   std::transform(centrality.begin(), centrality.end(), centrality.begin(), [\&](\textcolor{keyword}{auto}\& val) \{ return val /= largest; \});}
\DoxyCodeLine{120   \textcolor{keywordflow}{return} centrality;}
\DoxyCodeLine{121 \}}
\DoxyCodeLine{122 }
\DoxyCodeLine{123 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} score\_t = \textcolor{keywordtype}{float}, \textcolor{keyword}{typename} accum\_t = \textcolor{keywordtype}{size\_t}>}
\DoxyCodeLine{124 std::vector<score\_t> approx\_betweenness\_worklist\_serial(\textcolor{keyword}{const} Graph\& A, std::vector<typename Graph::vertex\_id\_type>\& sources) \{}
\DoxyCodeLine{125   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{126 }
\DoxyCodeLine{127   \textcolor{keywordtype}{size\_t}               n\_vtx = A.size();}
\DoxyCodeLine{128   std::vector<score\_t> centrality(n\_vtx, 0);}
\DoxyCodeLine{129 }
\DoxyCodeLine{130   \textcolor{keyword}{struct }nodeinfo \{}
\DoxyCodeLine{131     \textcolor{keywordtype}{size\_t}                                                         l;}
\DoxyCodeLine{132     accum\_t                                                        path\_counts;}
\DoxyCodeLine{133     std::unordered\_set<vertex\_id\_type>                             preds;}
\DoxyCodeLine{134     std::unordered\_set<vertex\_id\_type>                             succs;}
\DoxyCodeLine{135     std::unordered\_map<vertex\_id\_type, std::pair<size\_t, accum\_t>> edge\_l\_s;}
\DoxyCodeLine{136   \};}
\DoxyCodeLine{137 }
\DoxyCodeLine{138   std::vector<size\_t>   succs\_ct(n\_vtx);}
\DoxyCodeLine{139   std::vector<score\_t>  delta(n\_vtx);}
\DoxyCodeLine{140   std::vector<nodeinfo> vertices(n\_vtx);}
\DoxyCodeLine{141 }
\DoxyCodeLine{142   \textcolor{keyword}{auto} g\_cn = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{143     \textcolor{keywordflow}{return} udata-\/>l >= vdata-\/>l \&\& udata-\/>edge\_l\_s[v].first == udata-\/>l \&\& udata-\/>l != std::numeric\_limits<std::uint32\_t>::max();}
\DoxyCodeLine{144   \};}
\DoxyCodeLine{145   \textcolor{keyword}{auto} apply\_cn = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{146     udata-\/>succs.erase(v);}
\DoxyCodeLine{147     udata-\/>edge\_l\_s[v].first = std::numeric\_limits<std::uint32\_t>::max();}
\DoxyCodeLine{148   \};}
\DoxyCodeLine{149   \textcolor{keyword}{auto} g\_sp       = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{ \textcolor{keywordflow}{return} vdata-\/>l > udata-\/>l + 1; \};}
\DoxyCodeLine{150   \textcolor{keyword}{auto} apply\_spfu = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{151     vdata-\/>l           = udata-\/>l + 1;}
\DoxyCodeLine{152     vdata-\/>path\_counts = udata-\/>path\_counts;}
\DoxyCodeLine{153     vdata-\/>preds.clear();}
\DoxyCodeLine{154     vdata-\/>succs.clear();}
\DoxyCodeLine{155     udata-\/>succs.emplace(v);}
\DoxyCodeLine{156     vdata-\/>preds.emplace(u);}
\DoxyCodeLine{157     udata-\/>edge\_l\_s[v].first  = udata-\/>l;}
\DoxyCodeLine{158     udata-\/>edge\_l\_s[v].second = udata-\/>path\_counts;}
\DoxyCodeLine{159   \};}
\DoxyCodeLine{160   \textcolor{keyword}{auto} g\_fu     = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{ \textcolor{keywordflow}{return} vdata-\/>l == udata-\/>l + 1 \&\& udata-\/>edge\_l\_s[v].first != udata-\/>l; \};}
\DoxyCodeLine{161   \textcolor{keyword}{auto} apply\_fu = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{162     vdata-\/>path\_counts += udata-\/>path\_counts;}
\DoxyCodeLine{163     udata-\/>succs.emplace(v);}
\DoxyCodeLine{164     vdata-\/>preds.emplace(u);}
\DoxyCodeLine{165     udata-\/>edge\_l\_s[v].first  = udata-\/>l;}
\DoxyCodeLine{166     udata-\/>edge\_l\_s[v].second = udata-\/>path\_counts;}
\DoxyCodeLine{167   \};}
\DoxyCodeLine{168   \textcolor{keyword}{auto} g\_us = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{169     \textcolor{keywordflow}{return} udata-\/>l == udata-\/>edge\_l\_s[v].first \&\& vdata-\/>l == udata-\/>l + 1 \&\& udata-\/>edge\_l\_s[v].second != udata-\/>path\_counts;}
\DoxyCodeLine{170   \};}
\DoxyCodeLine{171   \textcolor{keyword}{auto} apply\_us = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{172     vdata-\/>path\_counts        = vdata-\/>path\_counts + udata-\/>path\_counts -\/ udata-\/>edge\_l\_s[v].second;}
\DoxyCodeLine{173     udata-\/>edge\_l\_s[v].second = udata-\/>path\_counts;}
\DoxyCodeLine{174   \};}
\DoxyCodeLine{175 }
\DoxyCodeLine{176   worklist\_range<\textcolor{keyword}{decltype}(A), std::pair<vertex\_id\_type, vertex\_id\_type>> worklist(A);}
\DoxyCodeLine{177   worklist\_range<\textcolor{keyword}{decltype}(A), vertex\_id\_type>                            worklist\_back(A);}
\DoxyCodeLine{178   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& s : sources) \{}
\DoxyCodeLine{179 }
\DoxyCodeLine{180     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vertices.begin(); it != vertices.end(); ++it) \{}
\DoxyCodeLine{181       it-\/>l           = std::numeric\_limits<std::uint32\_t>::max();}
\DoxyCodeLine{182       it-\/>path\_counts = 0;}
\DoxyCodeLine{183       it-\/>preds.clear();}
\DoxyCodeLine{184       it-\/>succs.clear();}
\DoxyCodeLine{185       it-\/>edge\_l\_s.clear();}
\DoxyCodeLine{186     \}}
\DoxyCodeLine{187 }
\DoxyCodeLine{188     vertices[s].l           = 0;}
\DoxyCodeLine{189     vertices[s].path\_counts = 1;}
\DoxyCodeLine{190     std::fill(delta.begin(), delta.end(), 0);}
\DoxyCodeLine{191 }
\DoxyCodeLine{192     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner = A[s].begin(); inner != A[s].end(); ++inner) \{}
\DoxyCodeLine{193       worklist.push\_back(std::pair(s, std::get<0>(*inner)));}
\DoxyCodeLine{194     \}}
\DoxyCodeLine{195 }
\DoxyCodeLine{196     \textcolor{keyword}{auto} work = worklist.begin();}
\DoxyCodeLine{197     \textcolor{keywordflow}{for} (; work != worklist.end(); ++work) \{}
\DoxyCodeLine{198       \textcolor{comment}{// auto workitem = *(++work);}}
\DoxyCodeLine{199       \textcolor{keyword}{auto} workitem = *(work);}
\DoxyCodeLine{200       \textcolor{keyword}{auto} u        = std::get<0>(workitem);}
\DoxyCodeLine{201       \textcolor{keyword}{auto} v        = std::get<1>(workitem);}
\DoxyCodeLine{202 }
\DoxyCodeLine{203       nodeinfo* vdata = \&vertices[v];}
\DoxyCodeLine{204       nodeinfo* udata = \&vertices[u];}
\DoxyCodeLine{205       \textcolor{comment}{// lock u,v}}
\DoxyCodeLine{206 }
\DoxyCodeLine{207       \textcolor{keywordflow}{if} (g\_cn(u, v, udata, vdata)) \{}
\DoxyCodeLine{208         apply\_cn(u, v, udata, vdata);}
\DoxyCodeLine{209       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_sp(u, v, udata, vdata)) \{}
\DoxyCodeLine{210         std::vector<size\_t> temp\_preds(vdata-\/>preds.size());}
\DoxyCodeLine{211         \textcolor{keywordtype}{size\_t}              i = 0;}
\DoxyCodeLine{212         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vdata-\/>preds.begin(); it != vdata-\/>preds.end(); ++it) \{}
\DoxyCodeLine{213           temp\_preds[i] = *it;}
\DoxyCodeLine{214           ++i;}
\DoxyCodeLine{215         \}}
\DoxyCodeLine{216         apply\_spfu(u, v, udata, vdata);}
\DoxyCodeLine{217         \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{218 }
\DoxyCodeLine{219         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner = A[v].begin(); inner != A[v].end(); ++inner) \{}
\DoxyCodeLine{220           worklist.push\_back(std::pair(v, std::get<0>(*inner)));}
\DoxyCodeLine{221         \}}
\DoxyCodeLine{222         \textcolor{comment}{// Should this be all incoming edges?}}
\DoxyCodeLine{223         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} iter = temp\_preds.begin(); iter != temp\_preds.end(); ++iter) \{}
\DoxyCodeLine{224           worklist.push\_back(std::pair(*iter, v));}
\DoxyCodeLine{225         \}}
\DoxyCodeLine{226       \}    \textcolor{comment}{// else if (vdata-\/>l == udata-\/>l + 1 \&\& udata-\/>edge\_l\_s[v].first !=}}
\DoxyCodeLine{227       \textcolor{comment}{// udata-\/>l) \{}}
\DoxyCodeLine{228       \textcolor{comment}{// else if (vdata-\/>l == udata-\/>l + 1 \&\& udata-\/>edge\_l[v] != udata-\/>l) \{}}
\DoxyCodeLine{229       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_fu(u, v, udata, vdata)) \{}
\DoxyCodeLine{230         apply\_fu(u, v, udata, vdata);}
\DoxyCodeLine{231         \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{232         \textcolor{comment}{// should this include all neighbors of v?}}
\DoxyCodeLine{233         \textcolor{keywordflow}{if} (vdata-\/>succs.begin() != vdata-\/>succs.end()) \{}
\DoxyCodeLine{234           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner = A[v].begin(); inner != A[v].end(); ++inner) \{}
\DoxyCodeLine{235             worklist.push\_back(std::pair(v, std::get<0>(*inner)));}
\DoxyCodeLine{236           \}}
\DoxyCodeLine{237         \}}
\DoxyCodeLine{238         \textcolor{comment}{/*for (auto it = vertices[v].succs.begin(); it !=}}
\DoxyCodeLine{239 \textcolor{comment}{        vertices[v].succs.end(); ++it) \{ worklist.push\_back(std::pair(v, *it));}}
\DoxyCodeLine{240 \textcolor{comment}{        \}*/}}
\DoxyCodeLine{241       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_us(u, v, udata, vdata)) \{}
\DoxyCodeLine{242         apply\_us(u, v, udata, vdata);}
\DoxyCodeLine{243         \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{244 }
\DoxyCodeLine{245         \textcolor{comment}{// should this only be all neighbors of v?}}
\DoxyCodeLine{246         \textcolor{comment}{/*for (auto inner =A[v].begin(); inner !=}}
\DoxyCodeLine{247 \textcolor{comment}{       A[v].end(); ++inner) \{ worklist.push\_back(std::pair(v,}}
\DoxyCodeLine{248 \textcolor{comment}{        std::get<0>(*inner)));}}
\DoxyCodeLine{249 \textcolor{comment}{        \}*/}}
\DoxyCodeLine{250         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vdata-\/>succs.begin(); it != vdata-\/>succs.end(); ++it) \{}
\DoxyCodeLine{251           worklist.push\_back(std::pair(v, *it));}
\DoxyCodeLine{252         \}}
\DoxyCodeLine{253       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{254         \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{255       \}}
\DoxyCodeLine{256     \}}
\DoxyCodeLine{257 }
\DoxyCodeLine{258     vertex\_id\_type \textcolor{keywordtype}{id} = 0;}
\DoxyCodeLine{259     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vertices.begin(); it != vertices.end(); ++it) \{}
\DoxyCodeLine{260       succs\_ct[id] = it-\/>succs.size();}
\DoxyCodeLine{261 }
\DoxyCodeLine{262       \textcolor{keywordflow}{if} (it-\/>succs.empty()) \{}
\DoxyCodeLine{263         worklist\_back.push\_back(\textcolor{keywordtype}{id});}
\DoxyCodeLine{264       \}}
\DoxyCodeLine{265       ++id;}
\DoxyCodeLine{266     \}}
\DoxyCodeLine{267 }
\DoxyCodeLine{268     \textcolor{keyword}{auto} work2 = worklist\_back.begin();}
\DoxyCodeLine{269     \textcolor{keywordflow}{for} (; work2 != worklist\_back.end(); ++work2) \{}
\DoxyCodeLine{270       \textcolor{keyword}{auto}      workitem = *(work2);}
\DoxyCodeLine{271       \textcolor{keyword}{auto}      v        = workitem;}
\DoxyCodeLine{272       nodeinfo* vdata    = \&vertices[v];}
\DoxyCodeLine{273 }
\DoxyCodeLine{274       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vdata-\/>preds.begin(); it != vdata-\/>preds.end(); ++it) \{}
\DoxyCodeLine{275         \textcolor{comment}{// lock u (*it)}}
\DoxyCodeLine{276         \textcolor{keyword}{auto} u = *it;}
\DoxyCodeLine{277         delta[u] += \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(vertices[u].path\_counts) / \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(vdata-\/>path\_counts) * (1 + delta[v]);}
\DoxyCodeLine{278         succs\_ct[u]-\/-\/;}
\DoxyCodeLine{279         \textcolor{keywordflow}{if} (succs\_ct[u] == 0 \&\& u != s) worklist\_back.push\_back(u);}
\DoxyCodeLine{280       \}}
\DoxyCodeLine{281       centrality[v] += delta[v];}
\DoxyCodeLine{282     \}}
\DoxyCodeLine{283   \}}
\DoxyCodeLine{284 }
\DoxyCodeLine{285   score\_t largest = *std::max\_element(centrality.begin(), centrality.end());}
\DoxyCodeLine{286   std::transform(centrality.begin(), centrality.end(), centrality.begin(), [\&](\textcolor{keyword}{auto}\& val) \{ return val /= largest; \});}
\DoxyCodeLine{287   \textcolor{keywordflow}{return} centrality;}
\DoxyCodeLine{288 \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} score\_t = \textcolor{keywordtype}{float}, \textcolor{keyword}{typename} accum\_t = \textcolor{keywordtype}{size\_t}>}
\DoxyCodeLine{291 std::vector<score\_t> approx\_betweenness\_worklist(\textcolor{keyword}{const} Graph\& A, std::vector<typename Graph::vertex\_id\_type>\& sources, \textcolor{keywordtype}{size\_t} num\_threads,}
\DoxyCodeLine{292                                                  \textcolor{keywordtype}{size\_t} DELTA) \{}
\DoxyCodeLine{293   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{294 }
\DoxyCodeLine{295   \textcolor{keywordtype}{size\_t}               n\_vtx = A.size();}
\DoxyCodeLine{296   std::vector<score\_t> centrality(n\_vtx, 0);}
\DoxyCodeLine{297   \textcolor{comment}{// size\_t             DELTA = 200;}}
\DoxyCodeLine{298   \textcolor{keyword}{struct }nodeinfo \{}
\DoxyCodeLine{299     \textcolor{keywordtype}{size\_t}                                                         l;}
\DoxyCodeLine{300     accum\_t                                                        path\_counts;}
\DoxyCodeLine{301     std::unordered\_set<vertex\_id\_type>                             preds;}
\DoxyCodeLine{302     std::unordered\_set<vertex\_id\_type>                             succs;}
\DoxyCodeLine{303     std::unordered\_map<vertex\_id\_type, std::pair<size\_t, accum\_t>> edge\_l\_s;}
\DoxyCodeLine{304   \};}
\DoxyCodeLine{305 }
\DoxyCodeLine{306   std::vector<size\_t>     succs\_ct(n\_vtx);}
\DoxyCodeLine{307   std::vector<score\_t>    delta(n\_vtx);}
\DoxyCodeLine{308   std::vector<nodeinfo>   vertices(n\_vtx);}
\DoxyCodeLine{309   std::vector<Spinlock>   vector\_spinlocks(n\_vtx);}
\DoxyCodeLine{310   std::vector<std::mutex> locks(n\_vtx);}
\DoxyCodeLine{311   Spinlock                worklock;}
\DoxyCodeLine{312   \textcolor{keyword}{auto}                    g\_cn = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{313     \textcolor{keywordflow}{return} udata-\/>l >= vdata-\/>l \&\& udata-\/>edge\_l\_s[v].first == udata-\/>l \&\& udata-\/>l != std::numeric\_limits<std::uint32\_t>::max();}
\DoxyCodeLine{314   \};}
\DoxyCodeLine{315   \textcolor{keyword}{auto} apply\_cn = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{316     udata-\/>succs.erase(v);}
\DoxyCodeLine{317     udata-\/>edge\_l\_s[v].first = std::numeric\_limits<std::uint32\_t>::max();}
\DoxyCodeLine{318   \};}
\DoxyCodeLine{319   \textcolor{keyword}{auto} g\_sp       = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{ \textcolor{keywordflow}{return} vdata-\/>l > udata-\/>l + 1; \};}
\DoxyCodeLine{320   \textcolor{keyword}{auto} apply\_spfu = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{321     vdata-\/>l           = udata-\/>l + 1;}
\DoxyCodeLine{322     vdata-\/>path\_counts = udata-\/>path\_counts;}
\DoxyCodeLine{323     vdata-\/>preds.clear();}
\DoxyCodeLine{324     vdata-\/>succs.clear();}
\DoxyCodeLine{325     udata-\/>succs.emplace(v);}
\DoxyCodeLine{326     vdata-\/>preds.emplace(u);}
\DoxyCodeLine{327     udata-\/>edge\_l\_s[v].first  = udata-\/>l;}
\DoxyCodeLine{328     udata-\/>edge\_l\_s[v].second = udata-\/>path\_counts;}
\DoxyCodeLine{329   \};}
\DoxyCodeLine{330   \textcolor{keyword}{auto} g\_fu     = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{ \textcolor{keywordflow}{return} vdata-\/>l == udata-\/>l + 1 \&\& udata-\/>edge\_l\_s[v].first != udata-\/>l; \};}
\DoxyCodeLine{331   \textcolor{keyword}{auto} apply\_fu = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{332     vdata-\/>path\_counts += udata-\/>path\_counts;}
\DoxyCodeLine{333     udata-\/>succs.emplace(v);}
\DoxyCodeLine{334     vdata-\/>preds.emplace(u);}
\DoxyCodeLine{335     udata-\/>edge\_l\_s[v].first  = udata-\/>l;}
\DoxyCodeLine{336     udata-\/>edge\_l\_s[v].second = udata-\/>path\_counts;}
\DoxyCodeLine{337   \};}
\DoxyCodeLine{338   \textcolor{keyword}{auto} g\_us = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{339     \textcolor{keywordflow}{return} udata-\/>l == udata-\/>edge\_l\_s[v].first \&\& vdata-\/>l == udata-\/>l + 1 \&\& udata-\/>edge\_l\_s[v].second != udata-\/>path\_counts;}
\DoxyCodeLine{340   \};}
\DoxyCodeLine{341   \textcolor{keyword}{auto} apply\_us = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{342     vdata-\/>path\_counts        = vdata-\/>path\_counts + udata-\/>path\_counts -\/ udata-\/>edge\_l\_s[v].second;}
\DoxyCodeLine{343     udata-\/>edge\_l\_s[v].second = udata-\/>path\_counts;}
\DoxyCodeLine{344   \};}
\DoxyCodeLine{345 }
\DoxyCodeLine{346   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& s : sources) \{}
\DoxyCodeLine{347     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vertices.begin(); it != vertices.end(); ++it) \{}
\DoxyCodeLine{348       it-\/>l           = std::numeric\_limits<std::uint32\_t>::max();}
\DoxyCodeLine{349       it-\/>path\_counts = 0;}
\DoxyCodeLine{350       it-\/>preds.clear();}
\DoxyCodeLine{351       it-\/>succs.clear();}
\DoxyCodeLine{352       it-\/>edge\_l\_s.clear();}
\DoxyCodeLine{353     \}}
\DoxyCodeLine{354 }
\DoxyCodeLine{355     vertices[s].l           = 0;}
\DoxyCodeLine{356     vertices[s].path\_counts = 1;}
\DoxyCodeLine{357     std::fill(delta.begin(), delta.end(), 0);}
\DoxyCodeLine{358     tbb::concurrent\_queue<std::pair<vertex\_id\_type, vertex\_id\_type>> myqueue;}
\DoxyCodeLine{359     \textcolor{comment}{// tbbworklist\_range<decltype(A), std::pair<std::pair<vertex\_id\_type,}}
\DoxyCodeLine{360     \textcolor{comment}{// vertex\_id\_type>, size\_t>, DELTAQ> worklist(A);}}
\DoxyCodeLine{361     tbbworklist\_range2<\textcolor{keyword}{decltype}(A), std::pair<vertex\_id\_type, vertex\_id\_type>> worklist(A);}
\DoxyCodeLine{362     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner = A[s].begin(); inner != A[s].end(); ++inner) \{}
\DoxyCodeLine{363       \textcolor{comment}{// worklist.push\_back(std::pair(s, std::get<0>(*inner)));}}
\DoxyCodeLine{364       worklist.push\_back(std::pair(s, std::get<0>(*inner)), 0);}
\DoxyCodeLine{365       \textcolor{comment}{// myqueue.push(std::pair(s, std::get<0>(*inner)));}}
\DoxyCodeLine{366     \}}
\DoxyCodeLine{367     std::pair<vertex\_id\_type, vertex\_id\_type> dummy1(0, 0);}
\DoxyCodeLine{368     worklist.set\_dummy(dummy1);}
\DoxyCodeLine{369 }
\DoxyCodeLine{370     std::vector<std::future<void>> futures(num\_threads);}
\DoxyCodeLine{371     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} thread = 0; thread < num\_threads; ++thread) \{}
\DoxyCodeLine{372       futures[thread] = std::async(}
\DoxyCodeLine{373           std::launch::async,}
\DoxyCodeLine{374           [\&](\textcolor{keywordtype}{size\_t} thread) \{}
\DoxyCodeLine{375             \textcolor{keyword}{thread\_local} \textcolor{keyword}{auto} work = worklist.begin();}
\DoxyCodeLine{376             \textcolor{keywordflow}{for} (; work != worklist.end(); ++work) \{}
\DoxyCodeLine{377               \textcolor{keywordflow}{if} (*work != dummy1) \{}
\DoxyCodeLine{378 }
\DoxyCodeLine{379                 \textcolor{comment}{// while (myqueue.unsafe\_size() > 0) \{}}
\DoxyCodeLine{380                 \textcolor{comment}{/*size\_t buffer\_size=50;}}
\DoxyCodeLine{381 \textcolor{comment}{                                       std::vector<std::pair<vertex\_id\_type,}}
\DoxyCodeLine{382 \textcolor{comment}{                   vertex\_id\_type>> buffer(buffer\_size); for(size\_t j = 0; j <}}
\DoxyCodeLine{383 \textcolor{comment}{                   buffer\_size; ++j) \{ buffer[j] = *(++work);}}
\DoxyCodeLine{384 \textcolor{comment}{                                       \}}}
\DoxyCodeLine{385 \textcolor{comment}{                                       for(size\_t j = 0; j < buffer\_size; ++j) \{}}
\DoxyCodeLine{386 \textcolor{comment}{                                         auto workitem = buffer[j];*/}}
\DoxyCodeLine{387                 \textcolor{comment}{// auto      workitembuffer = *(++work);}}
\DoxyCodeLine{388                 \textcolor{comment}{// std::cout << "{}anything"{} << std::endl;}}
\DoxyCodeLine{389                 \textcolor{comment}{// for(auto workitem = (*work).begin(); workitem !=}}
\DoxyCodeLine{390                 \textcolor{comment}{// (*work).end(); ++workitem) \{}}
\DoxyCodeLine{391                 \textcolor{comment}{// std::for\_each(std::execution::par\_unseq,(*work).begin(),}}
\DoxyCodeLine{392                 \textcolor{comment}{// (*work).end(), [\&](auto \&workitem) \{}}
\DoxyCodeLine{393 }
\DoxyCodeLine{394                 \textcolor{comment}{// for (auto workitem = (*work).begin(); workitem !=}}
\DoxyCodeLine{395                 \textcolor{comment}{// (*work).end(); ++workitem) \{ auto workitem = *y;}}
\DoxyCodeLine{396                 \textcolor{comment}{// std::pair<vertex\_id\_type, vertex\_id\_type> workitem;}}
\DoxyCodeLine{397                 \textcolor{comment}{// if (myqueue.try\_pop(workitem)) \{}}
\DoxyCodeLine{398                 \textcolor{comment}{// if(*workitem != dummy1) \{}}
\DoxyCodeLine{399                 \textcolor{keyword}{auto} u = std::get<0>(*work);}
\DoxyCodeLine{400                 \textcolor{keyword}{auto} v = std::get<1>(*work);}
\DoxyCodeLine{401                 \textcolor{keywordflow}{if} (u < v) \{}
\DoxyCodeLine{402                   vector\_spinlocks[u].lock();}
\DoxyCodeLine{403                   vector\_spinlocks[v].lock();}
\DoxyCodeLine{404                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{405                   vector\_spinlocks[v].lock();}
\DoxyCodeLine{406                   vector\_spinlocks[u].lock();}
\DoxyCodeLine{407                 \}}
\DoxyCodeLine{408 }
\DoxyCodeLine{409                 \textcolor{comment}{// std::cout << u << "{} "{} << v << std::endl;}}
\DoxyCodeLine{410                 nodeinfo* udata = \&vertices[u];}
\DoxyCodeLine{411                 nodeinfo* vdata = \&vertices[v];}
\DoxyCodeLine{412                 \textcolor{comment}{// lock u,v}}
\DoxyCodeLine{413                 \textcolor{keywordflow}{if} (g\_cn(u, v, udata, vdata)) \{}
\DoxyCodeLine{414                   apply\_cn(u, v, udata, vdata);}
\DoxyCodeLine{415                   vector\_spinlocks[v].unlock();}
\DoxyCodeLine{416                   vector\_spinlocks[u].unlock();}
\DoxyCodeLine{417                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_sp(u, v, udata, vdata)) \{}
\DoxyCodeLine{418                   std::vector<size\_t> temp\_preds(vdata-\/>preds.size());}
\DoxyCodeLine{419                   \textcolor{keywordtype}{size\_t}              i = 0;}
\DoxyCodeLine{420                   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vdata-\/>preds.begin(); it != vdata-\/>preds.end(); ++it) \{}
\DoxyCodeLine{421                     temp\_preds[i] = *it;}
\DoxyCodeLine{422                     ++i;}
\DoxyCodeLine{423                   \}}
\DoxyCodeLine{424                   apply\_spfu(u, v, udata, vdata);}
\DoxyCodeLine{425                   \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{426                   vector\_spinlocks[u].unlock();}
\DoxyCodeLine{427 }
\DoxyCodeLine{428                   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner = A[v].begin(); inner != A[v].end(); ++inner) \{}
\DoxyCodeLine{429                     \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{430                     \textcolor{comment}{// worklist.push\_back(std::pair(v, std::get<0>(*inner)));}}
\DoxyCodeLine{431                     \textcolor{comment}{// myqueue.push(std::pair(v, std::get<0>(*inner)));}}
\DoxyCodeLine{432                     worklist.push\_back(std::pair(v, std::get<0>(*inner)), priority);}
\DoxyCodeLine{433                   \}}
\DoxyCodeLine{434 }
\DoxyCodeLine{435                   \textcolor{comment}{// Should this be all incoming edges?}}
\DoxyCodeLine{436                   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} iter = temp\_preds.begin(); iter != temp\_preds.end(); ++iter) \{}
\DoxyCodeLine{437                     \textcolor{keywordtype}{size\_t} priority = (vertices[*iter].l + 1) / DELTA;}
\DoxyCodeLine{438                     \textcolor{comment}{// worklist.push\_back(std::pair(*iter, v));}}
\DoxyCodeLine{439                     \textcolor{comment}{// myqueue.push(std::pair(*iter, v));}}
\DoxyCodeLine{440                     worklist.push\_back(std::pair(*iter, v), priority);}
\DoxyCodeLine{441                   \}}
\DoxyCodeLine{442                   vector\_spinlocks[v].unlock();}
\DoxyCodeLine{443                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_fu(u, v, udata, vdata)) \{}
\DoxyCodeLine{444                   apply\_fu(u, v, udata, vdata);}
\DoxyCodeLine{445                   \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{446                   vector\_spinlocks[u].unlock();}
\DoxyCodeLine{447 }
\DoxyCodeLine{448                   \textcolor{comment}{// should this only be succ of v?}}
\DoxyCodeLine{449                   \textcolor{keywordflow}{if} (vdata-\/>succs.begin() != vdata-\/>succs.end()) \{}
\DoxyCodeLine{450                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner = A[v].begin(); inner != A[v].end(); ++inner) \{}
\DoxyCodeLine{451                       \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{452                       \textcolor{comment}{// worklist.push\_back(std::pair(v, std::get<0>(*inner)));}}
\DoxyCodeLine{453                       \textcolor{comment}{// myqueue.push(std::pair(v, std::get<0>(*inner)));}}
\DoxyCodeLine{454                       worklist.push\_back(std::pair(v, std::get<0>(*inner)), priority);}
\DoxyCodeLine{455                     \}}
\DoxyCodeLine{456                   \}}
\DoxyCodeLine{457                   vector\_spinlocks[v].unlock();}
\DoxyCodeLine{458                   \textcolor{comment}{/*for (auto it = vdata-\/>succs.begin(); it !=}}
\DoxyCodeLine{459 \textcolor{comment}{                     vdata-\/>succs.end(); ++it) \{ worklist.push\_back(std::pair(v,}}
\DoxyCodeLine{460 \textcolor{comment}{                     *it));}}
\DoxyCodeLine{461 \textcolor{comment}{                       \}*/}}
\DoxyCodeLine{462                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_us(u, v, udata, vdata)) \{}
\DoxyCodeLine{463                   apply\_us(u, v, udata, vdata);}
\DoxyCodeLine{464                   \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{465                   vector\_spinlocks[u].unlock();}
\DoxyCodeLine{466 }
\DoxyCodeLine{467                   \textcolor{comment}{// should this only be succ of v?}}
\DoxyCodeLine{468                   \textcolor{comment}{/*for (auto inner =A[v].begin(); inner !=}}
\DoxyCodeLine{469 \textcolor{comment}{                    A[v].end(); ++inner) \{}}
\DoxyCodeLine{470 \textcolor{comment}{                         worklist.push\_back(std::pair(v, std::get<0>(*inner)));}}
\DoxyCodeLine{471 \textcolor{comment}{                       \}*/}}
\DoxyCodeLine{472 }
\DoxyCodeLine{473                   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vdata-\/>succs.begin(); it != vdata-\/>succs.end(); ++it) \{}
\DoxyCodeLine{474                     \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{475                     worklist.push\_back(std::pair(v, *it), priority);}
\DoxyCodeLine{476                     \textcolor{comment}{// worklist.push\_back(std::pair(v, *it));}}
\DoxyCodeLine{477                     \textcolor{comment}{// myqueue.push(std::pair(v, *it));}}
\DoxyCodeLine{478                   \}}
\DoxyCodeLine{479                   vector\_spinlocks[v].unlock();}
\DoxyCodeLine{480                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{481                   \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{482                   vector\_spinlocks[v].unlock();}
\DoxyCodeLine{483                   vector\_spinlocks[u].unlock();}
\DoxyCodeLine{484                 \}}
\DoxyCodeLine{485               \}}
\DoxyCodeLine{486             \}}
\DoxyCodeLine{487             \textcolor{keywordflow}{return};}
\DoxyCodeLine{488           \},}
\DoxyCodeLine{489           thread);}
\DoxyCodeLine{490     \}}
\DoxyCodeLine{491     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < num\_threads; ++i) \{}
\DoxyCodeLine{492       futures[i].get();}
\DoxyCodeLine{493     \}}
\DoxyCodeLine{494     \textcolor{comment}{// std::cout << "{}here"{} << std::endl;}}
\DoxyCodeLine{495     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} work = worklist.begin(); work != worklist.end(); ++work) \{}
\DoxyCodeLine{496       \textcolor{comment}{// auto      workitembuffer = *(++work);}}
\DoxyCodeLine{497       \textcolor{comment}{// for (auto workitem = (*work).begin(); workitem != (*work).end();}}
\DoxyCodeLine{498       \textcolor{comment}{// ++workitem) \{}}
\DoxyCodeLine{499       \textcolor{keywordflow}{if} (*work != dummy1) \{}
\DoxyCodeLine{500         \textcolor{keyword}{auto} u = std::get<0>(*work);}
\DoxyCodeLine{501         \textcolor{keyword}{auto} v = std::get<1>(*work);}
\DoxyCodeLine{502         std::cout << u << \textcolor{stringliteral}{"{} "{}} << v << std::endl;}
\DoxyCodeLine{503         nodeinfo* vdata = \&vertices[v];}
\DoxyCodeLine{504         nodeinfo* udata = \&vertices[u];}
\DoxyCodeLine{505 }
\DoxyCodeLine{506         \textcolor{keywordflow}{if} (g\_cn(u, v, udata, vdata)) \{}
\DoxyCodeLine{507           apply\_cn(u, v, udata, vdata);}
\DoxyCodeLine{508         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_sp(u, v, udata, vdata)) \{}
\DoxyCodeLine{509           std::vector<size\_t> temp\_preds(vdata-\/>preds.size());}
\DoxyCodeLine{510           \textcolor{keywordtype}{size\_t}              i = 0;}
\DoxyCodeLine{511           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vdata-\/>preds.begin(); it != vdata-\/>preds.end(); ++it) \{}
\DoxyCodeLine{512             temp\_preds[i] = *it;}
\DoxyCodeLine{513             ++i;}
\DoxyCodeLine{514           \}}
\DoxyCodeLine{515           apply\_spfu(u, v, udata, vdata);}
\DoxyCodeLine{516           \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{517 }
\DoxyCodeLine{518           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner =A[v].begin(); inner !=A[v].end(); ++inner) \{}
\DoxyCodeLine{519             \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{520             \textcolor{comment}{// worklist.push\_back(std::pair(v, std::get<0>(*inner)));}}
\DoxyCodeLine{521             worklist.push\_back(std::pair(v, std::get<0>(*inner)), priority);}
\DoxyCodeLine{522           \}}
\DoxyCodeLine{523           \textcolor{comment}{// Should this be all incoming edges?}}
\DoxyCodeLine{524           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} iter = temp\_preds.begin(); iter != temp\_preds.end(); ++iter) \{}
\DoxyCodeLine{525             \textcolor{keywordtype}{size\_t} priority = (vertices[*iter].l + 1) / DELTA;}
\DoxyCodeLine{526             \textcolor{comment}{// worklist.push\_back(std::pair(*iter, v));}}
\DoxyCodeLine{527             worklist.push\_back(std::pair(*iter, v), priority);}
\DoxyCodeLine{528           \}}
\DoxyCodeLine{529         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_fu(u, v, udata, vdata)) \{}
\DoxyCodeLine{530           apply\_fu(u, v, udata, vdata);}
\DoxyCodeLine{531           \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{532           \textcolor{comment}{// should this include all neighbors of v?}}
\DoxyCodeLine{533           \textcolor{keywordflow}{if} (vdata-\/>succs.begin() != vdata-\/>succs.end()) \{}
\DoxyCodeLine{534             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner =A[v].begin(); inner !=A[v].end(); ++inner) \{}
\DoxyCodeLine{535               \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{536               worklist.push\_back(std::pair(v, std::get<0>(*inner)), priority);}
\DoxyCodeLine{537             \}}
\DoxyCodeLine{538           \}}
\DoxyCodeLine{539         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_us(u, v, udata, vdata)) \{}
\DoxyCodeLine{540           apply\_us(u, v, udata, vdata);}
\DoxyCodeLine{541           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vdata-\/>succs.begin(); it != vdata-\/>succs.end(); ++it) \{}
\DoxyCodeLine{542             \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{543             \textcolor{comment}{// worklist.push\_back(std::pair(v, *it));}}
\DoxyCodeLine{544             worklist.push\_back(std::pair(v, *it), priority);}
\DoxyCodeLine{545           \}}
\DoxyCodeLine{546         \}}
\DoxyCodeLine{547       \}}
\DoxyCodeLine{548     \}}
\DoxyCodeLine{549 }
\DoxyCodeLine{550     std::cout << \textcolor{stringliteral}{"{}back"{}} << std::endl;}
\DoxyCodeLine{551     tbbworklist\_range<\textcolor{keyword}{decltype}(A), vertex\_id\_type> worklist\_back(A);}
\DoxyCodeLine{552 }
\DoxyCodeLine{553     std::vector<size\_t> succs\_ct(n\_vtx);}
\DoxyCodeLine{554     \textcolor{comment}{// std::cout << "{}back"{} << std::endl;}}
\DoxyCodeLine{555     \textcolor{keywordflow}{for} (vertex\_id\_type v = 0; v < A.max() + 1; ++v) \{}
\DoxyCodeLine{556       succs\_ct[v] = vertices[v].succs.size();}
\DoxyCodeLine{557       \textcolor{keywordflow}{if} (vertices[v].succs.empty()) \{}
\DoxyCodeLine{558         worklist\_back.push\_back(v);}
\DoxyCodeLine{559       \}}
\DoxyCodeLine{560     \}}
\DoxyCodeLine{561 }
\DoxyCodeLine{562     worklist\_back.set\_dummy(std::numeric\_limits<std::uint32\_t>::max());}
\DoxyCodeLine{563     std::vector<std::future<void>> futures2(num\_threads);}
\DoxyCodeLine{564     \textcolor{comment}{// std::cout << "{}num\_threads "{} << num\_threads << std::endl;}}
\DoxyCodeLine{565     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} thread = 0; thread < num\_threads; ++thread) \{}
\DoxyCodeLine{566       futures2[thread] = std::async(}
\DoxyCodeLine{567           std::launch::async,}
\DoxyCodeLine{568           [\&](\textcolor{keywordtype}{size\_t} thread) \{}
\DoxyCodeLine{569             \textcolor{comment}{// std::cout << "{}starting on "{} << thread << std::endl;}}
\DoxyCodeLine{570             \textcolor{keyword}{thread\_local} \textcolor{keyword}{auto} work2 = worklist\_back.begin();}
\DoxyCodeLine{571             \textcolor{keywordflow}{for} (; work2 != worklist\_back.end(); ++work2) \{}
\DoxyCodeLine{572               \textcolor{comment}{// auto workitembuffer = *(++work2);}}
\DoxyCodeLine{573               \textcolor{comment}{// for (auto y : workitembuffer) \{}}
\DoxyCodeLine{574               \textcolor{comment}{// auto workitem = y;}}
\DoxyCodeLine{575               \textcolor{keywordflow}{if} (*work2 != std::numeric\_limits<std::uint32\_t>::max()) \{}
\DoxyCodeLine{576                 \textcolor{keyword}{auto} v = *work2;}
\DoxyCodeLine{577                 \textcolor{comment}{// std::cout << "{}thread "{} << thread << "{} taking "{} << v <<}}
\DoxyCodeLine{578                 \textcolor{comment}{// std::endl; vector\_spinlocks[v].lock(); locks[v].lock();}}
\DoxyCodeLine{579                 \textcolor{comment}{// std::cout << "{}thread "{} << thread << "{} got "{} << v <<}}
\DoxyCodeLine{580                 \textcolor{comment}{// std::endl;}}
\DoxyCodeLine{581                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vertices[v].preds.begin(); it != vertices[v].preds.end(); ++it) \{}
\DoxyCodeLine{582                   auto u = *it;}
\DoxyCodeLine{583                   \textcolor{comment}{// std::cout << "{}u "{} << u << std::endl;}}
\DoxyCodeLine{584                   vector\_spinlocks[u].lock();}
\DoxyCodeLine{585                   \textcolor{comment}{// locks[u].lock();}}
\DoxyCodeLine{586                   delta[u] =}
\DoxyCodeLine{587                       delta[u] + static\_cast<score\_t>(vertices[u].path\_counts) / static\_cast<score\_t>(vertices[v].path\_counts) * (1 + delta[v]);}
\DoxyCodeLine{588                   \textcolor{comment}{// succs[u].erase(v);}}
\DoxyCodeLine{589                   succs\_ct[u]-\/-\/;}
\DoxyCodeLine{590                   \textcolor{comment}{// if (succs[u].empty() \&\& u != s) worklist\_back.push\_back(u);}}
\DoxyCodeLine{591                   if (succs\_ct[u] == 0 \&\& u != s) \{}
\DoxyCodeLine{592                     worklist\_back.push\_back(u);}
\DoxyCodeLine{593                   \}}
\DoxyCodeLine{594                   vector\_spinlocks[u].unlock();}
\DoxyCodeLine{595                   \textcolor{comment}{// locks[u].unlock();}}
\DoxyCodeLine{596                 \}}
\DoxyCodeLine{597                 centrality[v] += delta[v];}
\DoxyCodeLine{598                 \textcolor{comment}{// vector\_spinlocks[v].unlock();}}
\DoxyCodeLine{599                 \textcolor{comment}{// locks[v].unlock();}}
\DoxyCodeLine{600               \}}
\DoxyCodeLine{601             \}}
\DoxyCodeLine{602 }
\DoxyCodeLine{603             \textcolor{comment}{// std::cout << "{}thread "{} << thread << "{} done"{} << std::endl;}}
\DoxyCodeLine{604 }
\DoxyCodeLine{605             \textcolor{keywordflow}{return};}
\DoxyCodeLine{606           \},}
\DoxyCodeLine{607           thread);}
\DoxyCodeLine{608     \}}
\DoxyCodeLine{609     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < num\_threads; ++i) \{}
\DoxyCodeLine{610       futures2[i].get();}
\DoxyCodeLine{611     \}}
\DoxyCodeLine{612   \}}
\DoxyCodeLine{613   \textcolor{keywordflow}{return} centrality;}
\DoxyCodeLine{614 \}}
\DoxyCodeLine{615 }
\DoxyCodeLine{616 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} score\_t = \textcolor{keywordtype}{float}, \textcolor{keyword}{typename} accum\_t = \textcolor{keywordtype}{size\_t}>}
\DoxyCodeLine{617 std::vector<score\_t> approx\_betweenness\_worklist\_noabstraction(\textcolor{keyword}{const} Graph\& A, std::vector<typename Graph::vertex\_id\_type>\& sources,}
\DoxyCodeLine{618                                                                \textcolor{keywordtype}{size\_t} num\_threads, \textcolor{keywordtype}{size\_t} par\_thresh, \textcolor{keywordtype}{size\_t} DELTA = 1) \{}
\DoxyCodeLine{619   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{620 }
\DoxyCodeLine{621   \textcolor{keywordtype}{size\_t}               n\_vtx = A.size();}
\DoxyCodeLine{622   std::vector<score\_t> centrality(n\_vtx, 0.0);}
\DoxyCodeLine{623   \textcolor{keywordtype}{bool}                 levelsets       = \textcolor{keyword}{true};}
\DoxyCodeLine{624   \textcolor{keywordtype}{size\_t}               back\_buffersize = 100;}
\DoxyCodeLine{625   \textcolor{keywordtype}{bool}                 asyncv1         = \textcolor{keyword}{true};}
\DoxyCodeLine{626 }
\DoxyCodeLine{627   \textcolor{keyword}{struct }nodeinfo \{}
\DoxyCodeLine{628     \textcolor{keywordtype}{size\_t}                                                         l;}
\DoxyCodeLine{629     accum\_t                                                        path\_counts;}
\DoxyCodeLine{630     std::forward\_list<vertex\_id\_type>                              preds;}
\DoxyCodeLine{631     std::forward\_list<vertex\_id\_type>                              succs;}
\DoxyCodeLine{632     std::unordered\_map<vertex\_id\_type, std::pair<size\_t, accum\_t>> edge\_l\_s;}
\DoxyCodeLine{633   \};}
\DoxyCodeLine{634 }
\DoxyCodeLine{635   \textcolor{keyword}{auto} g\_cn = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{636     \textcolor{keywordflow}{return} udata-\/>l >= vdata-\/>l \&\& udata-\/>edge\_l\_s[v].first == udata-\/>l \&\& udata-\/>l != std::numeric\_limits<std::uint32\_t>::max();}
\DoxyCodeLine{637   \};}
\DoxyCodeLine{638   \textcolor{keyword}{auto} apply\_cn = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{639     udata-\/>succs.remove(v);}
\DoxyCodeLine{640     udata-\/>edge\_l\_s[v].first = std::numeric\_limits<std::uint32\_t>::max();}
\DoxyCodeLine{641   \};}
\DoxyCodeLine{642   \textcolor{keyword}{auto} g\_sp       = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{ \textcolor{keywordflow}{return} vdata-\/>l > udata-\/>l + 1; \};}
\DoxyCodeLine{643   \textcolor{keyword}{auto} apply\_spfu = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{644     vdata-\/>l           = udata-\/>l + 1;}
\DoxyCodeLine{645     vdata-\/>path\_counts = udata-\/>path\_counts;}
\DoxyCodeLine{646     vdata-\/>preds.clear();}
\DoxyCodeLine{647     vdata-\/>succs.clear();}
\DoxyCodeLine{648     udata-\/>succs.emplace\_front(v);}
\DoxyCodeLine{649     udata-\/>edge\_l\_s[v].first  = udata-\/>l;}
\DoxyCodeLine{650     udata-\/>edge\_l\_s[v].second = udata-\/>path\_counts;}
\DoxyCodeLine{651     vdata-\/>preds.emplace\_front(u);}
\DoxyCodeLine{652   \};}
\DoxyCodeLine{653   \textcolor{keyword}{auto} g\_fu     = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{ \textcolor{keywordflow}{return} vdata-\/>l == udata-\/>l + 1 \&\& udata-\/>edge\_l\_s[v].first != udata-\/>l; \};}
\DoxyCodeLine{654   \textcolor{keyword}{auto} apply\_fu = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{655     vdata-\/>path\_counts += udata-\/>path\_counts;}
\DoxyCodeLine{656     udata-\/>succs.emplace\_front(v);}
\DoxyCodeLine{657     \textcolor{comment}{// vdata-\/>preds.push\_back(u);}}
\DoxyCodeLine{658     udata-\/>edge\_l\_s[v].first  = udata-\/>l;}
\DoxyCodeLine{659     udata-\/>edge\_l\_s[v].second = udata-\/>path\_counts;}
\DoxyCodeLine{660     \textcolor{comment}{// udata-\/>succs.emplace\_front(std::tuple(v, udata-\/>l, udata-\/>path\_counts));}}
\DoxyCodeLine{661     vdata-\/>preds.emplace\_front(u);}
\DoxyCodeLine{662   \};}
\DoxyCodeLine{663   \textcolor{keyword}{auto} g\_us = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{664     \textcolor{keywordflow}{return} udata-\/>l == udata-\/>edge\_l\_s[v].first \&\& vdata-\/>l == udata-\/>l + 1 \&\& udata-\/>edge\_l\_s[v].second != udata-\/>path\_counts;}
\DoxyCodeLine{665     \textcolor{comment}{// return udata-\/>l == std::get<1>(*it) \&\& vdata-\/>l == udata-\/>l + 1 \&\&}}
\DoxyCodeLine{666     \textcolor{comment}{// std::get<2>(*it) != udata-\/>path\_counts;}}
\DoxyCodeLine{667   \};}
\DoxyCodeLine{668   \textcolor{keyword}{auto} apply\_us = [](\textcolor{keyword}{auto}\& u, \textcolor{keyword}{auto}\& v, \textcolor{keyword}{auto}\& udata, \textcolor{keyword}{auto}\& vdata) \{}
\DoxyCodeLine{669     vdata-\/>path\_counts        = vdata-\/>path\_counts + udata-\/>path\_counts -\/ udata-\/>edge\_l\_s[v].second;}
\DoxyCodeLine{670     udata-\/>edge\_l\_s[v].second = udata-\/>path\_counts;}
\DoxyCodeLine{671   \};}
\DoxyCodeLine{672 }
\DoxyCodeLine{673   std::vector<size\_t>                         succs\_ct(n\_vtx);}
\DoxyCodeLine{674   std::vector<score\_t>                        delta(n\_vtx);}
\DoxyCodeLine{675   std::vector<Spinlock>                       vector\_spinlocks(n\_vtx);}
\DoxyCodeLine{676   std::vector<nodeinfo>                       vertices(n\_vtx);}
\DoxyCodeLine{677   std::atomic<size\_t>                         num\_buckets = 10;}
\DoxyCodeLine{678   Spinlock                                    b\_lock;}
\DoxyCodeLine{679   \textcolor{keywordtype}{bool}                                        parallel;}
\DoxyCodeLine{680   std::function<void(vertex\_id\_type, \textcolor{keywordtype}{size\_t})> innerfunc = [\&](vertex\_id\_type s, \textcolor{keywordtype}{size\_t} num\_threads) \{}
\DoxyCodeLine{681     std::function<void(\textcolor{keywordtype}{size\_t}, \textcolor{keywordtype}{size\_t})> reset([\&](\textcolor{keywordtype}{size\_t} begin, \textcolor{keywordtype}{size\_t} end) \{}
\DoxyCodeLine{682       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} v = begin; v < end; ++v) \{}
\DoxyCodeLine{683         vertices[v].l           = std::numeric\_limits<std::uint32\_t>::max();}
\DoxyCodeLine{684         vertices[v].path\_counts = 0;}
\DoxyCodeLine{685         vertices[v].preds.clear();}
\DoxyCodeLine{686         vertices[v].succs.clear();}
\DoxyCodeLine{687         delta[v]    = 0;}
\DoxyCodeLine{688         succs\_ct[v] = 0;}
\DoxyCodeLine{689         vector\_spinlocks[v].unlock();}
\DoxyCodeLine{690       \}}
\DoxyCodeLine{691     \});}
\DoxyCodeLine{692 }
\DoxyCodeLine{693     std::vector<std::thread> vecOfThreads;}
\DoxyCodeLine{694 }
\DoxyCodeLine{695     \textcolor{keywordflow}{if} (num\_threads != 1) \{}
\DoxyCodeLine{696       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} thread = 0; thread < num\_threads; ++thread) \{}
\DoxyCodeLine{697         vecOfThreads.push\_back(}
\DoxyCodeLine{698             std::thread(reset, n\_vtx / num\_threads * thread, (thread == num\_threads -\/ 1) ? n\_vtx : n\_vtx / num\_threads * (thread + 1)));}
\DoxyCodeLine{699       \}}
\DoxyCodeLine{700       \textcolor{keywordflow}{for} (std::thread\& th : vecOfThreads) \{}
\DoxyCodeLine{701         \textcolor{keywordflow}{if} (th.joinable()) th.join();}
\DoxyCodeLine{702       \}}
\DoxyCodeLine{703     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{704       reset(0, n\_vtx);}
\DoxyCodeLine{705     \}}
\DoxyCodeLine{706 }
\DoxyCodeLine{707     vertices[s].l           = 0;}
\DoxyCodeLine{708     vertices[s].path\_counts = 1;}
\DoxyCodeLine{709 }
\DoxyCodeLine{710     \textcolor{keywordflow}{if} (asyncv1) \{}
\DoxyCodeLine{711       tbb::concurrent\_vector<tbb::concurrent\_vector<std::pair<vertex\_id\_type, vertex\_id\_type>>> buckets(num\_buckets);}
\DoxyCodeLine{712       tbb::concurrent\_vector<std::pair<vertex\_id\_type, vertex\_id\_type>>                         currentlevel;}
\DoxyCodeLine{713       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = A[s].begin(); it != A[s].end(); ++it) \{}
\DoxyCodeLine{714         buckets[0].push\_back(std::pair(s, std::get<0>(*it)));}
\DoxyCodeLine{715       \}}
\DoxyCodeLine{716 }
\DoxyCodeLine{717       \textcolor{keyword}{auto} async1 = [\&](\textcolor{keyword}{auto}\& workpair) \{}
\DoxyCodeLine{718         \textcolor{keyword}{auto} u = std::get<0>(workpair);}
\DoxyCodeLine{719         \textcolor{keyword}{auto} v = std::get<1>(workpair);}
\DoxyCodeLine{720         \textcolor{comment}{// std::cout << u << "{} "{} << v << std::endl;}}
\DoxyCodeLine{721         \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{722           \textcolor{keywordflow}{if} (u < v) \{}
\DoxyCodeLine{723             vector\_spinlocks[u].lock();}
\DoxyCodeLine{724             vector\_spinlocks[v].lock();}
\DoxyCodeLine{725           \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{726             vector\_spinlocks[v].lock();}
\DoxyCodeLine{727             vector\_spinlocks[u].lock();}
\DoxyCodeLine{728           \}}
\DoxyCodeLine{729         \}}
\DoxyCodeLine{730 }
\DoxyCodeLine{731         nodeinfo* udata = \&vertices[u];}
\DoxyCodeLine{732         nodeinfo* vdata = \&vertices[v];}
\DoxyCodeLine{733         \textcolor{comment}{// lock u,v}}
\DoxyCodeLine{734         \textcolor{keywordflow}{if} (g\_cn(u, v, udata, vdata)) \{}
\DoxyCodeLine{735           apply\_cn(u, v, udata, vdata);}
\DoxyCodeLine{736           \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{737             vector\_spinlocks[v].unlock();}
\DoxyCodeLine{738             vector\_spinlocks[u].unlock();}
\DoxyCodeLine{739           \}}
\DoxyCodeLine{740         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_sp(u, v, udata, vdata)) \{}
\DoxyCodeLine{741           \textcolor{keyword}{auto} temp\_preds = vdata-\/>preds;}
\DoxyCodeLine{742 }
\DoxyCodeLine{743           apply\_spfu(u, v, udata, vdata);}
\DoxyCodeLine{744           \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{745           \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{746             vector\_spinlocks[u].unlock();}
\DoxyCodeLine{747             vector\_spinlocks[v].unlock();}
\DoxyCodeLine{748           \}}
\DoxyCodeLine{749           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner =A[v].begin(); inner !=A[v].end(); ++inner) \{}
\DoxyCodeLine{750             \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{751             \textcolor{comment}{// if (priority > maxbucket) \{}}
\DoxyCodeLine{752             \textcolor{keywordflow}{if} (priority + 1 > num\_buckets) \{}
\DoxyCodeLine{753               \textcolor{keywordflow}{if} (parallel) b\_lock.lock();}
\DoxyCodeLine{754               buckets.grow\_to\_at\_least(priority + 1);}
\DoxyCodeLine{755               num\_buckets = priority + 1;}
\DoxyCodeLine{756               \textcolor{keywordflow}{if} (parallel) b\_lock.unlock();}
\DoxyCodeLine{757             \}}
\DoxyCodeLine{758             \textcolor{comment}{// maxbucket = priority;}}
\DoxyCodeLine{759             \textcolor{comment}{//\}}}
\DoxyCodeLine{760             buckets[priority].push\_back(std::pair(v, std::get<0>(*inner)));}
\DoxyCodeLine{761           \}}
\DoxyCodeLine{762 }
\DoxyCodeLine{763           \textcolor{comment}{// Should this be all incoming edges?}}
\DoxyCodeLine{764           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} iter = temp\_preds.begin(); iter != temp\_preds.end(); ++iter) \{}
\DoxyCodeLine{765             \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{766             \textcolor{comment}{// if (priority > maxbucket) \{}}
\DoxyCodeLine{767             \textcolor{keywordflow}{if} (priority + 1 > num\_buckets) \{}
\DoxyCodeLine{768               \textcolor{keywordflow}{if} (parallel) b\_lock.lock();}
\DoxyCodeLine{769               buckets.grow\_to\_at\_least(priority + 1);}
\DoxyCodeLine{770               num\_buckets = priority + 1;}
\DoxyCodeLine{771               \textcolor{keywordflow}{if} (parallel) b\_lock.unlock();}
\DoxyCodeLine{772             \}}
\DoxyCodeLine{773             \textcolor{comment}{// maxbucket = priority;}}
\DoxyCodeLine{774             \textcolor{comment}{//\}}}
\DoxyCodeLine{775             buckets[priority].push\_back(std::pair(*iter, v));}
\DoxyCodeLine{776           \}}
\DoxyCodeLine{777 }
\DoxyCodeLine{778         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_fu(u, v, udata, vdata)) \{}
\DoxyCodeLine{779           apply\_fu(u, v, udata, vdata);}
\DoxyCodeLine{780           \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{781           \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{782             vector\_spinlocks[u].unlock();}
\DoxyCodeLine{783             vector\_spinlocks[v].unlock();}
\DoxyCodeLine{784           \}}
\DoxyCodeLine{785           \textcolor{comment}{// should this only be succ of v?}}
\DoxyCodeLine{786           \textcolor{keywordflow}{if} (vdata-\/>succs.begin() != vdata-\/>succs.end()) \{}
\DoxyCodeLine{787             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner =A[v].begin(); inner !=A[v].end(); ++inner) \{}
\DoxyCodeLine{788               \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{789               \textcolor{comment}{// if (priority > maxbucket) \{}}
\DoxyCodeLine{790               \textcolor{keywordflow}{if} (priority + 1 > num\_buckets) \{}
\DoxyCodeLine{791                 \textcolor{keywordflow}{if} (parallel) b\_lock.lock();}
\DoxyCodeLine{792                 buckets.grow\_to\_at\_least(priority + 1);}
\DoxyCodeLine{793                 num\_buckets = priority + 1;}
\DoxyCodeLine{794                 \textcolor{keywordflow}{if} (parallel) b\_lock.unlock();}
\DoxyCodeLine{795               \}}
\DoxyCodeLine{796               \textcolor{comment}{// maxbucket = priority;}}
\DoxyCodeLine{797               \textcolor{comment}{//\}}}
\DoxyCodeLine{798               buckets[priority].push\_back(std::pair(v, std::get<0>(*inner)));}
\DoxyCodeLine{799             \}}
\DoxyCodeLine{800           \}}
\DoxyCodeLine{801         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_us(u, v, udata, vdata)) \{}
\DoxyCodeLine{802           apply\_us(u, v, udata, vdata);}
\DoxyCodeLine{803           \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{804           \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{805             vector\_spinlocks[u].unlock();}
\DoxyCodeLine{806             vector\_spinlocks[v].unlock();}
\DoxyCodeLine{807           \}}
\DoxyCodeLine{808           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vdata-\/>succs.begin(); it != vdata-\/>succs.end(); ++it) \{}
\DoxyCodeLine{809             \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{810             \textcolor{comment}{// if (priority > maxbucket) \{}}
\DoxyCodeLine{811             \textcolor{keywordflow}{if} (priority + 1 > num\_buckets) \{}
\DoxyCodeLine{812               \textcolor{keywordflow}{if} (parallel) b\_lock.lock();}
\DoxyCodeLine{813               buckets.grow\_to\_at\_least(priority + 1);}
\DoxyCodeLine{814               num\_buckets = priority + 1;}
\DoxyCodeLine{815               \textcolor{keywordflow}{if} (parallel) b\_lock.unlock();}
\DoxyCodeLine{816             \}}
\DoxyCodeLine{817             \textcolor{comment}{// maxbucket = priority;}}
\DoxyCodeLine{818             \textcolor{comment}{//\}}}
\DoxyCodeLine{819             buckets[priority].push\_back(std::pair(v, *it));}
\DoxyCodeLine{820           \}}
\DoxyCodeLine{821 }
\DoxyCodeLine{822         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{823           \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{824           vector\_spinlocks[v].unlock();}
\DoxyCodeLine{825           vector\_spinlocks[u].unlock();}
\DoxyCodeLine{826         \}}
\DoxyCodeLine{827         \textcolor{keywordflow}{return};}
\DoxyCodeLine{828       \};}
\DoxyCodeLine{829 }
\DoxyCodeLine{830       \textcolor{keywordtype}{size\_t} top\_level = 0;}
\DoxyCodeLine{831       \textcolor{keywordflow}{while} (top\_level < buckets.size()) \{}
\DoxyCodeLine{832         currentlevel.resize(0);}
\DoxyCodeLine{833         std::swap(currentlevel, buckets[top\_level]);}
\DoxyCodeLine{834         \textcolor{keywordflow}{if} (num\_threads != 1 \&\& currentlevel.size() > par\_thresh) \{}
\DoxyCodeLine{835           parallel = \textcolor{keyword}{true};}
\DoxyCodeLine{836           std::for\_each(std::execution::par, currentlevel.begin(), currentlevel.end(), async1);}
\DoxyCodeLine{837         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{838           parallel = \textcolor{keyword}{false};}
\DoxyCodeLine{839           std::for\_each(currentlevel.begin(), currentlevel.end(), async1);}
\DoxyCodeLine{840         \}}
\DoxyCodeLine{841         \textcolor{keywordflow}{while} (buckets[top\_level].empty() \&\& top\_level < buckets.size()) \{}
\DoxyCodeLine{842           top\_level++;}
\DoxyCodeLine{843         \}}
\DoxyCodeLine{844       \}}
\DoxyCodeLine{845 }
\DoxyCodeLine{846     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{847       tbb::concurrent\_vector<tbb::concurrent\_vector<vertex\_id\_type>> buckets(num\_buckets);}
\DoxyCodeLine{848       tbb::concurrent\_vector<vertex\_id\_type>                         currentlevel;}
\DoxyCodeLine{849       buckets[0].push\_back(s);}
\DoxyCodeLine{850       \textcolor{keyword}{auto} async2 = [\&](\textcolor{keyword}{auto}\& u) \{}
\DoxyCodeLine{851         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner = A[u].begin(); inner != A[u].end(); ++inner) \{}
\DoxyCodeLine{852           \textcolor{keyword}{auto} v = std::get<0>(*inner);}
\DoxyCodeLine{853           \textcolor{keywordflow}{if} (u == v) \{}
\DoxyCodeLine{854             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{855           \}}
\DoxyCodeLine{856 }
\DoxyCodeLine{857           \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{858             \textcolor{keywordflow}{if} (u < v) \{}
\DoxyCodeLine{859               vector\_spinlocks[u].lock();}
\DoxyCodeLine{860               vector\_spinlocks[v].lock();}
\DoxyCodeLine{861             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{862               vector\_spinlocks[v].lock();}
\DoxyCodeLine{863               vector\_spinlocks[u].lock();}
\DoxyCodeLine{864             \}}
\DoxyCodeLine{865           \}}
\DoxyCodeLine{866 }
\DoxyCodeLine{867           nodeinfo* udata = \&vertices[u];}
\DoxyCodeLine{868           nodeinfo* vdata = \&vertices[v];}
\DoxyCodeLine{869           \textcolor{comment}{// lock u,v}}
\DoxyCodeLine{870           \textcolor{keywordflow}{if} (g\_sp(u, v, udata, vdata)) \{}
\DoxyCodeLine{871             \textcolor{keyword}{auto} temp\_preds = vdata-\/>preds;}
\DoxyCodeLine{872             apply\_spfu(u, v, udata, vdata);}
\DoxyCodeLine{873             \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{874             \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{875               vector\_spinlocks[u].unlock();}
\DoxyCodeLine{876               vector\_spinlocks[v].unlock();}
\DoxyCodeLine{877             \}}
\DoxyCodeLine{878             \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{879             \textcolor{comment}{// if (priority > maxbucket) \{}}
\DoxyCodeLine{880             \textcolor{keywordflow}{if} (priority + 1 > num\_buckets) \{}
\DoxyCodeLine{881               \textcolor{keywordflow}{if} (parallel) b\_lock.lock();}
\DoxyCodeLine{882               buckets.grow\_to\_at\_least(priority + 1);}
\DoxyCodeLine{883               num\_buckets = priority + 1;}
\DoxyCodeLine{884               \textcolor{keywordflow}{if} (parallel) b\_lock.unlock();}
\DoxyCodeLine{885             \}}
\DoxyCodeLine{886             \textcolor{comment}{// maxbucket = priority;}}
\DoxyCodeLine{887             \textcolor{comment}{//\}}}
\DoxyCodeLine{888             buckets[priority].push\_back(v);}
\DoxyCodeLine{889 }
\DoxyCodeLine{890             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} inner2 = temp\_preds.begin(); inner2 != temp\_preds.end(); ++inner2) \{}
\DoxyCodeLine{891               \textcolor{keyword}{auto} w = *inner2;}
\DoxyCodeLine{892 }
\DoxyCodeLine{893               \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{894                 \textcolor{keywordflow}{if} (v == w) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{895                 \textcolor{keywordflow}{if} (v < w) \{}
\DoxyCodeLine{896                   vector\_spinlocks[v].lock();}
\DoxyCodeLine{897                   vector\_spinlocks[w].lock();}
\DoxyCodeLine{898                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{899                   vector\_spinlocks[w].lock();}
\DoxyCodeLine{900                   vector\_spinlocks[v].lock();}
\DoxyCodeLine{901                 \}}
\DoxyCodeLine{902               \}}
\DoxyCodeLine{903 }
\DoxyCodeLine{904               nodeinfo* wdata = \&vertices[w];}
\DoxyCodeLine{905 }
\DoxyCodeLine{906               \textcolor{keywordflow}{if} (g\_cn(w, v, wdata, vdata)) \{}
\DoxyCodeLine{907                 apply\_cn(w, v, wdata, vdata);}
\DoxyCodeLine{908               \}}
\DoxyCodeLine{909               \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{910                 vector\_spinlocks[v].unlock();}
\DoxyCodeLine{911                 vector\_spinlocks[w].unlock();}
\DoxyCodeLine{912               \}}
\DoxyCodeLine{913             \}}
\DoxyCodeLine{914           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_fu(u, v, udata, vdata)) \{}
\DoxyCodeLine{915             apply\_fu(u, v, udata, vdata);}
\DoxyCodeLine{916             \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{917             \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{918               vector\_spinlocks[u].unlock();}
\DoxyCodeLine{919               vector\_spinlocks[v].unlock();}
\DoxyCodeLine{920             \}}
\DoxyCodeLine{921             \textcolor{comment}{// should this only be succ of v?}}
\DoxyCodeLine{922             \textcolor{keywordflow}{if} (vdata-\/>succs.begin() != vdata-\/>succs.end()) \{}
\DoxyCodeLine{923               \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{924               \textcolor{comment}{// if (priority > maxbucket) \{}}
\DoxyCodeLine{925               \textcolor{keywordflow}{if} (priority + 1 > num\_buckets) \{}
\DoxyCodeLine{926                 \textcolor{keywordflow}{if} (parallel) b\_lock.lock();}
\DoxyCodeLine{927                 buckets.grow\_to\_at\_least(priority + 1);}
\DoxyCodeLine{928                 num\_buckets = priority + 1;}
\DoxyCodeLine{929                 \textcolor{keywordflow}{if} (parallel) b\_lock.unlock();}
\DoxyCodeLine{930               \}}
\DoxyCodeLine{931               \textcolor{comment}{// maxbucket = priority;}}
\DoxyCodeLine{932               \textcolor{comment}{//\}}}
\DoxyCodeLine{933               buckets[priority].push\_back(v);}
\DoxyCodeLine{934             \}}
\DoxyCodeLine{935           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (g\_us(u, v, udata, vdata)) \{}
\DoxyCodeLine{936             apply\_us(u, v, udata, vdata);}
\DoxyCodeLine{937             \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{938             \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{939               vector\_spinlocks[u].unlock();}
\DoxyCodeLine{940               vector\_spinlocks[v].unlock();}
\DoxyCodeLine{941             \}}
\DoxyCodeLine{942             \textcolor{keywordflow}{if} (vdata-\/>succs.begin() != vdata-\/>succs.end()) \{}
\DoxyCodeLine{943               \textcolor{keywordtype}{size\_t} priority = (vdata-\/>l + 1) / DELTA;}
\DoxyCodeLine{944               \textcolor{comment}{// if (priority > maxbucket) \{}}
\DoxyCodeLine{945               \textcolor{keywordflow}{if} (priority + 1 > num\_buckets) \{}
\DoxyCodeLine{946                 \textcolor{keywordflow}{if} (parallel) b\_lock.lock();}
\DoxyCodeLine{947                 buckets.grow\_to\_at\_least(priority + 1);}
\DoxyCodeLine{948                 num\_buckets = priority + 1;}
\DoxyCodeLine{949                 \textcolor{keywordflow}{if} (parallel) b\_lock.unlock();}
\DoxyCodeLine{950               \}}
\DoxyCodeLine{951               \textcolor{comment}{// maxbucket = priority;}}
\DoxyCodeLine{952               \textcolor{comment}{//\}}}
\DoxyCodeLine{953               buckets[priority].push\_back(v);}
\DoxyCodeLine{954             \}}
\DoxyCodeLine{955           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parallel) \{}
\DoxyCodeLine{956             \textcolor{comment}{// unlock u,v}}
\DoxyCodeLine{957             vector\_spinlocks[v].unlock();}
\DoxyCodeLine{958             vector\_spinlocks[u].unlock();}
\DoxyCodeLine{959           \}}
\DoxyCodeLine{960         \}}
\DoxyCodeLine{961         \textcolor{keywordflow}{return};}
\DoxyCodeLine{962       \};}
\DoxyCodeLine{963 }
\DoxyCodeLine{964       \textcolor{keywordtype}{size\_t} top\_level = 0;}
\DoxyCodeLine{965       \textcolor{keywordflow}{while} (top\_level < buckets.size()) \{}
\DoxyCodeLine{966         currentlevel.resize(0);}
\DoxyCodeLine{967         std::swap(currentlevel, buckets[top\_level]);}
\DoxyCodeLine{968         \textcolor{keywordflow}{if} (num\_threads != 1 \&\& currentlevel.size() > par\_thresh) \{}
\DoxyCodeLine{969           parallel = \textcolor{keyword}{true};}
\DoxyCodeLine{970           std::for\_each(std::execution::par, currentlevel.begin(), currentlevel.end(), async2);}
\DoxyCodeLine{971         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{972           parallel = \textcolor{keyword}{false};}
\DoxyCodeLine{973           std::for\_each(currentlevel.begin(), currentlevel.end(), async2);}
\DoxyCodeLine{974         \}}
\DoxyCodeLine{975         \textcolor{keywordflow}{while} (buckets[top\_level].empty() \&\& top\_level < buckets.size()) \{}
\DoxyCodeLine{976           top\_level++;}
\DoxyCodeLine{977         \}}
\DoxyCodeLine{978       \}}
\DoxyCodeLine{979     \}}
\DoxyCodeLine{980     std::atomic<size\_t>                   workest = 0;}
\DoxyCodeLine{981     tbb::concurrent\_queue<vertex\_id\_type> myqueue2;}
\DoxyCodeLine{982 }
\DoxyCodeLine{983     \textcolor{keywordflow}{if} (num\_threads == 1) \{}
\DoxyCodeLine{984       \textcolor{keywordflow}{for} (vertex\_id\_type v = 0; v < n\_vtx; ++v) \{}
\DoxyCodeLine{985         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vertices[v].succs.begin(); it != vertices[v].succs.end(); ++it) \{}
\DoxyCodeLine{986           succs\_ct[v]++;}
\DoxyCodeLine{987         \}}
\DoxyCodeLine{988         vertices[v].succs.clear();}
\DoxyCodeLine{989         \textcolor{keywordflow}{if} (succs\_ct[v] == 0) \{}
\DoxyCodeLine{990           myqueue2.push(v);}
\DoxyCodeLine{991           workest++;}
\DoxyCodeLine{992         \}}
\DoxyCodeLine{993       \}}
\DoxyCodeLine{994     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{995       std::function<void(\textcolor{keywordtype}{size\_t}, \textcolor{keywordtype}{size\_t})> populate\_queue = [\&](\textcolor{keywordtype}{size\_t} begin, \textcolor{keywordtype}{size\_t} end) \{}
\DoxyCodeLine{996         \textcolor{keywordflow}{for} (vertex\_id\_type v = begin; v < end; ++v) \{}
\DoxyCodeLine{997           succs\_ct[v] = 0;}
\DoxyCodeLine{998           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vertices[v].succs.begin(); it != vertices[v].succs.end(); ++it) \{}
\DoxyCodeLine{999             succs\_ct[v]++;}
\DoxyCodeLine{1000           \}}
\DoxyCodeLine{1001           \textcolor{keywordflow}{if} (succs\_ct[v] == 0) \{}
\DoxyCodeLine{1002             myqueue2.push(v);}
\DoxyCodeLine{1003           \}}
\DoxyCodeLine{1004         \}}
\DoxyCodeLine{1005       \};}
\DoxyCodeLine{1006       vecOfThreads.clear();}
\DoxyCodeLine{1007       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} thread = 0; thread < num\_threads; ++thread) \{}
\DoxyCodeLine{1008         vecOfThreads.push\_back(std::thread(populate\_queue, n\_vtx / num\_threads * thread,}
\DoxyCodeLine{1009                                            (thread == num\_threads -\/ 1) ? n\_vtx : n\_vtx / num\_threads * (thread + 1)));}
\DoxyCodeLine{1010       \}}
\DoxyCodeLine{1011       \textcolor{keywordflow}{for} (std::thread\& th : vecOfThreads) \{}
\DoxyCodeLine{1012         \textcolor{keywordflow}{if} (th.joinable()) th.join();}
\DoxyCodeLine{1013       \}}
\DoxyCodeLine{1014     \}}
\DoxyCodeLine{1015 }
\DoxyCodeLine{1016     std::function<void(\textcolor{keywordtype}{bool}, \textcolor{keywordtype}{bool})> backprocess = [\&](\textcolor{keywordtype}{bool} parallel, \textcolor{keywordtype}{bool} \textcolor{keyword}{final}) \{}
\DoxyCodeLine{1017       std::queue<vertex\_id\_type> buffer;}
\DoxyCodeLine{1018       vertex\_id\_type             workitem;}
\DoxyCodeLine{1019       \textcolor{keywordflow}{while} (buffer.size() > 0 || (parallel) || (!parallel \&\& (workest < par\_thresh || num\_threads == 1)) || \textcolor{keyword}{final}) \{}
\DoxyCodeLine{1020         \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};}
\DoxyCodeLine{1021         \textcolor{keywordflow}{if} (buffer.size() > 0) \{}
\DoxyCodeLine{1022           found    = \textcolor{keyword}{true};}
\DoxyCodeLine{1023           workitem = buffer.front();}
\DoxyCodeLine{1024           buffer.pop();}
\DoxyCodeLine{1025         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1026           found          = myqueue2.try\_pop(workitem);}
\DoxyCodeLine{1027           \textcolor{keywordtype}{size\_t} counter = 0;}
\DoxyCodeLine{1028           \textcolor{keywordflow}{while} (!found \&\& parallel \&\& counter < 10) \{}
\DoxyCodeLine{1029             found = myqueue2.try\_pop(workitem);}
\DoxyCodeLine{1030             counter++;}
\DoxyCodeLine{1031           \}}
\DoxyCodeLine{1032         \}}
\DoxyCodeLine{1033         \textcolor{keywordflow}{if} (!found) \textcolor{keywordflow}{break};}
\DoxyCodeLine{1034 }
\DoxyCodeLine{1035         \textcolor{keyword}{auto}    v    = workitem;}
\DoxyCodeLine{1036         score\_t temp = (1 + delta[v]) / \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(vertices[v].path\_counts);}
\DoxyCodeLine{1037         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = vertices[v].preds.begin(); it != vertices[v].preds.end(); ++it) \{}
\DoxyCodeLine{1038           \textcolor{keyword}{auto} u = *it;}
\DoxyCodeLine{1039           \textcolor{keywordflow}{if} (parallel) vector\_spinlocks[u].lock();}
\DoxyCodeLine{1040 }
\DoxyCodeLine{1041           delta[u] = delta[u] + temp;}
\DoxyCodeLine{1042           succs\_ct[u]-\/-\/;}
\DoxyCodeLine{1043 }
\DoxyCodeLine{1044           \textcolor{keywordflow}{if} (succs\_ct[u] == 0 \&\& u != s) \{}
\DoxyCodeLine{1045             delta[u] *= \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(vertices[u].path\_counts);}
\DoxyCodeLine{1046             \textcolor{keywordflow}{if} (buffer.size() < back\_buffersize) \{}
\DoxyCodeLine{1047               buffer.push(u);}
\DoxyCodeLine{1048             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1049               myqueue2.push(u);}
\DoxyCodeLine{1050             \}}
\DoxyCodeLine{1051           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parallel)}
\DoxyCodeLine{1052             vector\_spinlocks[u].unlock();}
\DoxyCodeLine{1053         \}}
\DoxyCodeLine{1054         centrality[v] += delta[v];}
\DoxyCodeLine{1055       \}}
\DoxyCodeLine{1056     \};}
\DoxyCodeLine{1057 }
\DoxyCodeLine{1058     \textcolor{keywordflow}{if} (num\_threads != 1) \{}
\DoxyCodeLine{1059       vecOfThreads.clear();}
\DoxyCodeLine{1060       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} thread = 0; thread < num\_threads; ++thread) \{}
\DoxyCodeLine{1061         vecOfThreads.emplace\_back(std::thread(backprocess, \textcolor{keyword}{true}, \textcolor{keyword}{false}));}
\DoxyCodeLine{1062       \}}
\DoxyCodeLine{1063       \textcolor{keywordflow}{for} (std::thread\& th : vecOfThreads) \{}
\DoxyCodeLine{1064         \textcolor{keywordflow}{if} (th.joinable()) th.join();}
\DoxyCodeLine{1065       \}}
\DoxyCodeLine{1066     \}}
\DoxyCodeLine{1067     backprocess(\textcolor{keyword}{false}, \textcolor{keyword}{true});}
\DoxyCodeLine{1068 }
\DoxyCodeLine{1069     \textcolor{keywordflow}{return};}
\DoxyCodeLine{1070   \};}
\DoxyCodeLine{1071 }
\DoxyCodeLine{1072   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} y : sources) \{}
\DoxyCodeLine{1073     innerfunc(y, num\_threads);}
\DoxyCodeLine{1074   \}}
\DoxyCodeLine{1075 }
\DoxyCodeLine{1076   \textcolor{keywordflow}{if} (num\_threads == 1) \{}
\DoxyCodeLine{1077     score\_t largest = 0;}
\DoxyCodeLine{1078     \textcolor{keywordflow}{for} (vertex\_id\_type v = 0; v < n\_vtx; ++v) \{}
\DoxyCodeLine{1079       largest = std::max(centrality[v], largest);}
\DoxyCodeLine{1080     \}}
\DoxyCodeLine{1081     \textcolor{keywordflow}{for} (vertex\_id\_type v = 0; v < n\_vtx; ++v) \{}
\DoxyCodeLine{1082       centrality[v] = centrality[v] / largest;}
\DoxyCodeLine{1083     \}}
\DoxyCodeLine{1084   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1085     std::vector<std::future<score\_t>> futures(num\_threads);}
\DoxyCodeLine{1086     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} thread = 0; thread < num\_threads; ++thread) \{}
\DoxyCodeLine{1087       \textcolor{keywordtype}{size\_t} begin    = (n\_vtx / num\_threads) * thread;}
\DoxyCodeLine{1088       \textcolor{keywordtype}{size\_t} end      = (thread == num\_threads -\/ 1) ? n\_vtx : n\_vtx / num\_threads * (thread + 1);}
\DoxyCodeLine{1089       futures[thread] = std::async(}
\DoxyCodeLine{1090           std::launch::async,}
\DoxyCodeLine{1091           [\&](\textcolor{keywordtype}{size\_t} thread, \textcolor{keywordtype}{size\_t} begin, \textcolor{keywordtype}{size\_t} end) \{}
\DoxyCodeLine{1092             score\_t temp\_largest = 0;}
\DoxyCodeLine{1093             \textcolor{keywordflow}{for} (vertex\_id\_type v = begin; v < end; ++v) \{}
\DoxyCodeLine{1094               temp\_largest = std::max(centrality[v], temp\_largest);}
\DoxyCodeLine{1095             \}}
\DoxyCodeLine{1096             \textcolor{keywordflow}{return} temp\_largest;}
\DoxyCodeLine{1097           \},}
\DoxyCodeLine{1098           thread, begin, end);}
\DoxyCodeLine{1099     \}}
\DoxyCodeLine{1100     score\_t largest = 0;}
\DoxyCodeLine{1101     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < num\_threads; ++i) \{}
\DoxyCodeLine{1102       largest = std::max(futures[i].get(), largest);}
\DoxyCodeLine{1103     \}}
\DoxyCodeLine{1104     std::vector<std::future<void>> futures2(num\_threads);}
\DoxyCodeLine{1105     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} thread = 0; thread < num\_threads; ++thread) \{}
\DoxyCodeLine{1106       \textcolor{keywordtype}{size\_t} begin     = n\_vtx / num\_threads * thread;}
\DoxyCodeLine{1107       \textcolor{keywordtype}{size\_t} end       = (thread == num\_threads -\/ 1) ? n\_vtx : n\_vtx / num\_threads * (thread + 1);}
\DoxyCodeLine{1108       futures2[thread] = std::async(}
\DoxyCodeLine{1109           std::launch::async,}
\DoxyCodeLine{1110           [\&](\textcolor{keywordtype}{size\_t} thread, \textcolor{keywordtype}{size\_t} begin, \textcolor{keywordtype}{size\_t} end) \{}
\DoxyCodeLine{1111             \textcolor{keywordflow}{for} (vertex\_id\_type v = begin; v < end; ++v) \{}
\DoxyCodeLine{1112               centrality[v] = centrality[v] / largest;}
\DoxyCodeLine{1113             \}}
\DoxyCodeLine{1114             \textcolor{keywordflow}{return};}
\DoxyCodeLine{1115           \},}
\DoxyCodeLine{1116           thread, begin, end);}
\DoxyCodeLine{1117     \}}
\DoxyCodeLine{1118     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < num\_threads; ++i) \{}
\DoxyCodeLine{1119       futures2[i].get();}
\DoxyCodeLine{1120     \}}
\DoxyCodeLine{1121   \}}
\DoxyCodeLine{1122   \textcolor{keywordflow}{return} centrality;}
\DoxyCodeLine{1123 \}}
\DoxyCodeLine{1124 }
\DoxyCodeLine{1125 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{1126 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Graph, \textcolor{keyword}{typename} Vector1, \textcolor{keyword}{typename} BitMap1, \textcolor{keyword}{typename} Queue1, \textcolor{keyword}{typename} Queue2>}
\DoxyCodeLine{1127 \textcolor{keywordtype}{void} PBFS(\textcolor{keyword}{const} Graph \&graph, vertex\_id\_type root, Vector1 \&path\_counts,}
\DoxyCodeLine{1128     BitMap1 \&succ, Queue1 \&depth\_index, Queue2 \&q1, Queue2 \&q2) \{}
\DoxyCodeLine{1129 }
\DoxyCodeLine{1130   std::vector<vertex\_id\_type> level(graph.num\_nodes(), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{1131 }
\DoxyCodeLine{1132   q1[0].push\_back(root);}
\DoxyCodeLine{1133   level[root] = 0;}
\DoxyCodeLine{1134   path\_counts[root] = 1;}
\DoxyCodeLine{1135 }
\DoxyCodeLine{1136   queue.push\_back(root);}
\DoxyCodeLine{1137   depth\_index.push\_back(queue.begin());}
\DoxyCodeLine{1138   queue.slide\_window();}
\DoxyCodeLine{1139 }
\DoxyCodeLine{1140   \textcolor{keyword}{auto} g\_out\_start = graph.out\_neigh(0).begin();}
\DoxyCodeLine{1141 }
\DoxyCodeLine{1142   \{}
\DoxyCodeLine{1143     vertex\_id\_type depth = 0;}
\DoxyCodeLine{1144     QueueBuffer<vertex\_id\_type> lqueue(queue);}
\DoxyCodeLine{1145 }
\DoxyCodeLine{1146     \textcolor{keywordflow}{while} (!queue.empty()) \{}
\DoxyCodeLine{1147 }
\DoxyCodeLine{1148       depth\_index.push\_back(queue.begin());}
\DoxyCodeLine{1149       ++depth;}
\DoxyCodeLine{1150 }
\DoxyCodeLine{1151       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} q\_iter = queue.begin(); q\_iter < queue.end(); q\_iter++) \{}
\DoxyCodeLine{1152         \textcolor{keyword}{auto} u = *q\_iter;}
\DoxyCodeLine{1153         vertex\_id\_type neg\_one = -\/1;}
\DoxyCodeLine{1154         \textcolor{keywordflow}{for} (vertex\_id\_type \&v : graph.out\_neigh(u)) \{}
\DoxyCodeLine{1155           \textcolor{keywordflow}{if} ((level[v] == -\/1) \&\&}
\DoxyCodeLine{1156               level[v].compare\_exchange\_strong, neg\_one, depth)) \{}
\DoxyCodeLine{1157             lqueue.push\_back(v);}
\DoxyCodeLine{1158           \}}
\DoxyCodeLine{1159           \textcolor{keywordflow}{if} (level[v] == depth) \{}
\DoxyCodeLine{1160             succ.store(\&v -\/ g\_out\_start);}
\DoxyCodeLine{1161             path\_counts[v].fetch\_add(path\_counts[u]);}
\DoxyCodeLine{1162           \}}
\DoxyCodeLine{1163         \}}
\DoxyCodeLine{1164       \}}
\DoxyCodeLine{1165       lqueue.flush();}
\DoxyCodeLine{1166       queue.slide\_window();}
\DoxyCodeLine{1167     \}}
\DoxyCodeLine{1168   \}}
\DoxyCodeLine{1169 }
\DoxyCodeLine{1170   depth\_index.push\_back(queue.begin());}
\DoxyCodeLine{1171 \}}
\DoxyCodeLine{1172 }
\DoxyCodeLine{1173 }
\DoxyCodeLine{1174 std::vector<score\_t> Brandes(\textcolor{keyword}{const} Graph \&g, \textcolor{keyword}{const} std::vector<vertex\_id\_type> sources) \{}
\DoxyCodeLine{1175 }
\DoxyCodeLine{1176   std::vector<score\_t> scores(g.num\_nodes(), 0);}
\DoxyCodeLine{1177   std::vector<score\_t> path\_counts(g.num\_nodes());}
\DoxyCodeLine{1178   std::vector<std::atomic<bool>> succ(g.num\_edges\_directed());}
\DoxyCodeLine{1179 }
\DoxyCodeLine{1180   std::vector<SlidingQueue<vertex\_id\_type>::iterator> depth\_index;}
\DoxyCodeLine{1181   SlidingQueue<vertex\_id\_type> queue(g.num\_nodes());}
\DoxyCodeLine{1182 }
\DoxyCodeLine{1183 }
\DoxyCodeLine{1184   \textcolor{keyword}{const} vertex\_id\_type* g\_out\_start = g.out\_neigh(0).begin();}
\DoxyCodeLine{1185 }
\DoxyCodeLine{1186 }
\DoxyCodeLine{1187   \textcolor{keywordflow}{for} (vertex\_id\_type iter=0; iter < num\_iters; iter++) \{}
\DoxyCodeLine{1188     vertex\_id\_type source = sp.PickNext();}
\DoxyCodeLine{1189     cout << \textcolor{stringliteral}{"{}source: "{}} << source << endl;}
\DoxyCodeLine{1190     t.Start();}
\DoxyCodeLine{1191     path\_counts.fill(0);}
\DoxyCodeLine{1192     depth\_index.resize(0);}
\DoxyCodeLine{1193     queue.reset();}
\DoxyCodeLine{1194     succ.reset();}
\DoxyCodeLine{1195 }
\DoxyCodeLine{1196     PBFS(g, source, path\_counts, succ, depth\_index, queue);}
\DoxyCodeLine{1197 }
\DoxyCodeLine{1198     std::vector<score\_t> deltas(g.num\_nodes(), 0);}
\DoxyCodeLine{1199 }
\DoxyCodeLine{1200     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} d = depth\_index.size()-\/2; d >= 0; d-\/-\/) \{}
\DoxyCodeLine{1201 }
\DoxyCodeLine{1202       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = depth\_index[d]; it < depth\_index[d+1]; it++) \{}
\DoxyCodeLine{1203         vertex\_id\_type u = *it;}
\DoxyCodeLine{1204         score\_t delta\_u = 0;}
\DoxyCodeLine{1205         \textcolor{keywordflow}{for} (vertex\_id\_type \&v : g.out\_neigh(u)) \{}
\DoxyCodeLine{1206           \textcolor{keywordflow}{if} (succ.get\_bit(\&v -\/ g\_out\_start)) \{}
\DoxyCodeLine{1207             delta\_u += path\_counts[u] / path\_counts[v] * (1 + deltas[v]);}
\DoxyCodeLine{1208           \}}
\DoxyCodeLine{1209         \}}
\DoxyCodeLine{1210         deltas[u] = delta\_u;}
\DoxyCodeLine{1211         scores[u] += delta\_u;}
\DoxyCodeLine{1212       \}}
\DoxyCodeLine{1213     \}}
\DoxyCodeLine{1214   \}}
\DoxyCodeLine{1215 }
\DoxyCodeLine{1216   score\_t biggest\_score = 0;}
\DoxyCodeLine{1217 }
\DoxyCodeLine{1218   \textcolor{keywordflow}{for} (vertex\_id\_type n=0; n < g.num\_nodes(); n++)}
\DoxyCodeLine{1219     biggest\_score = max(biggest\_score, scores[n]);}
\DoxyCodeLine{1220 }
\DoxyCodeLine{1221   \textcolor{keywordflow}{for} (vertex\_id\_type n=0; n < g.num\_nodes(); n++)}
\DoxyCodeLine{1222     scores[n] = scores[n] / biggest\_score;}
\DoxyCodeLine{1223 }
\DoxyCodeLine{1224   \textcolor{keywordflow}{return} scores;}
\DoxyCodeLine{1225 \}}
\DoxyCodeLine{1226 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1227 }
\DoxyCodeLine{1228 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} score\_t = \textcolor{keywordtype}{float}, \textcolor{keyword}{typename} accum\_t = \textcolor{keywordtype}{size\_t}>}
\DoxyCodeLine{1229 \textcolor{keyword}{auto} bc2\_v0(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type> sources, \textcolor{keywordtype}{bool} normalize = \textcolor{keyword}{true}) \{}
\DoxyCodeLine{1230   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{1231 }
\DoxyCodeLine{1232   vertex\_id\_type       N = num\_vertices(graph);}
\DoxyCodeLine{1233   std::vector<score\_t> bc(N);}
\DoxyCodeLine{1234 }
\DoxyCodeLine{1235   \textcolor{keywordflow}{for} (vertex\_id\_type root : sources) \{}
\DoxyCodeLine{1236 }
\DoxyCodeLine{1237     std::vector<vertex\_id\_type>                depths(N, std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{1238     std::vector<accum\_t>                       path\_counts(N);}
\DoxyCodeLine{1239     std::vector<std::multiset<vertex\_id\_type>> P(N);}
\DoxyCodeLine{1240 }
\DoxyCodeLine{1241     std::vector<std::deque<vertex\_id\_type>> S(2);}
\DoxyCodeLine{1242 }
\DoxyCodeLine{1243     path\_counts[root]    = 1;}
\DoxyCodeLine{1244     depths[root]         = 0;}
\DoxyCodeLine{1245     vertex\_id\_type phase = 0;}
\DoxyCodeLine{1246     vertex\_id\_type count = 1;}
\DoxyCodeLine{1247 }
\DoxyCodeLine{1248     S[phase].push\_front(root);}
\DoxyCodeLine{1249 }
\DoxyCodeLine{1250     \textcolor{keywordflow}{while} (count > 0) \{}
\DoxyCodeLine{1251       count = 0;}
\DoxyCodeLine{1252 }
\DoxyCodeLine{1253       \textcolor{keywordflow}{for} (vertex\_id\_type v : S[phase]) \{}
\DoxyCodeLine{1254         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& elt : graph[v]) \{}
\DoxyCodeLine{1255           \textcolor{keyword}{auto} w = target(graph, elt);}
\DoxyCodeLine{1256 }
\DoxyCodeLine{1257           \textcolor{keywordflow}{if} (depths[w] == std::numeric\_limits<vertex\_id\_type>::max()) \{}
\DoxyCodeLine{1258             S[phase + 1].push\_front(w);}
\DoxyCodeLine{1259             count     = count + 1;}
\DoxyCodeLine{1260             depths[w] = depths[v] + 1;}
\DoxyCodeLine{1261           \}}
\DoxyCodeLine{1262 }
\DoxyCodeLine{1263           \textcolor{keywordflow}{if} (depths[w] == depths[v] + 1) \{}
\DoxyCodeLine{1264             path\_counts[w] = path\_counts[w] + path\_counts[v];}
\DoxyCodeLine{1265             P[w].insert(v);}
\DoxyCodeLine{1266           \}}
\DoxyCodeLine{1267         \}}
\DoxyCodeLine{1268       \}}
\DoxyCodeLine{1269 }
\DoxyCodeLine{1270       phase = phase + 1;}
\DoxyCodeLine{1271       S.push\_back(std::deque<vertex\_id\_type>());}
\DoxyCodeLine{1272     \}}
\DoxyCodeLine{1273 }
\DoxyCodeLine{1274     std::vector<score\_t> delta(N);}
\DoxyCodeLine{1275 }
\DoxyCodeLine{1276     \textcolor{keywordflow}{while} (phase-\/-\/ > 0) \{}
\DoxyCodeLine{1277       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} w : S[phase]) \{}
\DoxyCodeLine{1278         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} v : P[w]) \{}
\DoxyCodeLine{1279           delta[v] += \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(path\_counts[v]) / \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(path\_counts[w]) * (1 + delta[w]);}
\DoxyCodeLine{1280         \}}
\DoxyCodeLine{1281         bc[w] = bc[w] + delta[w];}
\DoxyCodeLine{1282       \}}
\DoxyCodeLine{1283     \}}
\DoxyCodeLine{1284   \}}
\DoxyCodeLine{1285   \textcolor{keywordflow}{if} (normalize) \{}
\DoxyCodeLine{1286     score\_t biggest\_score = *max\_element(bc.begin(), bc.end());}
\DoxyCodeLine{1287     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \&j : bc)}
\DoxyCodeLine{1288       j = j / biggest\_score; }
\DoxyCodeLine{1289   \}}
\DoxyCodeLine{1290 }
\DoxyCodeLine{1291   \textcolor{keywordflow}{return} bc;}
\DoxyCodeLine{1292 \}}
\DoxyCodeLine{1293 }
\DoxyCodeLine{1294 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} score\_t = \textcolor{keywordtype}{float}, \textcolor{keyword}{typename} accum\_t = \textcolor{keywordtype}{size\_t}>}
\DoxyCodeLine{1295 \textcolor{keyword}{auto} bc2\_v1(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type> sources, \textcolor{keywordtype}{bool} normalize = \textcolor{keyword}{true}) \{}
\DoxyCodeLine{1296   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{1297 }
\DoxyCodeLine{1298   \textcolor{keyword}{auto}                 g = graph.begin();}
\DoxyCodeLine{1299   vertex\_id\_type       N = num\_vertices(graph);}
\DoxyCodeLine{1300   std::vector<score\_t> bc(N);}
\DoxyCodeLine{1301 }
\DoxyCodeLine{1302   \textcolor{keywordflow}{for} (vertex\_id\_type root : sources) \{}
\DoxyCodeLine{1303 }
\DoxyCodeLine{1304     std::vector<std::atomic<vertex\_id\_type>> depths(N);}
\DoxyCodeLine{1305     std::for\_each(depths.begin(), depths.end(), [\&](std::atomic<vertex\_id\_type>\& x) \{ x.store(std::numeric\_limits<vertex\_id\_type>::max()); \});}
\DoxyCodeLine{1306     std::vector<accum\_t>                       path\_counts(N);}
\DoxyCodeLine{1307     std::vector<std::multiset<vertex\_id\_type>> P(N);}
\DoxyCodeLine{1308 }
\DoxyCodeLine{1309     std::vector<tbb::concurrent\_vector<vertex\_id\_type>> S(2);}
\DoxyCodeLine{1310 }
\DoxyCodeLine{1311     path\_counts[root]                 = 1;}
\DoxyCodeLine{1312     depths[root]                      = 0;}
\DoxyCodeLine{1313     vertex\_id\_type              phase = 0;}
\DoxyCodeLine{1314     std::atomic<vertex\_id\_type> count = 1;}
\DoxyCodeLine{1315 }
\DoxyCodeLine{1316     S[phase].push\_back(root);}
\DoxyCodeLine{1317 }
\DoxyCodeLine{1318     \textcolor{keywordflow}{while} (count > 0) \{}
\DoxyCodeLine{1319       count = 0;}
\DoxyCodeLine{1320 }
\DoxyCodeLine{1321       \textcolor{keywordflow}{for} (vertex\_id\_type v : S[phase]) \{}
\DoxyCodeLine{1322         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& elt : g[v]) \{}
\DoxyCodeLine{1323           \textcolor{keyword}{auto} w = target(graph, elt);}
\DoxyCodeLine{1324 }
\DoxyCodeLine{1325           vertex\_id\_type neg\_one = std::numeric\_limits<vertex\_id\_type>::max();}
\DoxyCodeLine{1326           \textcolor{keywordflow}{if} (depths[w].compare\_exchange\_strong(neg\_one, depths[v] + 1)) \{}
\DoxyCodeLine{1327             S[phase + 1].push\_back(w);}
\DoxyCodeLine{1328             ++count;}
\DoxyCodeLine{1329           \}}
\DoxyCodeLine{1330           \textcolor{keywordflow}{if} (depths[w] == depths[v] + 1) \{}
\DoxyCodeLine{1331             path\_counts[w] += path\_counts[v];}
\DoxyCodeLine{1332             P[w].insert(v);}
\DoxyCodeLine{1333           \}}
\DoxyCodeLine{1334         \}}
\DoxyCodeLine{1335       \}}
\DoxyCodeLine{1336 }
\DoxyCodeLine{1337       phase = phase + 1;}
\DoxyCodeLine{1338       S.push\_back(tbb::concurrent\_vector<vertex\_id\_type>());}
\DoxyCodeLine{1339     \}}
\DoxyCodeLine{1340 }
\DoxyCodeLine{1341     std::vector<score\_t> delta(N);}
\DoxyCodeLine{1342 }
\DoxyCodeLine{1343     \textcolor{keywordflow}{while} (-\/-\/phase > 0) \{}
\DoxyCodeLine{1344       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} w : S[phase]) \{}
\DoxyCodeLine{1345         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} v : P[w]) \{}
\DoxyCodeLine{1346           delta[v] += \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(path\_counts[v]) / \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(path\_counts[w]) * (1 + delta[w]);}
\DoxyCodeLine{1347         \}}
\DoxyCodeLine{1348         bc[w] = bc[w] + delta[w];}
\DoxyCodeLine{1349       \}}
\DoxyCodeLine{1350     \}}
\DoxyCodeLine{1351   \}}
\DoxyCodeLine{1352 }
\DoxyCodeLine{1353   \textcolor{keywordflow}{if} (normalize) \{}
\DoxyCodeLine{1354     score\_t biggest\_score = *max\_element(bc.begin(), bc.end());}
\DoxyCodeLine{1355     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \&j : bc)}
\DoxyCodeLine{1356       j = j / biggest\_score; }
\DoxyCodeLine{1357   \}}
\DoxyCodeLine{1358 }
\DoxyCodeLine{1359   \textcolor{keywordflow}{return} bc;}
\DoxyCodeLine{1360 \}}
\DoxyCodeLine{1361 }
\DoxyCodeLine{1362 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} score\_t = float, \textcolor{keyword}{typename} accum\_t = size\_t,}
\DoxyCodeLine{1363           \textcolor{keyword}{class }ExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{1364 \textcolor{keyword}{auto} bc2\_v2(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& sources, ExecutionPolicy\&\& policy = \{\}, \textcolor{keywordtype}{bool} normalize = \textcolor{keyword}{true}) \{}
\DoxyCodeLine{1365   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{1366 }
\DoxyCodeLine{1367   \textcolor{keyword}{auto}                 g = graph.begin();}
\DoxyCodeLine{1368   vertex\_id\_type       N = num\_vertices(graph);}
\DoxyCodeLine{1369   std::vector<score\_t> bc(N, 0);}
\DoxyCodeLine{1370 }
\DoxyCodeLine{1371   \textcolor{keywordflow}{for} (vertex\_id\_type root : sources) \{}
\DoxyCodeLine{1372     std::vector<std::atomic<vertex\_id\_type>> depths(N);}
\DoxyCodeLine{1373 }
\DoxyCodeLine{1374     std::fill(policy, depths.begin(), depths.end(), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{1375 }
\DoxyCodeLine{1376     std::vector<accum\_t> path\_counts(N, 0);}
\DoxyCodeLine{1377 }
\DoxyCodeLine{1378     std::vector<tbb::concurrent\_vector<vertex\_id\_type>> P(N);}
\DoxyCodeLine{1379     std::vector<tbb::concurrent\_vector<vertex\_id\_type>> S(2);}
\DoxyCodeLine{1380 }
\DoxyCodeLine{1381     vertex\_id\_type depth = 0;}
\DoxyCodeLine{1382 }
\DoxyCodeLine{1383     path\_counts[root]                 = 1;}
\DoxyCodeLine{1384     depths[root]                      = depth++;}
\DoxyCodeLine{1385     vertex\_id\_type              phase = 0;}
\DoxyCodeLine{1386     std::atomic<vertex\_id\_type> count = 1;}
\DoxyCodeLine{1387 }
\DoxyCodeLine{1388     S[phase].push\_back(root);}
\DoxyCodeLine{1389 }
\DoxyCodeLine{1390     \textcolor{keywordflow}{while} (count > 0) \{}
\DoxyCodeLine{1391       count = 0;}
\DoxyCodeLine{1392 }
\DoxyCodeLine{1393       std::for\_each(policy, S[phase].begin(), S[phase].end(), [\&](\textcolor{keyword}{auto}\&\& v) \{}
\DoxyCodeLine{1394         tbb::parallel\_for(g[v], [\&](\textcolor{keyword}{auto}\&\& elt) \{}
\DoxyCodeLine{1395           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& e : elt) \{}
\DoxyCodeLine{1396             \textcolor{keyword}{auto} w = target(graph, e);}
\DoxyCodeLine{1397 }
\DoxyCodeLine{1398             vertex\_id\_type neg\_one = std::numeric\_limits<vertex\_id\_type>::max();}
\DoxyCodeLine{1399             \textcolor{keywordflow}{if} ((depths[w] == neg\_one) \&\& depths[w].compare\_exchange\_strong(neg\_one, depth)) \{}
\DoxyCodeLine{1400               S[phase + 1].push\_back(w);}
\DoxyCodeLine{1401               ++count;}
\DoxyCodeLine{1402             \}}
\DoxyCodeLine{1403             \textcolor{keywordflow}{if} (depths[w] == depth) \{}
\DoxyCodeLine{1404               path\_counts[w] += path\_counts[v];}
\DoxyCodeLine{1405               P[w].push\_back(v);}
\DoxyCodeLine{1406             \}}
\DoxyCodeLine{1407           \}}
\DoxyCodeLine{1408         \});}
\DoxyCodeLine{1409       \});}
\DoxyCodeLine{1410 }
\DoxyCodeLine{1411       phase = phase + 1;}
\DoxyCodeLine{1412       S.push\_back(tbb::concurrent\_vector<vertex\_id\_type>());}
\DoxyCodeLine{1413       ++depth;}
\DoxyCodeLine{1414     \}}
\DoxyCodeLine{1415 }
\DoxyCodeLine{1416     std::cout << \textcolor{stringliteral}{"{}depth phase = "{}} << depth << \textcolor{stringliteral}{"{} "{}} << phase << std::endl;}
\DoxyCodeLine{1417 }
\DoxyCodeLine{1418     std::vector<std::atomic<score\_t>> delta(N);}
\DoxyCodeLine{1419 }
\DoxyCodeLine{1420     \textcolor{keywordflow}{while} (-\/-\/phase > 0) \{}
\DoxyCodeLine{1421       std::for\_each(policy, S[phase].begin(), S[phase].end(), [\&](\textcolor{keyword}{auto}\&\& w) \{}
\DoxyCodeLine{1422         std::for\_each(P[w].begin(), P[w].end(), [\&](\textcolor{keyword}{auto}\&\& v) \{}
\DoxyCodeLine{1423           delta[v] += \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(path\_counts[v]) / \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(path\_counts[w]) * (1 + \textcolor{keyword}{static\_cast<}score\_t\textcolor{keyword}{>}(delta[w]));}
\DoxyCodeLine{1424         \});}
\DoxyCodeLine{1425 }
\DoxyCodeLine{1426         bc[w] += delta[w];}
\DoxyCodeLine{1427       \});}
\DoxyCodeLine{1428     \}}
\DoxyCodeLine{1429   \}}
\DoxyCodeLine{1430   \textcolor{keywordflow}{if} (normalize) \{}
\DoxyCodeLine{1431     score\_t biggest\_score = *max\_element(policy, bc.begin(), bc.end());}
\DoxyCodeLine{1432     std::for\_each(policy, bc.begin(), bc.end(), [\&](score\_t\& j) \{ j = j / biggest\_score; \});}
\DoxyCodeLine{1433   \}}
\DoxyCodeLine{1434   \textcolor{keywordflow}{return} bc;}
\DoxyCodeLine{1435 \}}
\DoxyCodeLine{1436 }
\DoxyCodeLine{1437 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{typename} score\_t = float, \textcolor{keyword}{typename} accum\_t = size\_t,}
\DoxyCodeLine{1438           \textcolor{keyword}{class }OuterExecutionPolicy = std::execution::parallel\_unsequenced\_policy,}
\DoxyCodeLine{1439           \textcolor{keyword}{class }InnerExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{1440 \textcolor{keyword}{auto} bc2\_v3(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& sources, OuterExecutionPolicy\&\& outer\_policy = \{\},}
\DoxyCodeLine{1441             InnerExecutionPolicy\&\& inner\_policy = \{\}, \textcolor{keywordtype}{bool} normalize = \textcolor{keyword}{true}) \{}
\DoxyCodeLine{1442   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{1443 }
\DoxyCodeLine{1444   vertex\_id\_type N = num\_vertices(graph);}
\DoxyCodeLine{1445   \textcolor{keywordtype}{size\_t}         M = graph.to\_be\_indexed\_.size();}
\DoxyCodeLine{1446 }
\DoxyCodeLine{1447   \textcolor{keyword}{auto}                 neighbors = (*(graph.begin())).begin();}
\DoxyCodeLine{1448   std::vector<score\_t> bc(N);}
\DoxyCodeLine{1449 }
\DoxyCodeLine{1450   \textcolor{keyword}{const} vertex\_id\_type num\_bins = 32;}
\DoxyCodeLine{1451   \textcolor{keyword}{const} vertex\_id\_type bin\_mask = 0x1F;}
\DoxyCodeLine{1452 }
\DoxyCodeLine{1453   \textcolor{keywordflow}{for} (vertex\_id\_type root : sources) \{}
\DoxyCodeLine{1454     std::cout << \textcolor{stringliteral}{"{}source: "{}} << root << std::endl;}
\DoxyCodeLine{1455 }
\DoxyCodeLine{1456     std::vector<std::atomic<vertex\_id\_type>> levels(N);}
\DoxyCodeLine{1457     std::vector<std::atomic<bool>>           succ(M);    \textcolor{comment}{// use tbb:: bit map ?}}
\DoxyCodeLine{1458 }
\DoxyCodeLine{1459     std::fill(outer\_policy, levels.begin(), levels.end(), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{1460 }
\DoxyCodeLine{1461     std::vector<std::atomic<accum\_t>>                                path\_counts(N);    \textcolor{comment}{// move outside loop?}}
\DoxyCodeLine{1462     std::vector<tbb::concurrent\_vector<vertex\_id\_type>>              q1(num\_bins);}
\DoxyCodeLine{1463     std::vector<tbb::concurrent\_vector<vertex\_id\_type>>              q2(num\_bins);}
\DoxyCodeLine{1464     std::vector<std::vector<tbb::concurrent\_vector<vertex\_id\_type>>> retired;}
\DoxyCodeLine{1465 }
\DoxyCodeLine{1466     vertex\_id\_type lvl = 0;}
\DoxyCodeLine{1467 }
\DoxyCodeLine{1468     path\_counts[root] = 1;}
\DoxyCodeLine{1469     q1[0].push\_back(root);}
\DoxyCodeLine{1470     levels[root] = lvl++;}
\DoxyCodeLine{1471 }
\DoxyCodeLine{1472     \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};}
\DoxyCodeLine{1473     \textcolor{keywordflow}{while} (!done) \{}
\DoxyCodeLine{1474       std::for\_each(outer\_policy, q1.begin(), q1.end(), [\&](\textcolor{keyword}{auto}\& q) \{}
\DoxyCodeLine{1475         std::for\_each(inner\_policy, q.begin(), q.end(), [\&](vertex\_id\_type u) \{}
\DoxyCodeLine{1476           \textcolor{comment}{// tbb::parallel\_for(g[u], [\&](auto\&\& gu) \{}}
\DoxyCodeLine{1477           for (auto x = graph[u].begin(); x != graph[u].end(); ++x) \{}
\DoxyCodeLine{1478             auto v = target(graph, *x);}
\DoxyCodeLine{1479             \textcolor{comment}{//auto\&\&         v       = std::get<0>(*x);}}
\DoxyCodeLine{1480             vertex\_id\_type neg\_one = std::numeric\_limits<vertex\_id\_type>::max();}
\DoxyCodeLine{1481             if (levels[v] == neg\_one \&\& levels[v].compare\_exchange\_strong(neg\_one, lvl)) \{}
\DoxyCodeLine{1482               q2[u \& bin\_mask].push\_back(v);}
\DoxyCodeLine{1483             \}}
\DoxyCodeLine{1484             if (levels[v] == lvl) \{}
\DoxyCodeLine{1485               \textcolor{comment}{// path\_counts[v].fetch\_add(path\_counts[u]);}}
\DoxyCodeLine{1486               for (accum\_t temp = path\_counts[v];}
\DoxyCodeLine{1487                    !path\_counts[v].compare\_exchange\_strong(temp, temp + path\_counts[u], std::memory\_order\_acq\_rel);)}
\DoxyCodeLine{1488                 ;}
\DoxyCodeLine{1489               succ[x -\/ neighbors] = true;    \textcolor{comment}{// edge(w,v) : P[w][v]}}
\DoxyCodeLine{1490             \}}
\DoxyCodeLine{1491           \}}
\DoxyCodeLine{1492           \textcolor{comment}{//\});}}
\DoxyCodeLine{1493         \});}
\DoxyCodeLine{1494       \});}
\DoxyCodeLine{1495 }
\DoxyCodeLine{1496       done = \textcolor{keyword}{true};}
\DoxyCodeLine{1497       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < num\_bins; ++i) \{}
\DoxyCodeLine{1498         \textcolor{keywordflow}{if} (q2[i].size() != 0) \{}
\DoxyCodeLine{1499           done = \textcolor{keyword}{false};}
\DoxyCodeLine{1500           \textcolor{keywordflow}{break};}
\DoxyCodeLine{1501         \}}
\DoxyCodeLine{1502       \}}
\DoxyCodeLine{1503 }
\DoxyCodeLine{1504       retired.emplace\_back(num\_bins);}
\DoxyCodeLine{1505       std::swap(q1, retired.back());}
\DoxyCodeLine{1506       std::swap(q1, q2);}
\DoxyCodeLine{1507 }
\DoxyCodeLine{1508       ++lvl;}
\DoxyCodeLine{1509     \}}
\DoxyCodeLine{1510 }
\DoxyCodeLine{1511     \textcolor{comment}{// std::cout << "{}lvl = "{} << lvl << "{} "{} << retired.size() << std::endl;}}
\DoxyCodeLine{1512 }
\DoxyCodeLine{1513     std::vector<score\_t> deltas(N);}
\DoxyCodeLine{1514 }
\DoxyCodeLine{1515     std::for\_each(retired.rbegin(), retired.rend(), [\&](\textcolor{keyword}{auto}\&\& vvv) \{}
\DoxyCodeLine{1516       std::for\_each(outer\_policy, vvv.begin(), vvv.end(), [\&](auto\&\& vv) \{}
\DoxyCodeLine{1517         std::for\_each(inner\_policy, vv.begin(), vv.end(), [\&](auto\&\& u) \{}
\DoxyCodeLine{1518           score\_t delta = 0;}
\DoxyCodeLine{1519           for (auto x = graph[u].begin(); x != graph[u].end(); ++x) \{}
\DoxyCodeLine{1520             auto v = target(graph, *x);}
\DoxyCodeLine{1521             \textcolor{comment}{//vertex\_id\_type v = std::get<0>(*x);}}
\DoxyCodeLine{1522             if (succ[x -\/ neighbors]) \{}
\DoxyCodeLine{1523               delta += static\_cast<double>(path\_counts[u]) / static\_cast<double>(path\_counts[v]) * (1 + deltas[v]);}
\DoxyCodeLine{1524             \}}
\DoxyCodeLine{1525           \}}
\DoxyCodeLine{1526           deltas[u] = delta;}
\DoxyCodeLine{1527           bc[u] += delta;}
\DoxyCodeLine{1528         \});}
\DoxyCodeLine{1529       \});}
\DoxyCodeLine{1530     \});}
\DoxyCodeLine{1531   \}}
\DoxyCodeLine{1532   \textcolor{keywordflow}{if} (normalize) \{}
\DoxyCodeLine{1533     score\_t biggest\_score = *max\_element(outer\_policy, bc.begin(), bc.end());}
\DoxyCodeLine{1534     std::for\_each(outer\_policy, bc.begin(), bc.end(), [\&](score\_t\& j) \{ j = j / biggest\_score; \});}
\DoxyCodeLine{1535   \}}
\DoxyCodeLine{1536   \textcolor{keywordflow}{return} bc;}
\DoxyCodeLine{1537 \}}
\DoxyCodeLine{1538 }
\DoxyCodeLine{1539 \textcolor{keyword}{template} <\textcolor{keyword}{class }score\_t, \textcolor{keyword}{class }accum\_t, adjacency\_list\_graph Graph, \textcolor{keyword}{class }OuterExecutionPolicy = std::execution::parallel\_unsequenced\_policy,}
\DoxyCodeLine{1540           \textcolor{keyword}{class }InnerExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{1541 \textcolor{keyword}{auto} bc2\_v4(\textcolor{keyword}{const} Graph\& graph, \textcolor{keyword}{const} std::vector<typename Graph::vertex\_id\_type>\& sources, \textcolor{keywordtype}{int} threads,}
\DoxyCodeLine{1542             OuterExecutionPolicy\&\& outer\_policy = \{\}, InnerExecutionPolicy\&\& inner\_policy = \{\}, \textcolor{keywordtype}{bool} normalize = \textcolor{keyword}{true}) \{}
\DoxyCodeLine{1543   \textcolor{keyword}{using} vertex\_id\_type = \textcolor{keyword}{typename} Graph::vertex\_id\_type;}
\DoxyCodeLine{1544 }
\DoxyCodeLine{1545   vertex\_id\_type       N     = num\_vertices(graph);}
\DoxyCodeLine{1546   \textcolor{keywordtype}{size\_t}               M     = graph.to\_be\_indexed\_.size();}
\DoxyCodeLine{1547   \textcolor{keyword}{auto}\&\&               edges = std::get<0>(*(*graph.begin()).begin());}
\DoxyCodeLine{1548   std::vector<score\_t> bc(N);}
\DoxyCodeLine{1549 }
\DoxyCodeLine{1550   \textcolor{keyword}{const} vertex\_id\_type num\_bins = nw::graph::pow2(nw::graph::ceil\_log2(threads));}
\DoxyCodeLine{1551   \textcolor{keyword}{const} vertex\_id\_type bin\_mask = num\_bins -\/ 1;}
\DoxyCodeLine{1552 }
\DoxyCodeLine{1553   \textcolor{keywordflow}{for} (vertex\_id\_type root : sources) \{}
\DoxyCodeLine{1554     std::vector<std::atomic<vertex\_id\_type>> levels(N);}
\DoxyCodeLine{1555     \mbox{\hyperlink{classnw_1_1graph_1_1_atomic_bit_vector}{nw::graph::AtomicBitVector}}               succ(M);}
\DoxyCodeLine{1556 }
\DoxyCodeLine{1557     std::fill(outer\_policy, levels.begin(), levels.end(), std::numeric\_limits<vertex\_id\_type>::max());}
\DoxyCodeLine{1558 }
\DoxyCodeLine{1559     std::vector<std::atomic<accum\_t>>                                path\_counts(N);    \textcolor{comment}{// move outside loop?}}
\DoxyCodeLine{1560     std::vector<tbb::concurrent\_vector<vertex\_id\_type>>              q1(num\_bins);}
\DoxyCodeLine{1561     std::vector<tbb::concurrent\_vector<vertex\_id\_type>>              q2(num\_bins);}
\DoxyCodeLine{1562     std::vector<std::vector<tbb::concurrent\_vector<vertex\_id\_type>>> retired;}
\DoxyCodeLine{1563 }
\DoxyCodeLine{1564     vertex\_id\_type lvl = 0;}
\DoxyCodeLine{1565 }
\DoxyCodeLine{1566     path\_counts[root] = 1;}
\DoxyCodeLine{1567     q1[0].push\_back(root);}
\DoxyCodeLine{1568     levels[root] = lvl++;}
\DoxyCodeLine{1569 }
\DoxyCodeLine{1570     \textcolor{keywordtype}{bool} done = \textcolor{keyword}{false};}
\DoxyCodeLine{1571     \textcolor{keywordflow}{while} (!done) \{}
\DoxyCodeLine{1572       std::for\_each(outer\_policy, q1.begin(), q1.end(), [\&](\textcolor{keyword}{auto}\&\& q) \{}
\DoxyCodeLine{1573         std::for\_each(inner\_policy, q.begin(), q.end(), [\&](auto\&\& u) \{}
\DoxyCodeLine{1574           for (auto\&\& elt : graph[u]) \{}
\DoxyCodeLine{1575             auto v = target(graph, elt);}
\DoxyCodeLine{1576             auto\&\& neg\_one = std::numeric\_limits<vertex\_id\_type>::max();}
\DoxyCodeLine{1577             if (nw::graph::acquire(levels[v]) == neg\_one \&\& nw::graph::cas(levels[v], neg\_one, lvl)) \{}
\DoxyCodeLine{1578               q2[u \& bin\_mask].push\_back(v);}
\DoxyCodeLine{1579             \}}
\DoxyCodeLine{1580             if (nw::graph::acquire(levels[v]) == lvl) \{}
\DoxyCodeLine{1581               nw::graph::fetch\_add(path\_counts[v], nw::graph::acquire(path\_counts[u]));}
\DoxyCodeLine{1582               succ.atomic\_set(\&v -\/ \&edges);    \textcolor{comment}{// edge(w,v) : P[w][v]}}
\DoxyCodeLine{1583             \}}
\DoxyCodeLine{1584           \}}
\DoxyCodeLine{1585         \});}
\DoxyCodeLine{1586       \});}
\DoxyCodeLine{1587 }
\DoxyCodeLine{1588       done = \textcolor{keyword}{true};}
\DoxyCodeLine{1589       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < num\_bins; ++i) \{}
\DoxyCodeLine{1590         \textcolor{keywordflow}{if} (q2[i].size() != 0) \{}
\DoxyCodeLine{1591           done = \textcolor{keyword}{false};}
\DoxyCodeLine{1592           \textcolor{keywordflow}{break};}
\DoxyCodeLine{1593         \}}
\DoxyCodeLine{1594       \}}
\DoxyCodeLine{1595 }
\DoxyCodeLine{1596       retired.emplace\_back(num\_bins);}
\DoxyCodeLine{1597       std::swap(q1, retired.back());}
\DoxyCodeLine{1598       std::swap(q1, q2);}
\DoxyCodeLine{1599 }
\DoxyCodeLine{1600       ++lvl;}
\DoxyCodeLine{1601     \}}
\DoxyCodeLine{1602 }
\DoxyCodeLine{1603     \textcolor{comment}{// std::cout << "{}lvl = "{} << lvl << "{} "{} << retired.size() << std::endl;}}
\DoxyCodeLine{1604 }
\DoxyCodeLine{1605     std::vector<score\_t> deltas(N);}
\DoxyCodeLine{1606 }
\DoxyCodeLine{1607     std::for\_each(retired.rbegin(), retired.rend(), [\&](\textcolor{keyword}{auto}\&\& vvv) \{}
\DoxyCodeLine{1608       std::for\_each(outer\_policy, vvv.begin(), vvv.end(), [\&](auto\&\& vv) \{}
\DoxyCodeLine{1609         std::for\_each(inner\_policy, vv.begin(), vv.end(), [\&](auto\&\& u) \{}
\DoxyCodeLine{1610           score\_t delta = 0;}
\DoxyCodeLine{1611           for (auto x = graph[u].begin(); x != graph[u].end(); ++x) \{}
\DoxyCodeLine{1612             auto v = target(graph, *x);}
\DoxyCodeLine{1613             \textcolor{comment}{//auto\&\& v = std::get<0>(*x);}}
\DoxyCodeLine{1614             if (succ.get(\&v -\/ \&edges)) \{}
\DoxyCodeLine{1615               delta += path\_counts[u] / path\_counts[v] * (1 + deltas[v]);}
\DoxyCodeLine{1616             \}}
\DoxyCodeLine{1617           \}}
\DoxyCodeLine{1618           deltas[u] = delta;}
\DoxyCodeLine{1619           bc[u] += delta;}
\DoxyCodeLine{1620         \});}
\DoxyCodeLine{1621       \});}
\DoxyCodeLine{1622     \});}
\DoxyCodeLine{1623   \}}
\DoxyCodeLine{1624 }
\DoxyCodeLine{1625   \textcolor{keywordflow}{if} (normalize) \{}
\DoxyCodeLine{1626     score\_t biggest\_score = *max\_element(outer\_policy, bc.begin(), bc.end());}
\DoxyCodeLine{1627     std::for\_each(outer\_policy, bc.begin(), bc.end(), [\&](score\_t\& j) \{ j = j / biggest\_score; \});}
\DoxyCodeLine{1628   \}}
\DoxyCodeLine{1629   \textcolor{keywordflow}{return} bc;}
\DoxyCodeLine{1630 \}}
\DoxyCodeLine{1631 }
\DoxyCodeLine{1632 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{1633 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{1634 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// BETWEENNESS\_EXPERIMENTAL\_CENTRALITY\_HPP}}

\end{DoxyCode}
