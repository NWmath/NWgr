\hypertarget{adjacency_8hpp_source}{}\doxysection{adjacency.\+hpp}
\label{adjacency_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/adjacency.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/adjacency.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine}}
\DoxyCodeLine{10 \textcolor{comment}{//     Xu Tony Liu}}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_ADJACENCY\_HPP}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define NW\_GRAPH\_ADJACENCY\_HPP}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include "{}nwgraph/containers/compressed.hpp"{}}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}nwgraph/edge\_list.hpp"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_base.hpp"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_concepts.hpp"{}}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}nwgraph/util/defaults.hpp"{}}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include "{}nwgraph/build.hpp"{}}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <concepts>}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include "{}nwgraph/graph\_concepts.hpp"{}}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 }
\DoxyCodeLine{29 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{30 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{33 \textcolor{keyword}{template} <std::unsigned\_integral index\_type, std::unsigned\_integral vertex\_id\_type, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{34 \textcolor{keyword}{class }index\_compressed : \textcolor{keyword}{public} unipartite\_graph\_base, \textcolor{keyword}{public} indexed\_struct\_of\_arrays<index\_type, vertex\_id\_type, Attributes...> \{}
\DoxyCodeLine{35   \textcolor{keyword}{using} base = indexed\_struct\_of\_arrays<index\_type, vertex\_id\_type, Attributes...>;}
\DoxyCodeLine{36 }
\DoxyCodeLine{37 \textcolor{keyword}{public}:}
\DoxyCodeLine{38   \textcolor{keyword}{using} index\_t = index\_type;}
\DoxyCodeLine{39   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_type;}
\DoxyCodeLine{40 }
\DoxyCodeLine{41   index\_compressed(\textcolor{keywordtype}{size\_t} N) : unipartite\_graph\_base(N), base(N) \{\}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43   \textcolor{keywordtype}{void} close\_for\_push\_back() \{ base::close\_for\_push\_back(); \};}
\DoxyCodeLine{44 }
\DoxyCodeLine{45   \textcolor{keyword}{auto} num\_edges() \{ \textcolor{keywordflow}{return} base::to\_be\_indexed\_.size(); \}}
\DoxyCodeLine{46 \};}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 }
\DoxyCodeLine{49 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{50 \textcolor{keyword}{using} compressed = index\_compressed<default\_index\_t, default\_vertex\_id\_type, Attributes...>;}
\DoxyCodeLine{51 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} idx, std::unsigned\_integral index\_type, std::unsigned\_integral vertex\_id, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{54 \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}} : \textcolor{keyword}{public} \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}, \textcolor{keyword}{public} \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{indexed\_struct\_of\_arrays}}<index\_type, vertex\_id, Attributes...> \{}
\DoxyCodeLine{55   \textcolor{keyword}{using} \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}} = \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{indexed\_struct\_of\_arrays}}<index\_type, vertex\_id, Attributes...>;}
\DoxyCodeLine{56 }
\DoxyCodeLine{57 \textcolor{keyword}{public}:}
\DoxyCodeLine{58   \textcolor{keyword}{using} index\_t           = index\_type;}
\DoxyCodeLine{59   \textcolor{keyword}{using} vertex\_id\_type    = vertex\_id;}
\DoxyCodeLine{60   \textcolor{keyword}{using} num\_vertices\_type = std::array<vertex\_id\_type, 1>;}
\DoxyCodeLine{61   \textcolor{keyword}{using} num\_edges\_type    = index\_t;}
\DoxyCodeLine{62 }
\DoxyCodeLine{63   \textcolor{comment}{// The first index\_t isn't considered an attribute.}}
\DoxyCodeLine{64   \textcolor{keyword}{using} attributes\_t = std::tuple<Attributes...>;}
\DoxyCodeLine{65   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::size\_t getNAttr() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}...(Attributes); \}}
\DoxyCodeLine{66 }
\DoxyCodeLine{67   \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}(\textcolor{keywordtype}{size\_t} N = 0, \textcolor{keywordtype}{size\_t} M = 0) \textcolor{keyword}{requires}(std::is\_same<unipartite\_graph\_base, unipartite\_graph\_base>::value) : \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}(N), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(N, M) \{\}}
\DoxyCodeLine{68   \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}(std::array<size\_t, 1> N, \textcolor{keywordtype}{size\_t} M = 0) \textcolor{keyword}{requires}(std::is\_same<unipartite\_graph\_base, unipartite\_graph\_base>::value) : \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}(N), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(N[0], M) \{\}}
\DoxyCodeLine{69 }
\DoxyCodeLine{70   \textcolor{keyword}{template} <\textcolor{keyword}{class} ExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{71   \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}(\mbox{\hyperlink{classnw_1_1graph_1_1index__edge__list}{index\_edge\_list<vertex\_id\_type, unipartite\_graph\_base, directedness::directed, Attributes...>}}\& A,}
\DoxyCodeLine{72                   \textcolor{keywordtype}{bool} sort\_adjacency = \textcolor{keyword}{false},}
\DoxyCodeLine{73                   ExecutionPolicy\&\&                                                                              policy = \{\})}
\DoxyCodeLine{74       : \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}(A.num\_vertices()[0]), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(A.num\_vertices()[0] + 1) \{}
\DoxyCodeLine{75     fill<idx>(A, *\textcolor{keyword}{this}, sort\_adjacency, policy);}
\DoxyCodeLine{76   \}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78   \textcolor{keyword}{template} <\textcolor{keyword}{class} ExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{79   \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}(\mbox{\hyperlink{classnw_1_1graph_1_1index__edge__list}{index\_edge\_list<vertex\_id\_type, unipartite\_graph\_base, directedness::undirected, Attributes...>}}\& A,}
\DoxyCodeLine{80                   \textcolor{keywordtype}{bool} sort\_adjacency = \textcolor{keyword}{false},}
\DoxyCodeLine{81                   ExecutionPolicy\&\&                                                                                policy = \{\})}
\DoxyCodeLine{82       : \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}(A.num\_vertices()[0]), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(A.num\_vertices()[0] + 1) \{}
\DoxyCodeLine{83     fill<idx>(A, *\textcolor{keyword}{this}, sort\_adjacency, policy);}
\DoxyCodeLine{84   \}}
\DoxyCodeLine{85 }
\DoxyCodeLine{86   \textcolor{keyword}{template} <\textcolor{keyword}{class} ExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{87   \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}(\textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{88                   \mbox{\hyperlink{classnw_1_1graph_1_1index__edge__list}{index\_edge\_list}}<vertex\_id\_type, \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}},}
\DoxyCodeLine{89                                   directedness::directed, Attributes...>\& A,}
\DoxyCodeLine{90                   \textcolor{keywordtype}{bool} sort\_adjacency = \textcolor{keyword}{false},                }
\DoxyCodeLine{91                   ExecutionPolicy\&\& policy = \{\})}
\DoxyCodeLine{92       : \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}(N), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(N) \{}
\DoxyCodeLine{93     fill<idx>(A, *\textcolor{keyword}{this}, sort\_adjacency, policy);}
\DoxyCodeLine{94   \}}
\DoxyCodeLine{95   \textcolor{keyword}{template} <\textcolor{keyword}{class} ExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{96   \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}(\textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{97                   \mbox{\hyperlink{classnw_1_1graph_1_1index__edge__list}{index\_edge\_list}}<vertex\_id\_type, \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}},}
\DoxyCodeLine{98                                   directedness::undirected, Attributes...>\& A,}
\DoxyCodeLine{99                   \textcolor{keywordtype}{bool} sort\_adjacency = \textcolor{keyword}{false},}
\DoxyCodeLine{100                   ExecutionPolicy\&\& policy = \{\})}
\DoxyCodeLine{101       : \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}(N), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(N) \{}
\DoxyCodeLine{102     fill<idx>(A, *\textcolor{keyword}{this}, sort\_adjacency, policy);}
\DoxyCodeLine{103   \}}
\DoxyCodeLine{104   \textcolor{comment}{// customized move constructor}}
\DoxyCodeLine{105   \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}(std::vector<vertex\_id>\&\& indices,}
\DoxyCodeLine{106                   std::vector<vertex\_id>\&\& first\_to\_be,}
\DoxyCodeLine{107                   std::vector<Attributes>\&\&... rest\_to\_be)}
\DoxyCodeLine{108       : \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}(indices.size() -\/ 1), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(std::move(indices), std::move(first\_to\_be), std::move(rest\_to\_be)...) \{\}}
\DoxyCodeLine{109   \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}(std::vector<vertex\_id>\&\& indices,}
\DoxyCodeLine{110                   std::tuple<std::vector<vertex\_id>,}
\DoxyCodeLine{111                              std::vector<Attributes>...>\&\& to\_be\_indexed)}
\DoxyCodeLine{112       : \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}(indices.size() -\/ 1), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(std::move(indices), std::move(to\_be\_indexed)) \{\}}
\DoxyCodeLine{113   \textcolor{comment}{// customized copy constructor}}
\DoxyCodeLine{114   \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}(\textcolor{keyword}{const} std::vector<vertex\_id>\& indices,}
\DoxyCodeLine{115                   \textcolor{keyword}{const} std::vector<vertex\_id>\& first\_to\_be,}
\DoxyCodeLine{116                   \textcolor{keyword}{const} std::vector<Attributes>\&... rest\_to\_be)}
\DoxyCodeLine{117       : \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}(indices.size() -\/ 1), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(indices, first\_to\_be, rest\_to\_be...) \{\}}
\DoxyCodeLine{118   \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}(\textcolor{keyword}{const} std::vector<vertex\_id>\& indices,}
\DoxyCodeLine{119                   \textcolor{keyword}{const} std::tuple<std::vector<vertex\_id>,}
\DoxyCodeLine{120                                    std::vector<Attributes>...>\& to\_be\_indexed)}
\DoxyCodeLine{121       : \mbox{\hyperlink{classnw_1_1graph_1_1unipartite__graph__base}{unipartite\_graph\_base}}(indices.size() -\/ 1), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(indices, to\_be\_indexed) \{\}}
\DoxyCodeLine{122 }
\DoxyCodeLine{123   num\_vertices\_type num\_vertices()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{base::size()\}; \};}
\DoxyCodeLine{124   num\_edges\_type    num\_edges()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} base::to\_be\_indexed\_.size(); \};}
\DoxyCodeLine{125 \};}
\DoxyCodeLine{126 }
\DoxyCodeLine{127 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} idx, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{128 \textcolor{keyword}{using} \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{adjacency}} = \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{index\_adjacency}}<idx, default\_index\_t, default\_vertex\_id\_type, Attributes...>;}
\DoxyCodeLine{129 }
\DoxyCodeLine{130 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t>}
\DoxyCodeLine{131 \textcolor{keyword}{auto} make\_adjacency(edge\_list\_t\& el) \{}
\DoxyCodeLine{132   \textcolor{keywordflow}{return} \mbox{\hyperlink{classnw_1_1graph_1_1index__adjacency}{adjacency<idx>}}(el);}
\DoxyCodeLine{133 \}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135 }
\DoxyCodeLine{136 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_c edge\_list\_t, std::\textcolor{keywordtype}{unsigned}\_\textcolor{keywordtype}{int}egral u\_\textcolor{keywordtype}{int}egral, \textcolor{keyword}{class} ExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{137 \textcolor{keyword}{auto} make\_adjacency(edge\_list\_t\& el, u\_integral n, directedness edge\_directedness = directedness::directed, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{138   adjacency<idx> adj(n);}
\DoxyCodeLine{139   fill<idx>(el, adj, edge\_directedness, policy);}
\DoxyCodeLine{140   \textcolor{keywordflow}{return} adj;}
\DoxyCodeLine{141 \}}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} idx, std::unsigned\_integral index\_type, std::unsigned\_integral vertex\_id, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{144 \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{index\_biadjacency}} : \textcolor{keyword}{public} \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}}, \textcolor{keyword}{public} \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{indexed\_struct\_of\_arrays}}<index\_type, vertex\_id, Attributes...> \{}
\DoxyCodeLine{145   \textcolor{keyword}{using} \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}} = \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{indexed\_struct\_of\_arrays}}<index\_type, vertex\_id, Attributes...>;}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{keyword}{public}:}
\DoxyCodeLine{148   \textcolor{keyword}{using} index\_t           = index\_type;}
\DoxyCodeLine{149   \textcolor{keyword}{using} vertex\_id\_type    = vertex\_id;}
\DoxyCodeLine{150   \textcolor{keyword}{using} num\_vertices\_type = std::array<vertex\_id\_type, 1>;}
\DoxyCodeLine{151   \textcolor{keyword}{using} num\_edges\_type    = index\_t;}
\DoxyCodeLine{152 }
\DoxyCodeLine{153   \textcolor{comment}{// The first index\_t isn't considered an attribute.}}
\DoxyCodeLine{154   \textcolor{keyword}{using} attributes\_t = std::tuple<Attributes...>;}
\DoxyCodeLine{155   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::size\_t getNAttr() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}...(Attributes); \}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157   \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{index\_biadjacency}}(\textcolor{keywordtype}{size\_t} N0 = 0, \textcolor{keywordtype}{size\_t} N1 = 0, \textcolor{keywordtype}{size\_t} M = 0) \textcolor{keyword}{requires}(std::is\_same<bipartite\_graph\_base, bipartite\_graph\_base>::value) : \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}}(N0, N1), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(N0, M) \{\}}
\DoxyCodeLine{158   \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{index\_biadjacency}}(std::array<size\_t, 2> N, \textcolor{keywordtype}{size\_t} M = 0) \textcolor{keyword}{requires}(std::is\_same<bipartite\_graph\_base, bipartite\_graph\_base>::value) : \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}}(N[idx], N[(idx + 1) \% 2]), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(N[idx], M) \{\}}
\DoxyCodeLine{159 }
\DoxyCodeLine{160   \textcolor{keyword}{template} <\textcolor{keyword}{class} ExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{161   \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{index\_biadjacency}}(\mbox{\hyperlink{classnw_1_1graph_1_1index__edge__list}{index\_edge\_list}}<vertex\_id\_type, \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}},}
\DoxyCodeLine{162                                     directedness::directed, Attributes...>\& A,}
\DoxyCodeLine{163                     \textcolor{keywordtype}{bool} sort\_biadjacency = \textcolor{keyword}{false},}
\DoxyCodeLine{164                     ExecutionPolicy\&\& policy = \{\})}
\DoxyCodeLine{165       : \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}}(A.num\_vertices()[idx],}
\DoxyCodeLine{166                              A.num\_vertices()[(idx + 1) \% 2]),}
\DoxyCodeLine{167         \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(A.num\_vertices()[idx] + 1) \{}
\DoxyCodeLine{168     fill\_biadjacency<idx>(A, *\textcolor{keyword}{this}, sort\_biadjacency, policy);}
\DoxyCodeLine{169   \}}
\DoxyCodeLine{170 }
\DoxyCodeLine{171   \textcolor{keyword}{template} <\textcolor{keyword}{class} ExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{172   \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{index\_biadjacency}}(\mbox{\hyperlink{classnw_1_1graph_1_1index__edge__list}{index\_edge\_list}}<vertex\_id\_type, \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}},}
\DoxyCodeLine{173                                     directedness::undirected, Attributes...>\& A,}
\DoxyCodeLine{174                     \textcolor{keywordtype}{bool} sort\_biadjacency = \textcolor{keyword}{false},}
\DoxyCodeLine{175                     ExecutionPolicy\&\& policy = \{\})}
\DoxyCodeLine{176       : \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}}(A.num\_vertices()[idx],}
\DoxyCodeLine{177                              A.num\_vertices()[(idx + 1) \% 2]),}
\DoxyCodeLine{178         \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(A.num\_vertices()[idx] + 1) \{}
\DoxyCodeLine{179     fill\_biadjacency<idx>(A, *\textcolor{keyword}{this}, sort\_biadjacency, policy);}
\DoxyCodeLine{180   \}}
\DoxyCodeLine{181   \textcolor{comment}{// customized move constructor}}
\DoxyCodeLine{182   \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{index\_biadjacency}}(\textcolor{keywordtype}{size\_t} N1, std::vector<vertex\_id>\&\& indices,}
\DoxyCodeLine{183                   std::vector<vertex\_id>\&\& first\_to\_be,}
\DoxyCodeLine{184                   std::vector<Attributes>\&\&... rest\_to\_be)}
\DoxyCodeLine{185       : \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}}(indices.size() -\/ 1, N1), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(std::move(indices), std::move(first\_to\_be), std::move(rest\_to\_be)...) \{\}}
\DoxyCodeLine{186   \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{index\_biadjacency}}(\textcolor{keywordtype}{size\_t} N1, std::vector<vertex\_id>\&\& indices,}
\DoxyCodeLine{187                   std::tuple<std::vector<vertex\_id>,}
\DoxyCodeLine{188                              std::vector<Attributes>...>\&\& to\_be\_indexed)}
\DoxyCodeLine{189       : \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}}(indices.size() -\/ 1, N1), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(std::move(indices), std::move(to\_be\_indexed)) \{\}}
\DoxyCodeLine{190   \textcolor{comment}{// customized copy constructor}}
\DoxyCodeLine{191   \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{index\_biadjacency}}(\textcolor{keywordtype}{size\_t} N1, \textcolor{keyword}{const} std::vector<vertex\_id>\& indices,}
\DoxyCodeLine{192                   \textcolor{keyword}{const} std::vector<vertex\_id>\& first\_to\_be,}
\DoxyCodeLine{193                   \textcolor{keyword}{const} std::vector<Attributes>\&... rest\_to\_be)}
\DoxyCodeLine{194       : \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}}(indices.size() -\/ 1, N1), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(indices, first\_to\_be, rest\_to\_be...) \{\}}
\DoxyCodeLine{195   \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{index\_biadjacency}}(\textcolor{keywordtype}{size\_t} N1, \textcolor{keyword}{const} std::vector<vertex\_id>\& indices,}
\DoxyCodeLine{196                   \textcolor{keyword}{const} std::tuple<std::vector<vertex\_id>,}
\DoxyCodeLine{197                                    std::vector<Attributes>...>\& to\_be\_indexed)}
\DoxyCodeLine{198       : \mbox{\hyperlink{classnw_1_1graph_1_1bipartite__graph__base}{bipartite\_graph\_base}}(indices.size() -\/ 1, N1), \mbox{\hyperlink{classnw_1_1graph_1_1indexed__struct__of__arrays}{base}}(indices, to\_be\_indexed) \{\}}
\DoxyCodeLine{199 }
\DoxyCodeLine{200   \textcolor{keyword}{auto} num\_vertices()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} vertex\_cardinality; \}}
\DoxyCodeLine{201   num\_edges\_type    num\_edges()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} base::to\_be\_indexed\_.size(); \};}
\DoxyCodeLine{202 \};}
\DoxyCodeLine{203 }
\DoxyCodeLine{204 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} idx, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{205 \textcolor{keyword}{using} \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{biadjacency}} = \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{index\_biadjacency}}<idx, default\_index\_t, default\_vertex\_id\_type, Attributes...>;}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_graph edge\_list\_t>}
\DoxyCodeLine{208 \textcolor{keyword}{auto} make\_biadjacency(edge\_list\_t\& el) \{}
\DoxyCodeLine{209   \textcolor{keywordflow}{return} \mbox{\hyperlink{classnw_1_1graph_1_1index__biadjacency}{biadjacency<idx>}}(el);}
\DoxyCodeLine{210 \}}
\DoxyCodeLine{211 }
\DoxyCodeLine{212 }
\DoxyCodeLine{213 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}x, edge\_list\_c edge\_list\_t, std::\textcolor{keywordtype}{unsigned}\_\textcolor{keywordtype}{int}egral u\_\textcolor{keywordtype}{int}egral, \textcolor{keyword}{class} ExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{214 \textcolor{keyword}{auto} make\_biadjacency(edge\_list\_t\& el, u\_integral n0, u\_integral n1, directedness edge\_directedness = directedness::directed, ExecutionPolicy\&\& policy = \{\}) \{}
\DoxyCodeLine{215   biadjacency<idx> adj(n0, n1);}
\DoxyCodeLine{216   fill\_biadjacency<idx>(el, adj, policy);}
\DoxyCodeLine{217   \textcolor{keywordflow}{return} adj;}
\DoxyCodeLine{218 \}}
\DoxyCodeLine{219 }
\DoxyCodeLine{220 }
\DoxyCodeLine{221 \textcolor{comment}{//template <int idx, std::unsigned\_integral index\_type, std::unsigned\_integral vertex\_id\_type, typename... Attributes>}}
\DoxyCodeLine{222 \textcolor{comment}{//auto num\_vertices(const index\_adjacency<idx, index\_type, vertex\_id\_type, Attributes...>\& g) \{}}
\DoxyCodeLine{223 \textcolor{comment}{//  return g.num\_vertices();}}
\DoxyCodeLine{224 \textcolor{comment}{//\}}}
\DoxyCodeLine{225 \textcolor{comment}{//index\_adjacency num\_vertices CPO}}
\DoxyCodeLine{226 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} idx, std::unsigned\_integral index\_type, std::unsigned\_integral vertex\_id\_type, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{227 \textcolor{keyword}{auto} tag\_invoke(\textcolor{keyword}{const} num\_vertices\_tag, \textcolor{keyword}{const} index\_adjacency<idx, index\_type, vertex\_id\_type, Attributes...>\& g) \{}
\DoxyCodeLine{228   \textcolor{keywordflow}{return} g.num\_vertices()[0];}
\DoxyCodeLine{229 \}}
\DoxyCodeLine{230 \textcolor{comment}{//index\_adjacency degree CPO}}
\DoxyCodeLine{231 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} idx, std::unsigned\_integral index\_type, std::unsigned\_integral vertex\_id\_type, std::unsigned\_integral lookup\_type, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{232 \textcolor{keyword}{auto} tag\_invoke(\textcolor{keyword}{const} degree\_tag, \textcolor{keyword}{const} index\_adjacency<idx, index\_type, vertex\_id\_type, Attributes...>\& g, lookup\_type i) \{}
\DoxyCodeLine{233   \textcolor{keywordflow}{return} g[i].size();}
\DoxyCodeLine{234 \}}
\DoxyCodeLine{235 \textcolor{comment}{//index\_adjacency degree CPO}}
\DoxyCodeLine{236 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} idx, std::unsigned\_integral index\_type, std::unsigned\_integral vertex\_id\_type, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{237 \textcolor{keyword}{auto} tag\_invoke(\textcolor{keyword}{const} degree\_tag, \textcolor{keyword}{const} index\_adjacency<idx, index\_type, vertex\_id\_type, Attributes...>\& g,}
\DoxyCodeLine{238                 \textcolor{keyword}{const} \textcolor{keyword}{typename} index\_adjacency<idx, index\_type, vertex\_id\_type, Attributes...>::sub\_view\& v) \{}
\DoxyCodeLine{239   \textcolor{keywordflow}{return} v.size();}
\DoxyCodeLine{240 \}}
\DoxyCodeLine{241 \textcolor{comment}{//index\_biadjacency num\_vertices CPO}}
\DoxyCodeLine{242 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} idx, std::unsigned\_integral index\_type, std::unsigned\_integral vertex\_id\_type, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{243 \textcolor{keyword}{auto} tag\_invoke(\textcolor{keyword}{const} num\_vertices\_tag, \textcolor{keyword}{const} index\_biadjacency<idx, index\_type, vertex\_id\_type, Attributes...>\& g, \textcolor{keywordtype}{int} jdx = 0) \{}
\DoxyCodeLine{244   \textcolor{keywordflow}{return} g.num\_vertices()[jdx];}
\DoxyCodeLine{245 \}}
\DoxyCodeLine{246 \textcolor{comment}{//index\_biadjacency degree CPO}}
\DoxyCodeLine{247 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} idx, std::unsigned\_integral index\_type, std::unsigned\_integral vertex\_id\_type, std::unsigned\_integral lookup\_type, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{248 \textcolor{keyword}{auto} tag\_invoke(\textcolor{keyword}{const} degree\_tag, \textcolor{keyword}{const} index\_biadjacency<idx, index\_type, vertex\_id\_type, Attributes...>\& g, lookup\_type i) \{}
\DoxyCodeLine{249   \textcolor{keywordflow}{return} g[i].size();}
\DoxyCodeLine{250 \}}
\DoxyCodeLine{251 \textcolor{comment}{//index\_biadjacency degree CPO}}
\DoxyCodeLine{252 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} idx, std::unsigned\_integral index\_type, std::unsigned\_integral vertex\_id\_type, \textcolor{keyword}{typename}... Attributes>}
\DoxyCodeLine{253 \textcolor{keyword}{auto} tag\_invoke(\textcolor{keyword}{const} degree\_tag, \textcolor{keyword}{const} index\_biadjacency<idx, index\_type, vertex\_id\_type, Attributes...>\& g,}
\DoxyCodeLine{254                 \textcolor{keyword}{const} \textcolor{keyword}{typename} index\_biadjacency<idx, index\_type, vertex\_id\_type, Attributes...>::sub\_view\& v) \{}
\DoxyCodeLine{255   \textcolor{keywordflow}{return} v.size();}
\DoxyCodeLine{256 \}}
\DoxyCodeLine{257 \textcolor{comment}{//degree CPO}}
\DoxyCodeLine{258 \textcolor{keyword}{template} <\textcolor{keyword}{class} Iterator>}
\DoxyCodeLine{259 \textcolor{keyword}{auto} tag\_invoke(\textcolor{keyword}{const} degree\_tag, \textcolor{keyword}{const} splittable\_range\_adapter<Iterator>\& n) \{}
\DoxyCodeLine{260   \textcolor{keywordflow}{return} n.size();}
\DoxyCodeLine{261 \}}
\DoxyCodeLine{262 }
\DoxyCodeLine{263 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{264 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// NW\_GRAPH\_ADJACENCY\_HPP}}

\end{DoxyCode}
