\hypertarget{boykov__kolmogorov_8hpp_source}{}\doxysection{boykov\+\_\+kolmogorov.\+hpp}
\label{boykov__kolmogorov_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/boykov\_kolmogorov.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/boykov\_kolmogorov.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#ifndef BOYKOV\_KOLMOGOROV\_HPP}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define BOYKOV\_KOLMOGOROV\_HPP}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <queue>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <stack>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include "{}nwgraph/util/util.hpp"{}}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{26 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} INFINITE\_D = 100000000;}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{keyword}{enum class} tree\_mem : \textcolor{keywordtype}{bool} \{ source = \textcolor{keyword}{false}, term = \textcolor{keyword}{true} \};}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Graph>}
\DoxyCodeLine{33 std::tuple<double, std::vector<tree\_mem>> bk\_maxflow(\textcolor{keyword}{const} Graph\& A, std::vector<double>\& cap) \{}
\DoxyCodeLine{34   \textcolor{comment}{// std::clock\_t start;}}
\DoxyCodeLine{35   \textcolor{comment}{// double grow = 0;}}
\DoxyCodeLine{36   \textcolor{comment}{// double augment = 0;}}
\DoxyCodeLine{37   \textcolor{comment}{// double adopt = 0;}}
\DoxyCodeLine{38   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<Graph>;}
\DoxyCodeLine{39 }
\DoxyCodeLine{40   \textcolor{keywordtype}{size\_t}         n\_vtx    = A.size();}
\DoxyCodeLine{41   vertex\_id\_type source   = n\_vtx;}
\DoxyCodeLine{42   vertex\_id\_type terminal = source + 1;}
\DoxyCodeLine{43   \textcolor{keywordtype}{double}         max\_flow = 0.0;}
\DoxyCodeLine{44   \textcolor{keywordtype}{double}         tol      = 1e-\/12;}
\DoxyCodeLine{45   \textcolor{keywordtype}{size\_t}         gtime    = 0;}
\DoxyCodeLine{46 }
\DoxyCodeLine{47   std::queue<vertex\_id\_type>                active;}
\DoxyCodeLine{48   std::queue<vertex\_id\_type>                orphans;}
\DoxyCodeLine{49   std::vector<tree\_mem>                     tree\_id(n\_vtx);}
\DoxyCodeLine{50   std::vector<std::tuple<double*, double*>> trees(n\_vtx);}
\DoxyCodeLine{51   std::vector<vertex\_id\_type>               preds(n\_vtx, null\_vertex\_v);}
\DoxyCodeLine{52   std::vector<size\_t>                       timestamp(n\_vtx);}
\DoxyCodeLine{53   std::vector<size\_t>                       dist(n\_vtx);}
\DoxyCodeLine{54 }
\DoxyCodeLine{55   \textcolor{keywordtype}{double} *       residual\_cap, *back\_residual\_cap;}
\DoxyCodeLine{56   vertex\_id\_type connect\_s;}
\DoxyCodeLine{57   vertex\_id\_type connect\_t;}
\DoxyCodeLine{58   \textcolor{keywordtype}{double}         min\_cap;}
\DoxyCodeLine{59   \textcolor{keyword}{auto}           G = A.begin();}
\DoxyCodeLine{60 }
\DoxyCodeLine{61   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n\_vtx; ++i) \{}
\DoxyCodeLine{62     \textcolor{keywordflow}{if} (cap[i] > 0) \{}
\DoxyCodeLine{63       tree\_id[i] = tree\_mem::source;}
\DoxyCodeLine{64       preds[i]   = source;}
\DoxyCodeLine{65     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cap[i] < 0) \{}
\DoxyCodeLine{66       max\_flow += cap[i];}
\DoxyCodeLine{67       tree\_id[i] = tree\_mem::term;}
\DoxyCodeLine{68       preds[i]   = terminal;}
\DoxyCodeLine{69     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{70       \textcolor{keywordflow}{continue};}
\DoxyCodeLine{71     \}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73     dist[i]      = 1;}
\DoxyCodeLine{74     timestamp[i] = 0;}
\DoxyCodeLine{75     active.push(i);}
\DoxyCodeLine{76   \}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78   \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{}
\DoxyCodeLine{79     \textcolor{keywordtype}{bool} found = \textcolor{keyword}{false};}
\DoxyCodeLine{80     \textcolor{comment}{// start = std::clock();}}
\DoxyCodeLine{81     \textcolor{comment}{// Grow}}
\DoxyCodeLine{82     \textcolor{keywordflow}{while} (!active.empty()) \{}
\DoxyCodeLine{83       \textcolor{keyword}{auto} p = active.front();}
\DoxyCodeLine{84 }
\DoxyCodeLine{85       \textcolor{comment}{// This node was disconnected, so make it inactive}}
\DoxyCodeLine{86       \textcolor{keywordflow}{if} (preds[p] == null\_vertex\_v) \{}
\DoxyCodeLine{87         active.pop();}
\DoxyCodeLine{88         \textcolor{keywordflow}{continue};}
\DoxyCodeLine{89       \}}
\DoxyCodeLine{90 }
\DoxyCodeLine{91       tree\_mem t = tree\_id[p];}
\DoxyCodeLine{92 }
\DoxyCodeLine{93       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = G[p].begin(); it != G[p].end(); ++it) \{}
\DoxyCodeLine{94         \textcolor{keyword}{auto} q = std::get<0>(*it);}
\DoxyCodeLine{95 }
\DoxyCodeLine{96         \textcolor{keywordflow}{if} (t == tree\_mem::term) \{}
\DoxyCodeLine{97           \textcolor{comment}{// We are in the term tree, so we need to push flow "{}backwards"{}, which}}
\DoxyCodeLine{98           \textcolor{comment}{// is the residual capacity.}}
\DoxyCodeLine{99           \textcolor{comment}{// residual\_cap = std::get<2>(*it);}}
\DoxyCodeLine{100           residual\_cap = \&std::get<1>(A.get\_back\_edge(p, q));}
\DoxyCodeLine{101           \textcolor{keywordflow}{if} (*residual\_cap <= tol) \{}
\DoxyCodeLine{102             \textcolor{comment}{// No residual capacity}}
\DoxyCodeLine{103             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{104           \}}
\DoxyCodeLine{105           back\_residual\_cap = \&std::get<1>(*it);}
\DoxyCodeLine{106           \textcolor{comment}{// potential endpoint in the source tree}}
\DoxyCodeLine{107           connect\_s = q;}
\DoxyCodeLine{108           connect\_t = p;}
\DoxyCodeLine{109         \} \textcolor{keywordflow}{else} \{    \textcolor{comment}{// s-\/tree}}
\DoxyCodeLine{110           residual\_cap = \&std::get<1>(*it);}
\DoxyCodeLine{111           \textcolor{keywordflow}{if} (*residual\_cap <= tol) \{}
\DoxyCodeLine{112             \textcolor{comment}{// no residual capacity}}
\DoxyCodeLine{113             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{114           \}}
\DoxyCodeLine{115           \textcolor{comment}{// back\_residual\_cap = std::get<2>(*it);}}
\DoxyCodeLine{116           back\_residual\_cap = \&std::get<1>(A.get\_back\_edge(p, q));}
\DoxyCodeLine{117           connect\_s         = p;}
\DoxyCodeLine{118           \textcolor{comment}{// potential endpoint in the terminal tree}}
\DoxyCodeLine{119           connect\_t = q;}
\DoxyCodeLine{120         \}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122         \textcolor{comment}{// q is fresh (does not have a predecessor, not in the tree)}}
\DoxyCodeLine{123         \textcolor{keywordflow}{if} (preds[q] == null\_vertex\_v) \{}
\DoxyCodeLine{124           \textcolor{comment}{// Assign our tree to q}}
\DoxyCodeLine{125           tree\_id[q] = t;}
\DoxyCodeLine{126           \textcolor{comment}{// We are the predecessor now}}
\DoxyCodeLine{127           preds[q] = p;}
\DoxyCodeLine{128           trees[q] = std::make\_tuple(residual\_cap, back\_residual\_cap);}
\DoxyCodeLine{129           active.push(q);}
\DoxyCodeLine{130           timestamp[q] = timestamp[p];}
\DoxyCodeLine{131           dist[q]      = dist[p] + 1;}
\DoxyCodeLine{132         \}}
\DoxyCodeLine{133         \textcolor{comment}{// Found a connection because q is in the other tree.}}
\DoxyCodeLine{134         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (tree\_id[q] != t) \{}
\DoxyCodeLine{135           found = \textcolor{keyword}{true};}
\DoxyCodeLine{136           \textcolor{keywordflow}{break};}
\DoxyCodeLine{137         \}}
\DoxyCodeLine{138         \textcolor{comment}{// q is in the same tree}}
\DoxyCodeLine{139         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (timestamp[q] <= timestamp[p] \&\& dist[q] > dist[p]) \{}
\DoxyCodeLine{140           preds[q]     = p;}
\DoxyCodeLine{141           trees[q]     = std::make\_tuple(residual\_cap, back\_residual\_cap);}
\DoxyCodeLine{142           timestamp[q] = timestamp[p];}
\DoxyCodeLine{143           dist[q]      = dist[p] + 1;}
\DoxyCodeLine{144         \}}
\DoxyCodeLine{145       \}}
\DoxyCodeLine{146 }
\DoxyCodeLine{147       gtime++;}
\DoxyCodeLine{148 }
\DoxyCodeLine{149       \textcolor{keywordflow}{if} (found) \textcolor{keywordflow}{break};}
\DoxyCodeLine{150 }
\DoxyCodeLine{151       active.pop();}
\DoxyCodeLine{152     \}}
\DoxyCodeLine{153 }
\DoxyCodeLine{154     \textcolor{keywordflow}{if} (!found) \textcolor{keywordflow}{break};}
\DoxyCodeLine{155 }
\DoxyCodeLine{156     \textcolor{comment}{// grow += (std::clock() -\/ start);}}
\DoxyCodeLine{157     \textcolor{comment}{// start = std::clock();}}
\DoxyCodeLine{158     \textcolor{comment}{// Augment}}
\DoxyCodeLine{159     min\_cap = *residual\_cap;}
\DoxyCodeLine{160     \textcolor{comment}{// Search the t-\/tree for min capacity}}
\DoxyCodeLine{161     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} vtx = connect\_t; vtx != terminal; vtx = preds[vtx]) \{}
\DoxyCodeLine{162       \textcolor{keywordflow}{if} (preds[vtx] == terminal) \{}
\DoxyCodeLine{163         min\_cap = std::min(min\_cap, -\/cap[vtx]);}
\DoxyCodeLine{164       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{165         \textcolor{keyword}{auto} edge = trees[vtx];}
\DoxyCodeLine{166         min\_cap   = std::min(min\_cap, *std::get<0>(edge));}
\DoxyCodeLine{167       \}}
\DoxyCodeLine{168     \}}
\DoxyCodeLine{169     \textcolor{comment}{// Search the s-\/tree for min capacity}}
\DoxyCodeLine{170     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} vtx = connect\_s; vtx != source; vtx = preds[vtx]) \{}
\DoxyCodeLine{171       \textcolor{keywordflow}{if} (preds[vtx] == source) \{}
\DoxyCodeLine{172         min\_cap = std::min(min\_cap, cap[vtx]);}
\DoxyCodeLine{173       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{174         \textcolor{keyword}{auto} edge = trees[vtx];}
\DoxyCodeLine{175         min\_cap   = std::min(min\_cap, *std::get<0>(edge));}
\DoxyCodeLine{176       \}}
\DoxyCodeLine{177     \}}
\DoxyCodeLine{178 }
\DoxyCodeLine{179     max\_flow += min\_cap;}
\DoxyCodeLine{180     *residual\_cap -\/= min\_cap;}
\DoxyCodeLine{181     *back\_residual\_cap += min\_cap;}
\DoxyCodeLine{182     \textcolor{comment}{// auto vtx = connect\_t, next = preds[vtx]; vtx != terminal; vtx = next,}}
\DoxyCodeLine{183     \textcolor{comment}{// next = preds[vtx]}}
\DoxyCodeLine{184     \textcolor{comment}{// Update t-\/tree}}
\DoxyCodeLine{185     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} vtx = connect\_t, next = preds[vtx]; vtx != terminal; vtx = next) \{}
\DoxyCodeLine{186       next = preds[vtx];}
\DoxyCodeLine{187       \textcolor{keywordflow}{if} (next == terminal) \{}
\DoxyCodeLine{188         cap[vtx] += min\_cap;}
\DoxyCodeLine{189         \textcolor{keywordflow}{if} (cap[vtx] >= 0) \{}
\DoxyCodeLine{190           preds[vtx] = null\_vertex\_v;}
\DoxyCodeLine{191           orphans.push(vtx);}
\DoxyCodeLine{192         \}}
\DoxyCodeLine{193       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{194         \textcolor{keyword}{auto} edge = trees[vtx];}
\DoxyCodeLine{195         *std::get<0>(edge) -\/= min\_cap;}
\DoxyCodeLine{196         *std::get<1>(edge) += min\_cap;}
\DoxyCodeLine{197         \textcolor{keywordflow}{if} (*std::get<0>(edge) <= 0) \{}
\DoxyCodeLine{198           preds[vtx] = null\_vertex\_v;}
\DoxyCodeLine{199           orphans.push(vtx);}
\DoxyCodeLine{200         \}}
\DoxyCodeLine{201       \}}
\DoxyCodeLine{202     \}}
\DoxyCodeLine{203     \textcolor{comment}{// Update s-\/tree}}
\DoxyCodeLine{204     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} vtx = connect\_s, next = preds[vtx]; vtx != source; vtx = next) \{}
\DoxyCodeLine{205       next = preds[vtx];}
\DoxyCodeLine{206       \textcolor{keywordflow}{if} (next == source) \{}
\DoxyCodeLine{207         cap[vtx] -\/= min\_cap;}
\DoxyCodeLine{208         \textcolor{keywordflow}{if} (cap[vtx] <= 0) \{}
\DoxyCodeLine{209           preds[vtx] = null\_vertex\_v;}
\DoxyCodeLine{210           orphans.push(vtx);}
\DoxyCodeLine{211         \}}
\DoxyCodeLine{212       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{213         \textcolor{keyword}{auto} edge = trees[vtx];}
\DoxyCodeLine{214         *std::get<0>(edge) -\/= min\_cap;}
\DoxyCodeLine{215         *std::get<1>(edge) += min\_cap;}
\DoxyCodeLine{216         \textcolor{keywordflow}{if} (*std::get<0>(edge) <= 0) \{}
\DoxyCodeLine{217           preds[vtx] = null\_vertex\_v;}
\DoxyCodeLine{218           orphans.push(vtx);}
\DoxyCodeLine{219         \}}
\DoxyCodeLine{220       \}}
\DoxyCodeLine{221     \}}
\DoxyCodeLine{222 }
\DoxyCodeLine{223     \textcolor{comment}{// augment += (std::clock() -\/ start);}}
\DoxyCodeLine{224     \textcolor{comment}{// start = std::clock();}}
\DoxyCodeLine{225     \textcolor{comment}{// Adopt}}
\DoxyCodeLine{226     \textcolor{keywordflow}{while} (!orphans.empty()) \{}
\DoxyCodeLine{227       \textcolor{keyword}{auto} p = orphans.front();}
\DoxyCodeLine{228       orphans.pop();}
\DoxyCodeLine{229 }
\DoxyCodeLine{230       tree\_mem                     t = tree\_id[p];}
\DoxyCodeLine{231       vertex\_id\_type               min\_pred\{null\_vertex\_v\};}
\DoxyCodeLine{232       \textcolor{keywordtype}{size\_t}                       d\_min = INFINITE\_D;}
\DoxyCodeLine{233       std::tuple<double*, double*> min\_edge;}
\DoxyCodeLine{234 }
\DoxyCodeLine{235       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = G[p].begin(); it != G[p].end(); ++it) \{}
\DoxyCodeLine{236         vertex\_id\_type q = std::get<0>(*it);}
\DoxyCodeLine{237         vertex\_id\_type target;}
\DoxyCodeLine{238         \textcolor{keywordtype}{size\_t}         d = 0;}
\DoxyCodeLine{239 }
\DoxyCodeLine{240         \textcolor{keywordflow}{if} (tree\_id[q] != t || preds[q] == p) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{241 }
\DoxyCodeLine{242         \textcolor{keywordflow}{if} (t == tree\_mem::term) \{}
\DoxyCodeLine{243           residual\_cap = \&std::get<1>(*it);}
\DoxyCodeLine{244           \textcolor{keywordflow}{if} (*residual\_cap <= tol) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{245           \textcolor{comment}{// back\_residual\_cap = std::get<2>(*it);}}
\DoxyCodeLine{246           back\_residual\_cap = \&std::get<1>(A.get\_back\_edge(p, q));}
\DoxyCodeLine{247           target            = terminal;}
\DoxyCodeLine{248         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{249           \textcolor{comment}{// residual\_cap = std::get<2>(*it);}}
\DoxyCodeLine{250           residual\_cap = \&std::get<1>(A.get\_back\_edge(p, q));}
\DoxyCodeLine{251           \textcolor{keywordflow}{if} (*residual\_cap <= tol) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{252           back\_residual\_cap = \&std::get<1>(*it);}
\DoxyCodeLine{253           target            = source;}
\DoxyCodeLine{254         \}}
\DoxyCodeLine{255 }
\DoxyCodeLine{256         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} vtx = q; vtx != target; vtx = preds[vtx]) \{}
\DoxyCodeLine{257           \textcolor{keywordflow}{if} (timestamp[vtx] == gtime) \{}
\DoxyCodeLine{258             d += dist[vtx];}
\DoxyCodeLine{259             \textcolor{keywordflow}{break};}
\DoxyCodeLine{260           \}}
\DoxyCodeLine{261 }
\DoxyCodeLine{262           d++;}
\DoxyCodeLine{263 }
\DoxyCodeLine{264           \textcolor{keywordflow}{if} (preds[vtx] == target) \{}
\DoxyCodeLine{265             timestamp[vtx] = gtime;}
\DoxyCodeLine{266             dist[vtx]      = 1;}
\DoxyCodeLine{267             \textcolor{keywordflow}{break};}
\DoxyCodeLine{268           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (preds[vtx] == null\_vertex\_v) \{}
\DoxyCodeLine{269             d = INFINITE\_D;}
\DoxyCodeLine{270             \textcolor{keywordflow}{break};}
\DoxyCodeLine{271           \}}
\DoxyCodeLine{272         \}}
\DoxyCodeLine{273 }
\DoxyCodeLine{274         \textcolor{keywordflow}{if} (d < INFINITE\_D) \{}
\DoxyCodeLine{275           \textcolor{keywordflow}{if} (d < d\_min) \{}
\DoxyCodeLine{276             min\_pred = q;}
\DoxyCodeLine{277             min\_edge = std::make\_tuple(residual\_cap, back\_residual\_cap);}
\DoxyCodeLine{278             d\_min    = d;}
\DoxyCodeLine{279           \}}
\DoxyCodeLine{280 }
\DoxyCodeLine{281           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} vtx = q; vtx != target; vtx = preds[vtx]) \{}
\DoxyCodeLine{282             \textcolor{keywordflow}{if} (timestamp[vtx] == gtime) \textcolor{keywordflow}{break};}
\DoxyCodeLine{283 }
\DoxyCodeLine{284             timestamp[vtx] = gtime;}
\DoxyCodeLine{285             dist[vtx]      = d-\/-\/;}
\DoxyCodeLine{286           \}}
\DoxyCodeLine{287         \}}
\DoxyCodeLine{288       \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290       \textcolor{comment}{// can't find new parent}}
\DoxyCodeLine{291       \textcolor{keywordflow}{if} (min\_pred == null\_vertex\_v) \{}
\DoxyCodeLine{292         timestamp[p] = 0;}
\DoxyCodeLine{293 }
\DoxyCodeLine{294         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = G[p].begin(); it != G[p].end(); ++it) \{}
\DoxyCodeLine{295           \textcolor{keyword}{auto} q = std::get<0>(*it);}
\DoxyCodeLine{296 }
\DoxyCodeLine{297           \textcolor{keywordflow}{if} (tree\_id[q] != t) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{298 }
\DoxyCodeLine{299           \textcolor{keywordflow}{if} (tree\_id[q] == tree\_mem::source \&\& std::get<1>(*it) > tol) \{}
\DoxyCodeLine{300             active.push(q);}
\DoxyCodeLine{301           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (tree\_id[q] == tree\_mem::term \&\& std::get<1>(A.get\_back\_edge(p, q)) > tol) \{}
\DoxyCodeLine{302             active.push(q);}
\DoxyCodeLine{303           \}}
\DoxyCodeLine{304 }
\DoxyCodeLine{305           \textcolor{keywordflow}{if} (preds[q] == p) \{}
\DoxyCodeLine{306             orphans.push(q);}
\DoxyCodeLine{307             preds[q] = null\_vertex\_v;}
\DoxyCodeLine{308           \}}
\DoxyCodeLine{309         \}}
\DoxyCodeLine{310       \}}
\DoxyCodeLine{311       \textcolor{comment}{// Found parent}}
\DoxyCodeLine{312       \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{313         preds[p]     = min\_pred;}
\DoxyCodeLine{314         trees[p]     = min\_edge;}
\DoxyCodeLine{315         timestamp[p] = gtime;}
\DoxyCodeLine{316         dist[p]      = d\_min + 1;}
\DoxyCodeLine{317       \}}
\DoxyCodeLine{318     \}}
\DoxyCodeLine{319     \textcolor{comment}{// adopt += (std::clock() -\/ start);}}
\DoxyCodeLine{320   \}}
\DoxyCodeLine{321   \textcolor{comment}{/*std::cout << "{}grow time: "{} << grow / (double) CLOCKS\_PER\_SEC <<}}
\DoxyCodeLine{322 \textcolor{comment}{    "{} augment time: "{} << augment / (double) CLOCKS\_PER\_SEC <<}}
\DoxyCodeLine{323 \textcolor{comment}{    "{} adopt time: "{} << adopt / (double) CLOCKS\_PER\_SEC << std::endl;*/}}
\DoxyCodeLine{324   \textcolor{comment}{// std::cout << augment\_ct << "{} aguments"{} << std::endl;}}
\DoxyCodeLine{325   \textcolor{comment}{// std::cout << path\_length*(1.0)/augment\_ct << "{} avg path length"{} <<}}
\DoxyCodeLine{326   \textcolor{comment}{// std::endl;}}
\DoxyCodeLine{327   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n\_vtx; ++i) \{}
\DoxyCodeLine{328     \textcolor{keywordflow}{if} (preds[i] == null\_vertex\_v) \{}
\DoxyCodeLine{329       tree\_id[i] = tree\_mem::term;}
\DoxyCodeLine{330     \}}
\DoxyCodeLine{331   \}}
\DoxyCodeLine{332   \textcolor{keywordflow}{return} std::make\_tuple(max\_flow, tree\_id);}
\DoxyCodeLine{333 \}}
\DoxyCodeLine{334 }
\DoxyCodeLine{335 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{336 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{337 }
\DoxyCodeLine{338 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// BOYKOV\_KOLMOGOROV\_HPP}}

\end{DoxyCode}
