\hypertarget{util_8hpp_source}{}\doxysection{util.\+hpp}
\label{util_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/util/util.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/util/util.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_UTIL\_HPP}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#define NW\_GRAPH\_UTIL\_HPP}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <atomic>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <numeric>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include "{}nwgraph/util/traits.hpp"{}}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{29 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{30 }
\DoxyCodeLine{31 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = std::\textcolor{keywordtype}{size\_t}>}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1counting__output__iterator}{counting\_output\_iterator}} : \textcolor{keyword}{public} std::iterator<std::output\_iterator\_tag, std::ptrdiff\_t> \{}
\DoxyCodeLine{34 \textcolor{keyword}{public}:}
\DoxyCodeLine{35   \mbox{\hyperlink{classnw_1_1graph_1_1counting__output__iterator}{counting\_output\_iterator}}(T\& count) : count\{count\} \{\}}
\DoxyCodeLine{36 }
\DoxyCodeLine{37   \mbox{\hyperlink{classnw_1_1graph_1_1counting__output__iterator}{counting\_output\_iterator}}\& operator++() \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{38   \mbox{\hyperlink{classnw_1_1graph_1_1counting__output__iterator}{counting\_output\_iterator}}\& operator++(\textcolor{keywordtype}{int}) \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{39   \mbox{\hyperlink{classnw_1_1graph_1_1counting__output__iterator}{counting\_output\_iterator}}\& operator*() \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{40   \mbox{\hyperlink{classnw_1_1graph_1_1counting__output__iterator}{counting\_output\_iterator}}\& operator[](std::ptrdiff\_t) \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42   \textcolor{comment}{// counting\_output\_iterator\& operator=(const counting\_output\_iterator\&) = delete;}}
\DoxyCodeLine{43   \textcolor{comment}{// counting\_output\_iterator\& operator=(counting\_output\_iterator\&\&) = delete;}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{46   \textcolor{keyword}{auto}\& operator=(U) \{}
\DoxyCodeLine{47     count++;}
\DoxyCodeLine{48     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{49   \}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51   \textcolor{keyword}{auto} get\_count() \{ \textcolor{keywordflow}{return} count; \}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{keyword}{private}:}
\DoxyCodeLine{54   T\& count;}
\DoxyCodeLine{55 \};}
\DoxyCodeLine{56 }
\DoxyCodeLine{60 \textcolor{keyword}{struct }\mbox{\hyperlink{structnw_1_1graph_1_1max}{max}} \{}
\DoxyCodeLine{61   \textcolor{keyword}{template} <\textcolor{keyword}{class} U, \textcolor{keyword}{class} V>}
\DoxyCodeLine{62   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator()(U\&\& lhs, V\&\& rhs)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{63     \textcolor{keywordflow}{return} std::max(std::forward<U>(lhs), std::forward<V>(rhs));}
\DoxyCodeLine{64   \}}
\DoxyCodeLine{65 \};}
\DoxyCodeLine{66 }
\DoxyCodeLine{70 \textcolor{keyword}{struct }\mbox{\hyperlink{structnw_1_1graph_1_1min}{min}} \{}
\DoxyCodeLine{71   \textcolor{keyword}{template} <\textcolor{keyword}{class} U, \textcolor{keyword}{class} V>}
\DoxyCodeLine{72   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator()(U\&\& lhs, V\&\& rhs)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{73     \textcolor{keywordflow}{return} std::min(std::forward<U>(lhs), std::forward<V>(rhs));}
\DoxyCodeLine{74   \}}
\DoxyCodeLine{75 \};}
\DoxyCodeLine{76 }
\DoxyCodeLine{84 \textcolor{keyword}{template} <\textcolor{keyword}{class} T = std::\textcolor{keywordtype}{size\_t}>}
\DoxyCodeLine{85 \textcolor{keyword}{struct }\mbox{\hyperlink{structnw_1_1graph_1_1counter}{counter}} : \textcolor{keyword}{public} std::iterator<std::output\_iterator\_tag, std::ptrdiff\_t> \{}
\DoxyCodeLine{86   T count;}
\DoxyCodeLine{87 }
\DoxyCodeLine{88   \mbox{\hyperlink{structnw_1_1graph_1_1counter}{counter}}(T init = \{\}) : count(init) \{\}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90   \textcolor{keyword}{constexpr} \textcolor{keyword}{operator} T()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} count; \}}
\DoxyCodeLine{91 }
\DoxyCodeLine{92   \mbox{\hyperlink{structnw_1_1graph_1_1counter}{counter}}\& operator++() \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{93   \mbox{\hyperlink{structnw_1_1graph_1_1counter}{counter}}\& operator++(\textcolor{keywordtype}{int}) \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{94   \mbox{\hyperlink{structnw_1_1graph_1_1counter}{counter}}\& operator*() \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{95 }
\DoxyCodeLine{96   \textcolor{keyword}{template} <\textcolor{keyword}{class} U>}
\DoxyCodeLine{97   \textcolor{keyword}{decltype}(\textcolor{keyword}{auto}) \textcolor{keyword}{operator}=(U) \{}
\DoxyCodeLine{98     ++count;}
\DoxyCodeLine{99     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{100   \}}
\DoxyCodeLine{101 \};}
\DoxyCodeLine{102 }
\DoxyCodeLine{112 \textcolor{keyword}{template} <std::size\_t... Is, \textcolor{keyword}{class }Tuple, \textcolor{keyword}{class }= std::enable\_if\_t<is\_tuple\_v<std::decay\_t<Tuple>>>>}
\DoxyCodeLine{113 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} select(Tuple\&\& t) -\/> std::tuple<std::tuple\_element\_t<Is, std::decay\_t<Tuple>>...> \{}
\DoxyCodeLine{114   \textcolor{keyword}{static\_assert}(((Is < std::tuple\_size\_v<std::decay\_t<Tuple>>)\&\&...), \textcolor{stringliteral}{"{}tuple index out of range during select"{}});}
\DoxyCodeLine{115   \textcolor{keywordflow}{return} \{std::forward<std::tuple\_element\_t<Is, std::decay\_t<Tuple>>>(std::get<Is>(std::forward<Tuple>(t)))...\};}
\DoxyCodeLine{116 \}}
\DoxyCodeLine{117 }
\DoxyCodeLine{119 \textcolor{keyword}{template} <\textcolor{keyword}{class }Tuple, std::size\_t... Is>}
\DoxyCodeLine{120 \textcolor{keyword}{using} select\_t = \textcolor{keyword}{decltype}(select<Is...>(std::declval<Tuple>()));}
\DoxyCodeLine{121 }
\DoxyCodeLine{122 \textcolor{keyword}{template} <\textcolor{keyword}{typename} vertex\_\textcolor{keywordtype}{id}\_type>}
\DoxyCodeLine{123 \textcolor{keyword}{struct }\mbox{\hyperlink{structnw_1_1graph_1_1null__vertex__s}{null\_vertex\_s}} \{}
\DoxyCodeLine{124   \textcolor{keyword}{constexpr} \textcolor{keyword}{static} vertex\_id\_type value = std::numeric\_limits<vertex\_id\_type>::max();}
\DoxyCodeLine{125 \};}
\DoxyCodeLine{126 }
\DoxyCodeLine{127 \textcolor{keyword}{template} <\textcolor{keyword}{typename} vertex\_\textcolor{keywordtype}{id}\_type>}
\DoxyCodeLine{128 \textcolor{keyword}{inline} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} null\_vertex\_v() \{}
\DoxyCodeLine{129   \textcolor{keywordflow}{return} \mbox{\hyperlink{structnw_1_1graph_1_1null__vertex__s}{null\_vertex\_s<vertex\_id\_type>::value}};}
\DoxyCodeLine{130 \}}
\DoxyCodeLine{131 }
\DoxyCodeLine{132 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} RandomAccessIterator,}
\DoxyCodeLine{133           \textcolor{keyword}{typename} = std::enable\_if\_t<nw::graph::is\_tuple\_v<typename InputIterator::value\_type>>>}
\DoxyCodeLine{134 \textcolor{keywordtype}{void} histogram(InputIterator first, InputIterator last, RandomAccessIterator o\_first, RandomAccessIterator o\_last, \textcolor{keywordtype}{size\_t} idx = 0) \{}
\DoxyCodeLine{135   std::fill(o\_first, o\_last, 0);}
\DoxyCodeLine{136   std::for\_each(first, last, [\&](\textcolor{keyword}{auto}\& i) \{ o\_first[std::get<idx>(i)]++; \});}
\DoxyCodeLine{137 \};}
\DoxyCodeLine{138 }
\DoxyCodeLine{139 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} RandomAccessIterator>}
\DoxyCodeLine{140 \textcolor{keywordtype}{void} histogram(InputIterator first, InputIterator last, RandomAccessIterator o\_first, RandomAccessIterator o\_last) \{}
\DoxyCodeLine{141   std::fill(o\_first, o\_last, 0);}
\DoxyCodeLine{142   std::for\_each(first, last, [\&](\textcolor{keyword}{auto}\& i) \{ o\_first[i]++; \});}
\DoxyCodeLine{143 \};}
\DoxyCodeLine{144 }
\DoxyCodeLine{145 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{146 \textcolor{keyword}{constexpr} \textcolor{keyword}{typename} std::underlying\_type<T>::type idx(T value) \{}
\DoxyCodeLine{147   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}typename std::underlying\_type<T>::type\textcolor{keyword}{>}(value);}
\DoxyCodeLine{148 \}}
\DoxyCodeLine{149 }
\DoxyCodeLine{150 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OuterIter>}
\DoxyCodeLine{151 \textcolor{keyword}{auto} get\_source(OuterIter\& outer) \{}
\DoxyCodeLine{152   \textcolor{keywordflow}{return} outer.get\_index();}
\DoxyCodeLine{153 \};}
\DoxyCodeLine{154 }
\DoxyCodeLine{155 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerIter>}
\DoxyCodeLine{156 \textcolor{keyword}{auto} get\_target(InnerIter\& inner) \{}
\DoxyCodeLine{157   \textcolor{keywordflow}{return} std::get<0>(*inner);}
\DoxyCodeLine{158 \};}
\DoxyCodeLine{159 }
\DoxyCodeLine{160 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} Idx, \textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{161 \textcolor{keyword}{auto} property(Iterator\& inner) \{}
\DoxyCodeLine{162   \textcolor{keywordflow}{return} std::get<Idx>(*inner);}
\DoxyCodeLine{163 \}}
\DoxyCodeLine{164 }
\DoxyCodeLine{165 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} Idx, \textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{166 \textcolor{keyword}{auto} property\_ptr(Iterator\& inner) \{}
\DoxyCodeLine{167   \textcolor{keywordflow}{return} \&std::get<Idx>(*inner);}
\DoxyCodeLine{168 \}}
\DoxyCodeLine{169 }
\DoxyCodeLine{172 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} log2(uint64\_t val) \{}
\DoxyCodeLine{173   assert(val);}
\DoxyCodeLine{174   \textcolor{keywordflow}{return} ((\textcolor{keyword}{sizeof}(val) * 8 -\/ 1) -\/ \_\_builtin\_clzl(val));}
\DoxyCodeLine{175 \}}
\DoxyCodeLine{176 }
\DoxyCodeLine{178 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} ceil\_log2(uint32\_t val) \{}
\DoxyCodeLine{179   assert(val);}
\DoxyCodeLine{180   \textcolor{keywordflow}{return} ((\textcolor{keyword}{sizeof}(val) * 8 -\/ 1) -\/ \_\_builtin\_clz(val)) + (!!(val \& (val -\/ 1)));}
\DoxyCodeLine{181 \}}
\DoxyCodeLine{182 }
\DoxyCodeLine{183 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} ceil\_log2(int32\_t val) \{}
\DoxyCodeLine{184   assert(0 < val);}
\DoxyCodeLine{185   \textcolor{keywordflow}{return} ceil\_log2(uint32\_t(val));}
\DoxyCodeLine{186 \}}
\DoxyCodeLine{187 }
\DoxyCodeLine{189 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} ceil\_log2(uint64\_t val) \{}
\DoxyCodeLine{190   assert(val);}
\DoxyCodeLine{191   \textcolor{keywordflow}{return} ((\textcolor{keyword}{sizeof}(val) * 8 -\/ 1) -\/ \_\_builtin\_clzl(val)) + (!!(val \& (val -\/ 1)));}
\DoxyCodeLine{192 \}}
\DoxyCodeLine{193 }
\DoxyCodeLine{195 \textcolor{keyword}{template} <\textcolor{keyword}{class} T = u\textcolor{keywordtype}{int}64\_t>}
\DoxyCodeLine{196 \textcolor{keyword}{static} \textcolor{keyword}{constexpr} T pow2(\textcolor{keywordtype}{int} exp) \{}
\DoxyCodeLine{197   \textcolor{keyword}{static\_assert}(std::is\_integral\_v<T>, \textcolor{stringliteral}{"{}pow2 only returns integer types"{}});}
\DoxyCodeLine{198   assert(0 <= exp and exp < (\textcolor{keywordtype}{int})(8 * \textcolor{keyword}{sizeof}(T) -\/ 1));}
\DoxyCodeLine{199   \textcolor{keywordflow}{return} (T(1) << exp);}
\DoxyCodeLine{200 \}}
\DoxyCodeLine{201 }
\DoxyCodeLine{206 \textcolor{keyword}{template} <\textcolor{keyword}{class} T, \textcolor{keyword}{class} U, \textcolor{keyword}{class} V>}
\DoxyCodeLine{207 \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::pair<T, T> block(T N, U n, V \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{208   \textcolor{keyword}{auto} r     = N \% n;                                 \textcolor{comment}{// remainder for block size}}
\DoxyCodeLine{209   \textcolor{keyword}{auto} b     = N / n;                                 \textcolor{comment}{// basic block size}}
\DoxyCodeLine{210   \textcolor{keyword}{auto} begin = \textcolor{keywordtype}{id} * b + std::min(\textcolor{keywordtype}{id}, r);              \textcolor{comment}{// block min}}
\DoxyCodeLine{211   \textcolor{keyword}{auto} end   = (\textcolor{keywordtype}{id} + 1) * b + std::min(\textcolor{keywordtype}{id} + 1, r);    \textcolor{comment}{// block max}}
\DoxyCodeLine{212   assert(\textcolor{keywordtype}{id} != 0 || begin == 0);                      \textcolor{comment}{// first range should start at 0}}
\DoxyCodeLine{213   assert(\textcolor{keywordtype}{id} != (N -\/ 1) || end == N);                  \textcolor{comment}{// last range should end at N}}
\DoxyCodeLine{214   \textcolor{keywordflow}{return} std::pair(begin, end);}
\DoxyCodeLine{215 \}}
\DoxyCodeLine{216 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{217 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{218 }
\DoxyCodeLine{219 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// NW\_GRAPH\_UTIL\_HPP}}

\end{DoxyCode}
