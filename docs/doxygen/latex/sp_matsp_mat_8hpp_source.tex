\hypertarget{sp_matsp_mat_8hpp_source}{}\doxysection{sp\+Matsp\+Mat.\+hpp}
\label{sp_matsp_mat_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/spMatspMat.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/spMatspMat.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine}}
\DoxyCodeLine{10 \textcolor{comment}{//     Scott McMillan}}
\DoxyCodeLine{11 \textcolor{comment}{//     Kevin Deweese}}
\DoxyCodeLine{12 \textcolor{comment}{//}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_SPMATSPMAT\_HPP}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#define NW\_GRAPH\_SPMATSPMAT\_HPP}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/plain\_range.hpp"{}}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include "{}nwgraph/edge\_list.hpp"{}}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include "{}nwgraph/util/util.hpp"{}}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{26 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{comment}{//****************************************************************************}}
\DoxyCodeLine{29 \textcolor{comment}{// A * B}}
\DoxyCodeLine{30 \textcolor{comment}{//****************************************************************************}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{comment}{//****************************************************************************}}
\DoxyCodeLine{35 \textcolor{comment}{}\textcolor{keyword}{template} <\textcolor{keyword}{typename} ScalarT, adjacency\_list\_graph LGraphT, adjacency\_list\_graph RGraphT, }
\DoxyCodeLine{36       \textcolor{keyword}{typename} MapOpT = std::multiplies<ScalarT>, \textcolor{keyword}{typename} ReduceOpT = std::plus<ScalarT>>}
\DoxyCodeLine{37 edge\_list<directedness::directed, ScalarT> spMatspMat(\textcolor{keyword}{const} LGraphT\& A, \textcolor{keyword}{const} RGraphT\& B) \{}
\DoxyCodeLine{38   edge\_list<directedness::directed, ScalarT> edges(0);}
\DoxyCodeLine{39   edges.open\_for\_push\_back();}
\DoxyCodeLine{40 }
\DoxyCodeLine{41   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<LGraphT>;}
\DoxyCodeLine{42 }
\DoxyCodeLine{43   \textcolor{keywordflow}{for} (vertex\_id\_type i = 0; i < num\_vertices(A); ++i)  \{}
\DoxyCodeLine{44 }
\DoxyCodeLine{45     std::map<size\_t, ScalarT> Ci\_tmp;}
\DoxyCodeLine{46 }
\DoxyCodeLine{47     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \&\& [k, a\_ik] : A[i]) \{}
\DoxyCodeLine{48       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \&\& [j, b\_kj] : B[k]) \{}
\DoxyCodeLine{49     }
\DoxyCodeLine{50         \textcolor{comment}{// TODO: Do we really want semiring support.  If so,}}
\DoxyCodeLine{51         \textcolor{comment}{// what is best way to deal with additive identity?}}
\DoxyCodeLine{52         ScalarT tmp = MapOpT()(a\_ik, b\_kj);    \textcolor{comment}{// C\_ij partial product}}
\DoxyCodeLine{53     }
\DoxyCodeLine{54         \textcolor{keywordflow}{if} (Ci\_tmp.find(j) != Ci\_tmp.end()) \{}
\DoxyCodeLine{55           Ci\_tmp[j] = ReduceOpT()(Ci\_tmp[j], tmp);}
\DoxyCodeLine{56         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{57           Ci\_tmp[j] = tmp;}
\DoxyCodeLine{58         \}}
\DoxyCodeLine{59       \}}
\DoxyCodeLine{60     \}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62     \textcolor{comment}{// extract from the map and put in edge\_list}}
\DoxyCodeLine{63     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} elt : Ci\_tmp) \{}
\DoxyCodeLine{64       edges.push\_back(i, elt.first, elt.second);}
\DoxyCodeLine{65     \}}
\DoxyCodeLine{66   \}}
\DoxyCodeLine{67 }
\DoxyCodeLine{68   edges.close\_for\_push\_back();}
\DoxyCodeLine{69 }
\DoxyCodeLine{70   \textcolor{comment}{// sort\_by<0>(edges);  // They should be already sorted}}
\DoxyCodeLine{71   \textcolor{keywordflow}{return} edges;}
\DoxyCodeLine{72 \}}
\DoxyCodeLine{73 }
\DoxyCodeLine{74 \textcolor{comment}{//****************************************************************************}}
\DoxyCodeLine{75 \textcolor{comment}{// A * B'}}
\DoxyCodeLine{76 \textcolor{comment}{//****************************************************************************}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78 \textcolor{comment}{//****************************************************************************}}
\DoxyCodeLine{79 \textcolor{comment}{// map}}
\DoxyCodeLine{80 \textcolor{keyword}{template} <\textcolor{keyword}{class} InputIt1, \textcolor{keyword}{class} InputIt2, \textcolor{keyword}{class} Output, \textcolor{keyword}{class} Compare, \textcolor{keyword}{class} Map>}
\DoxyCodeLine{81 \textcolor{keywordtype}{void} set\_ewise\_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Output\& container, Compare comp, Map map) \{}
\DoxyCodeLine{82   \textcolor{keywordflow}{while} (first1 != last1 \&\& first2 != last2) \{}
\DoxyCodeLine{83     \textcolor{keywordflow}{if} (comp(*first1, *first2)) \{}
\DoxyCodeLine{84       ++first1;}
\DoxyCodeLine{85     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{86       \textcolor{keywordflow}{if} (!comp(*first2, *first1)) \{}
\DoxyCodeLine{87         container.push\_back(map(*first1, *first2));}
\DoxyCodeLine{88         \textcolor{comment}{// std::cout << "{}map = "{} << map(*first1, *first2) << std::endl;}}
\DoxyCodeLine{89         ++first1;}
\DoxyCodeLine{90       \}}
\DoxyCodeLine{91       ++first2;}
\DoxyCodeLine{92     \}}
\DoxyCodeLine{93   \}}
\DoxyCodeLine{94 \}}
\DoxyCodeLine{95 }
\DoxyCodeLine{96 \textcolor{comment}{//****************************************************************************}}
\DoxyCodeLine{98 \textcolor{comment}{}\textcolor{keyword}{template} <\textcolor{keyword}{typename} ScalarT, adjacency\_list\_graph LGraphT, adjacency\_list\_graph RGraphT, \textcolor{keyword}{typename} MapOpT = std::multiplies<ScalarT>,}
\DoxyCodeLine{99           \textcolor{keyword}{typename} ReduceOpT = std::plus<ScalarT>>}
\DoxyCodeLine{100 edge\_list<directedness::directed, ScalarT> spMatspMatT(LGraphT\& A, RGraphT\& BT) \{}
\DoxyCodeLine{101   std::vector<ScalarT> products;}
\DoxyCodeLine{102 }
\DoxyCodeLine{103   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<LGraphT>;}
\DoxyCodeLine{104 }
\DoxyCodeLine{105   edge\_list<directedness::directed, ScalarT> edges(0);}
\DoxyCodeLine{106   edges.open\_for\_push\_back();}
\DoxyCodeLine{107 }
\DoxyCodeLine{108   \textcolor{comment}{// compute A * B' with a series of sparse dot products}}
\DoxyCodeLine{109   vertex\_id\_type row\_idx = 0;}
\DoxyCodeLine{110   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} row\_it = A.begin(); row\_it != A.end(); ++row\_it, ++row\_idx) \{}
\DoxyCodeLine{111     vertex\_id\_type col\_idx = 0;}
\DoxyCodeLine{112     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} col\_it = BT.begin(); col\_it != BT.end(); ++col\_it, ++col\_idx) \{}
\DoxyCodeLine{113       \textcolor{comment}{// std::cout << "{}Computing "{} << row\_idx << "{},"{} << col\_idx << std::endl;}}
\DoxyCodeLine{114       products.clear();}
\DoxyCodeLine{115 }
\DoxyCodeLine{116       set\_ewise\_intersection((*row\_it).begin(), (*row\_it).end(), (*col\_it).begin(), (*col\_it).end(), products,}
\DoxyCodeLine{117                              [](\textcolor{keyword}{auto}\&\& a, \textcolor{keyword}{auto}\&\& bt) -\/> \textcolor{keywordtype}{bool} \{ return std::get<0>(a) < std::get<0>(bt); \},}
\DoxyCodeLine{118                              [](\textcolor{keyword}{auto}\&\& a, \textcolor{keyword}{auto}\&\& bt) -\/> ScalarT \{ return MapOpT()(std::get<1>(a), std::get<1>(bt)); \});}
\DoxyCodeLine{119 }
\DoxyCodeLine{120       \textcolor{keywordflow}{if} (!products.empty()) \{}
\DoxyCodeLine{121         ScalarT res = std::accumulate(products.begin(), products.end(), (ScalarT)0, ReduceOpT());}
\DoxyCodeLine{122         edges.push\_back(row\_idx, col\_idx, res);}
\DoxyCodeLine{123         \textcolor{comment}{// std::cout << "{}Added element ("{} << row\_idx << "{},"{}}}
\DoxyCodeLine{124         \textcolor{comment}{//          << col\_idx << "{}) = "{} << res << std::endl;}}
\DoxyCodeLine{125         products.clear();}
\DoxyCodeLine{126       \}}
\DoxyCodeLine{127     \}}
\DoxyCodeLine{128   \}}
\DoxyCodeLine{129 }
\DoxyCodeLine{130   edges.close\_for\_push\_back();}
\DoxyCodeLine{131   \textcolor{comment}{// edges.template sort\_by<0>();  // not necessary}}
\DoxyCodeLine{132   \textcolor{keywordflow}{return} edges;}
\DoxyCodeLine{133 \}}
\DoxyCodeLine{134 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{135 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// NW\_GRAPH\_SPMATSPMAT\_HPP}}

\end{DoxyCode}
