\hypertarget{algorithms_2connected__components_8hpp_source}{}\doxysection{connected\+\_\+components.\+hpp}
\label{algorithms_2connected__components_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/connected\_components.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/algorithms/connected\_components.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//     Xu Tony Liu  }}
\DoxyCodeLine{12 \textcolor{comment}{//}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#ifndef CONNECTED\_COMPONENT\_HPP}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#define CONNECTED\_COMPONENT\_HPP}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/bfs\_edge\_range.hpp"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/edge\_range.hpp"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}nwgraph/adaptors/vertex\_range.hpp"{}}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}nwgraph/util/atomic.hpp"{}}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <unordered\_map>}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{preprocessor}{\#if defined(CL\_SYCL\_LANGUAGE\_VERSION)}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <dpstd/algorithm>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <dpstd/execution>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <execution>}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{34 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{comment}{// Verifies CC result by performing a BFS from a vertex in each component}}
\DoxyCodeLine{37 \textcolor{comment}{// -\/ Asserts search does not reach a vertex with a different component label}}
\DoxyCodeLine{38 \textcolor{comment}{// -\/ If the graph is directed, it performs the search as if it was undirected}}
\DoxyCodeLine{39 \textcolor{comment}{// -\/ Asserts every vertex is visited (degree-\/0 vertex should have own label)}}
\DoxyCodeLine{40 \textcolor{keyword}{template} <adjacency\_list\_graph Graph, \textcolor{keyword}{class} Transpose, \textcolor{keyword}{class} Vector>}
\DoxyCodeLine{41 \textcolor{keyword}{static} \textcolor{keywordtype}{bool} CCVerifier(\textcolor{keyword}{const} Graph\& graph, Transpose\&\& xpose, Vector\&\& comp) \{}
\DoxyCodeLine{42   \textcolor{keyword}{using} NodeID = \textcolor{keyword}{typename} nw::graph::vertex\_id\_t<std::decay\_t<Graph>>;}
\DoxyCodeLine{43   std::unordered\_map<NodeID, NodeID> label\_to\_source;}
\DoxyCodeLine{44   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& [n] : \mbox{\hyperlink{classplain__range}{plain\_range}}(graph)) \{}
\DoxyCodeLine{45     label\_to\_source[comp[n]] = n;}
\DoxyCodeLine{46   \}}
\DoxyCodeLine{47   std::vector<bool>   visited(graph.size() + 1);}
\DoxyCodeLine{48   std::vector<NodeID> frontier;}
\DoxyCodeLine{49   frontier.reserve(graph.size() + 1);}
\DoxyCodeLine{50   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& [curr\_label, source] : label\_to\_source) \{}
\DoxyCodeLine{51     frontier.clear();}
\DoxyCodeLine{52     frontier.push\_back(source);}
\DoxyCodeLine{53     visited[source] = \textcolor{keyword}{true};}
\DoxyCodeLine{54     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = frontier.begin(); it != frontier.end(); it++) \{}
\DoxyCodeLine{55       NodeID u = *it;}
\DoxyCodeLine{56       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& elt : graph[u]) \{}
\DoxyCodeLine{57         \textcolor{keyword}{auto} v = target(graph, elt);}
\DoxyCodeLine{58         \textcolor{keywordflow}{if} (comp[v] != curr\_label) \{}
\DoxyCodeLine{59           \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{60         \}}
\DoxyCodeLine{61         \textcolor{keywordflow}{if} (!visited[v]) \{}
\DoxyCodeLine{62           visited[v] = \textcolor{keyword}{true};}
\DoxyCodeLine{63           frontier.push\_back(v);}
\DoxyCodeLine{64         \}}
\DoxyCodeLine{65       \}}
\DoxyCodeLine{66       \textcolor{keywordflow}{if} (u < xpose.size()) \{}
\DoxyCodeLine{67         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& elt : xpose[u]) \{}
\DoxyCodeLine{68           \textcolor{keyword}{auto} v = target(xpose, elt);}
\DoxyCodeLine{69           \textcolor{keywordflow}{if} (comp[v] != curr\_label) \{}
\DoxyCodeLine{70             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{71           \}}
\DoxyCodeLine{72           \textcolor{keywordflow}{if} (!visited[v]) \{}
\DoxyCodeLine{73             visited[v] = \textcolor{keyword}{true};}
\DoxyCodeLine{74             frontier.push\_back(v);}
\DoxyCodeLine{75           \}}
\DoxyCodeLine{76         \}}
\DoxyCodeLine{77       \}}
\DoxyCodeLine{78     \}}
\DoxyCodeLine{79   \}}
\DoxyCodeLine{80   NodeID i = 0;}
\DoxyCodeLine{81   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& visited : visited) \{}
\DoxyCodeLine{82     \textcolor{keywordflow}{if} (!visited) \{}
\DoxyCodeLine{83       \textcolor{comment}{//return false;}}
\DoxyCodeLine{84       ++i;}
\DoxyCodeLine{85     \}}
\DoxyCodeLine{86   \}}
\DoxyCodeLine{87   \textcolor{keywordflow}{if} (0 < i) \{}
\DoxyCodeLine{88     std::cout << \textcolor{stringliteral}{"{}unvisited "{}} << i << \textcolor{stringliteral}{"{} "{}} << graph.size() + 1 << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{89     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{90   \}}
\DoxyCodeLine{91   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{92 \}}
\DoxyCodeLine{93 }
\DoxyCodeLine{94 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Vector, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{95 \textcolor{keyword}{static} \textcolor{keywordtype}{void} link(T u, T v, Vector\& comp) \{}
\DoxyCodeLine{96   T p1 = nw::graph::acquire(comp[u]);}
\DoxyCodeLine{97   T p2 = comp[v];}
\DoxyCodeLine{98   \textcolor{keywordflow}{while} (p1 != p2) \{}
\DoxyCodeLine{99     T high   = std::max(p1, p2);}
\DoxyCodeLine{100     T low    = p1 + (p2 -\/ high);}
\DoxyCodeLine{101     T p\_high = comp[high];}
\DoxyCodeLine{102 }
\DoxyCodeLine{103     \textcolor{keywordflow}{if} ((p\_high == low) || (p\_high == high \&\& comp[high].compare\_exchange\_strong(high, low))) \textcolor{keywordflow}{break};}
\DoxyCodeLine{104     p1 = comp[p\_high];}
\DoxyCodeLine{105     p2 = comp[low];}
\DoxyCodeLine{106   \}}
\DoxyCodeLine{107 \}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Execution, \textcolor{keyword}{typename} Vector>}
\DoxyCodeLine{110 \textcolor{keyword}{static} \textcolor{keywordtype}{void} compress(Execution exec, Vector\& comp) \{}
\DoxyCodeLine{111   std::for\_each(exec, counting\_iterator(0ul), counting\_iterator(comp.size()), [\&](\textcolor{keyword}{auto} n) \{}
\DoxyCodeLine{112     while (comp[n] != comp[comp[n]]) \{}
\DoxyCodeLine{113       auto foo = nw::graph::acquire(comp[n]);}
\DoxyCodeLine{114       auto bar = nw::graph::acquire(comp[foo]);}
\DoxyCodeLine{115       nw::graph::release(comp[n], bar);}
\DoxyCodeLine{116     \}}
\DoxyCodeLine{117   \});}
\DoxyCodeLine{118 \}}
\DoxyCodeLine{119 }
\DoxyCodeLine{120 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Vector, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{121 \textcolor{keyword}{static} T sample\_frequent\_element(\textcolor{keyword}{const} Vector\& comp, \textcolor{keywordtype}{size\_t} num\_samples = 1024) \{}
\DoxyCodeLine{122   std::unordered\_map<T, int>       counts(32);}
\DoxyCodeLine{123   std::mt19937                                  gen;}
\DoxyCodeLine{124   std::uniform\_int\_distribution<T> distribution(0, comp.size() -\/ 1);}
\DoxyCodeLine{125 }
\DoxyCodeLine{126   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < num\_samples; ++i) \{}
\DoxyCodeLine{127     T n = distribution(gen);}
\DoxyCodeLine{128     counts[comp[n]]++;}
\DoxyCodeLine{129   \}}
\DoxyCodeLine{130 }
\DoxyCodeLine{131   \textcolor{keyword}{auto}\&\& [num, count] = *std::max\_element(counts.begin(), counts.end(), [](\textcolor{keyword}{auto}\&\& a, \textcolor{keyword}{auto}\&\& b) \{ return std::get<1>(a) < std::get<1>(b); \});}
\DoxyCodeLine{132   \textcolor{keywordtype}{float} frac\_of\_graph = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(count) / num\_samples;}
\DoxyCodeLine{133   std::cout << \textcolor{stringliteral}{"{}Skipping largest intermediate component (ID: "{}} << num << \textcolor{stringliteral}{"{}, approx. "{}} << int(frac\_of\_graph * 100) << \textcolor{stringliteral}{"{}\% of the graph)\(\backslash\)n"{}};}
\DoxyCodeLine{134   \textcolor{keywordflow}{return} num;}
\DoxyCodeLine{135 \}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Execution, adjacency\_list\_graph Graph1, adjacency\_list\_graph Graph2>}
\DoxyCodeLine{138 \textcolor{keyword}{static} \textcolor{keyword}{auto} afforest(Execution\& exec, Graph1\& graph, Graph2\& t\_graph, \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} neighbor\_rounds = 2) \{}
\DoxyCodeLine{139   \textcolor{keyword}{using} vertex\_id\_type = vertex\_id\_t<Graph1>;}
\DoxyCodeLine{140   std::vector<std::atomic<vertex\_id\_type>> comp(graph.size() + 1);}
\DoxyCodeLine{141   std::for\_each(exec, counting\_iterator(0ul), counting\_iterator(comp.size()), [\&](vertex\_id\_type n) \{ comp[n] = n; \});}
\DoxyCodeLine{142   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} r = 0; r < neighbor\_rounds; ++r) \{}
\DoxyCodeLine{143     std::for\_each(exec, counting\_iterator(0ul), counting\_iterator(comp.size()), [\&](vertex\_id\_type u) \{}
\DoxyCodeLine{144       if (r < graph[u].size()) \{}
\DoxyCodeLine{145         link(u, std::get<0>(graph[u].begin()[r]), comp);}
\DoxyCodeLine{146       \}}
\DoxyCodeLine{147     \});}
\DoxyCodeLine{148     compress(exec, comp);}
\DoxyCodeLine{149   \}}
\DoxyCodeLine{150 }
\DoxyCodeLine{151   vertex\_id\_type c = sample\_frequent\_element<std::vector<std::atomic<vertex\_id\_type>>, vertex\_id\_type>(comp);}
\DoxyCodeLine{152 }
\DoxyCodeLine{153   std::for\_each(exec, counting\_iterator(0ul), counting\_iterator(comp.size()), [\&](vertex\_id\_type u) \{}
\DoxyCodeLine{154     if (comp[u] == c) return;}
\DoxyCodeLine{155 }
\DoxyCodeLine{156     if (neighbor\_rounds < graph[u].size()) \{}
\DoxyCodeLine{157       for (auto v = graph[u].begin() + neighbor\_rounds; v != graph[u].end(); ++v) \{}
\DoxyCodeLine{158         link(u, std::get<0>(*v), comp);}
\DoxyCodeLine{159       \}}
\DoxyCodeLine{160     \}}
\DoxyCodeLine{161 }
\DoxyCodeLine{162     if (t\_graph.size() != 0) \{}
\DoxyCodeLine{163       for (auto\&\& elt : t\_graph[u]) \{}
\DoxyCodeLine{164         auto v = target(t\_graph, elt);}
\DoxyCodeLine{165         link(u, v, comp);}
\DoxyCodeLine{166       \}}
\DoxyCodeLine{167     \}}
\DoxyCodeLine{168   \});}
\DoxyCodeLine{169 }
\DoxyCodeLine{170   compress(exec, comp);}
\DoxyCodeLine{171 }
\DoxyCodeLine{172   \textcolor{keywordflow}{return} comp;}
\DoxyCodeLine{173 \}}
\DoxyCodeLine{174 }
\DoxyCodeLine{175 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{176 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{177 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// CONNECTED\_COMPONENT\_HPP}}

\end{DoxyCode}
