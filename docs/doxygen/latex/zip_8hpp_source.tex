\hypertarget{zip_8hpp_source}{}\doxysection{zip.\+hpp}
\label{zip_8hpp_source}\index{/Users/lums/NWmath/NWgr/include/nwgraph/containers/zip.hpp@{/Users/lums/NWmath/NWgr/include/nwgraph/containers/zip.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// }}
\DoxyCodeLine{2 \textcolor{comment}{// This file is part of NW Graph (aka GraphPack) }}
\DoxyCodeLine{3 \textcolor{comment}{// (c) Pacific Northwest National Laboratory 2018-\/2021 }}
\DoxyCodeLine{4 \textcolor{comment}{// (c) University of Washington 2018-\/2021 }}
\DoxyCodeLine{5 \textcolor{comment}{// }}
\DoxyCodeLine{6 \textcolor{comment}{// Licensed under terms of include LICENSE file }}
\DoxyCodeLine{7 \textcolor{comment}{// }}
\DoxyCodeLine{8 \textcolor{comment}{// Authors: }}
\DoxyCodeLine{9 \textcolor{comment}{//     Andrew Lumsdaine }}
\DoxyCodeLine{10 \textcolor{comment}{//     Kevin Deweese    }}
\DoxyCodeLine{11 \textcolor{comment}{//     Luke D'Alessandro    }}
\DoxyCodeLine{12 \textcolor{comment}{//}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#ifndef NW\_GRAPH\_ZIP\_HPP}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#define NW\_GRAPH\_ZIP\_HPP}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <initializer\_list>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <istream>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include "{}nwgraph/util/arrow\_proxy.hpp"{}}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include "{}nwgraph/util/print\_types.hpp"{}}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include "{}nwgraph/util/util.hpp"{}}}
\DoxyCodeLine{33 }
\DoxyCodeLine{34 \textcolor{preprocessor}{\#if defined(CL\_SYCL\_LANGUAGE\_VERSION)}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#include <dpstd/algorithm>}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#include <dpstd/execution>}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#include <execution>}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 }
\DoxyCodeLine{43 \textcolor{preprocessor}{\#include <ranges>}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{keyword}{namespace }nw \{}
\DoxyCodeLine{47 \textcolor{keyword}{namespace }graph \{}
\DoxyCodeLine{48 }
\DoxyCodeLine{49 }
\DoxyCodeLine{50 \textcolor{comment}{// Bare bones zipper of ranges }}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{keyword}{template} <std::ranges::random\_access\_range... Ranges>}
\DoxyCodeLine{53 \textcolor{keyword}{struct }\mbox{\hyperlink{structnw_1_1graph_1_1zipped}{zipped}} : std::tuple<Ranges\&...> \{}
\DoxyCodeLine{54   \textcolor{keyword}{using} storage\_type = std::tuple<Ranges\&...>;}
\DoxyCodeLine{55   \textcolor{keyword}{using} base         = std::tuple<Ranges\&...>;}
\DoxyCodeLine{56 }
\DoxyCodeLine{57   \textcolor{keyword}{using} attributes\_t = std::tuple<std::ranges::range\_value\_t<Ranges>...>;}
\DoxyCodeLine{58   \textcolor{keyword}{using} const\_attributes\_t = std::tuple<const std::ranges::range\_value\_t<Ranges>...>;}
\DoxyCodeLine{59   \textcolor{keyword}{using} attributes\_r = std::tuple<std::ranges::range\_reference\_t<Ranges>...>;}
\DoxyCodeLine{60   \textcolor{keyword}{using} const\_attributes\_r = std::tuple<const std::ranges::range\_reference\_t<Ranges>...>;}
\DoxyCodeLine{61 }
\DoxyCodeLine{62 }
\DoxyCodeLine{63   \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} is\_const = false>}
\DoxyCodeLine{64   \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}} \{}
\DoxyCodeLine{65     \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}<!is\_const>;}
\DoxyCodeLine{66 }
\DoxyCodeLine{67     \textcolor{keyword}{using} soa\_t = std::conditional\_t<is\_const, const zipped, zipped>;}
\DoxyCodeLine{68 }
\DoxyCodeLine{69     std::size\_t i\_;}
\DoxyCodeLine{70     soa\_t*      soa\_;}
\DoxyCodeLine{71 }
\DoxyCodeLine{72   \textcolor{keyword}{public}:}
\DoxyCodeLine{73     \textcolor{keyword}{using} value\_type        = std::conditional\_t<is\_const, const\_attributes\_t, attributes\_t>;}
\DoxyCodeLine{74     \textcolor{keyword}{using} difference\_type   = std::ptrdiff\_t;}
\DoxyCodeLine{75     \textcolor{keyword}{using} reference         = std::conditional\_t<is\_const, const\_attributes\_r, attributes\_r>;}
\DoxyCodeLine{76     \textcolor{keyword}{using} \mbox{\hyperlink{structnw_1_1graph_1_1arrow__proxy}{pointer}}           = \mbox{\hyperlink{structnw_1_1graph_1_1arrow__proxy}{arrow\_proxy<reference>}};}
\DoxyCodeLine{77     \textcolor{keyword}{using} iterator\_category = std::random\_access\_iterator\_tag;}
\DoxyCodeLine{78 }
\DoxyCodeLine{79     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{80 }
\DoxyCodeLine{81     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}(soa\_t* soa, std::size\_t i = 0) : i\_(i), soa\_(soa) \{\}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}(\mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{84     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{85 }
\DoxyCodeLine{86     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator<false>}}\& b) \textcolor{keyword}{requires}(is\_const) : i\_(b.i\_), soa\_(b.soa\_) \{\}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{89     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\& operator=(\mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{90 }
\DoxyCodeLine{91     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\& operator                       =(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator<false>}}\& b) \textcolor{keyword}{requires}(is\_const) \{}
\DoxyCodeLine{92       i\_   = b.i\_;}
\DoxyCodeLine{93       soa\_ = b.soa\_;}
\DoxyCodeLine{94       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{95     \}}
\DoxyCodeLine{96 }
\DoxyCodeLine{97     \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\&) \textcolor{keyword}{const}  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{98     \textcolor{keyword}{auto} operator<=>(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\&) \textcolor{keyword}{const} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{99 }
\DoxyCodeLine{100     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}} operator++(\textcolor{keywordtype}{int}) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}(i\_++, soa\_); \}}
\DoxyCodeLine{101     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}} operator-\/-\/(\textcolor{keywordtype}{int}) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}(i\_-\/-\/, soa\_); \}}
\DoxyCodeLine{102 }
\DoxyCodeLine{103     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\& operator++() \{}
\DoxyCodeLine{104       ++i\_;}
\DoxyCodeLine{105       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{106     \}}
\DoxyCodeLine{107     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\& operator-\/-\/() \{}
\DoxyCodeLine{108       -\/-\/i\_;}
\DoxyCodeLine{109       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{110     \}}
\DoxyCodeLine{111     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\& operator+=(std::ptrdiff\_t n) \{}
\DoxyCodeLine{112       i\_ += n;}
\DoxyCodeLine{113       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{114     \}}
\DoxyCodeLine{115     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\& operator-\/=(std::ptrdiff\_t n) \{}
\DoxyCodeLine{116       i\_ -\/= n;}
\DoxyCodeLine{117       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{118     \}}
\DoxyCodeLine{119 }
\DoxyCodeLine{120     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}} operator+(std::ptrdiff\_t n)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{soa\_, i\_ + n\}; \}}
\DoxyCodeLine{121     \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}} operator-\/(std::ptrdiff\_t n)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{soa\_, i\_ -\/ n\}; \}}
\DoxyCodeLine{122 }
\DoxyCodeLine{123     \textcolor{keyword}{friend} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}} operator+(std::ptrdiff\_t n, \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}} i) \{ \textcolor{keywordflow}{return} i + n; \}}
\DoxyCodeLine{124     \textcolor{keyword}{friend} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}} operator-\/(std::ptrdiff\_t n, \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}} i) \{ \textcolor{keywordflow}{return} i -\/ n; \}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126     std::ptrdiff\_t operator-\/(\textcolor{keyword}{const} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator}}\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} i\_ -\/ b.i\_; \}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128     reference operator*()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{129       \textcolor{keywordflow}{return} std::apply(}
\DoxyCodeLine{130           [\textcolor{keyword}{this}]<\textcolor{keyword}{class}... Vectors>(Vectors \&\& ... v) \{ \textcolor{keywordflow}{return} reference(std::forward<Vectors>(v)[i\_]...); \}, *soa\_);}
\DoxyCodeLine{131     \}}
\DoxyCodeLine{132 }
\DoxyCodeLine{133     reference operator[](std::ptrdiff\_t n)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{134       \textcolor{keywordflow}{return} std::apply(}
\DoxyCodeLine{135           [\textcolor{keyword}{this}, n]<\textcolor{keyword}{class}... Vectors>(Vectors \&\& ... v) \{ \textcolor{keywordflow}{return} reference(std::forward<Vectors>(v)[i\_ + n]...); \}, *soa\_);}
\DoxyCodeLine{136     \}}
\DoxyCodeLine{137 }
\DoxyCodeLine{138     \mbox{\hyperlink{structnw_1_1graph_1_1arrow__proxy}{pointer}} operator-\/>()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{**\textcolor{keyword}{this}\}; \}}
\DoxyCodeLine{139     \mbox{\hyperlink{structnw_1_1graph_1_1arrow__proxy}{pointer}} operator-\/>() \{ \textcolor{keywordflow}{return} \{**\textcolor{keyword}{this}\}; \}}
\DoxyCodeLine{140   \};}
\DoxyCodeLine{141 }
\DoxyCodeLine{142   \textcolor{keyword}{using} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{iterator}} = \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator<false>}};}
\DoxyCodeLine{143 }
\DoxyCodeLine{144   \textcolor{keyword}{using} value\_type      = \textcolor{keyword}{typename} iterator::value\_type;}
\DoxyCodeLine{145   \textcolor{keyword}{using} reference       = \textcolor{keyword}{typename} iterator::reference;}
\DoxyCodeLine{146   \textcolor{keyword}{using} size\_type       = std::size\_t;}
\DoxyCodeLine{147   \textcolor{keyword}{using} difference\_type = \textcolor{keyword}{typename} iterator::difference\_type;}
\DoxyCodeLine{148   \textcolor{keyword}{using} pointer         = \textcolor{keyword}{typename} \mbox{\hyperlink{structnw_1_1graph_1_1arrow__proxy}{iterator::pointer}};}
\DoxyCodeLine{149 }
\DoxyCodeLine{150   \textcolor{keyword}{using} \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{const\_iterator}}  = \mbox{\hyperlink{classnw_1_1graph_1_1zipped_1_1soa__iterator}{soa\_iterator<true>}};}
\DoxyCodeLine{151   \textcolor{keyword}{using} const\_reference = \textcolor{keyword}{typename} const\_iterator::reference;}
\DoxyCodeLine{152   \textcolor{keyword}{using} const\_pointer   = \textcolor{keyword}{typename} \mbox{\hyperlink{structnw_1_1graph_1_1arrow__proxy}{const\_iterator::pointer}};}
\DoxyCodeLine{153 }
\DoxyCodeLine{154   \textcolor{keyword}{using} reverse\_iterator       = std::reverse\_iterator<iterator>;}
\DoxyCodeLine{155   \textcolor{keyword}{using} const\_reverse\_iterator = std::reverse\_iterator<const\_iterator>;}
\DoxyCodeLine{156 }
\DoxyCodeLine{157   \textcolor{comment}{//  zipped() = default;}}
\DoxyCodeLine{158 }
\DoxyCodeLine{159   \textcolor{comment}{// zipped(size\_t M) : base(std::vector<Attributes>(M)...) \{\}}}
\DoxyCodeLine{160   \textcolor{comment}{// zipped(std::initializer\_list<value\_type> l) \{}}
\DoxyCodeLine{161   \textcolor{comment}{// for\_each(l.begin(), l.end(), [\&](value\_type x) \{ push\_back(x); \});}}
\DoxyCodeLine{162   \textcolor{comment}{// \}}}
\DoxyCodeLine{163 }
\DoxyCodeLine{164 }
\DoxyCodeLine{165   \mbox{\hyperlink{structnw_1_1graph_1_1zipped}{zipped}}(Ranges\&... rs) : base(std::forward\_as\_tuple(rs...)) \{ \}}
\DoxyCodeLine{166 }
\DoxyCodeLine{167   iterator       begin() \{ \textcolor{keywordflow}{return} \{\textcolor{keyword}{this}\}; \}}
\DoxyCodeLine{168   const\_iterator begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{\textcolor{keyword}{this}\}; \}}
\DoxyCodeLine{169 }
\DoxyCodeLine{170   iterator end() \{ \textcolor{keywordflow}{return} begin() + size(); \}}
\DoxyCodeLine{171 }
\DoxyCodeLine{172   const\_iterator end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} begin() + size(); \}}
\DoxyCodeLine{173 }
\DoxyCodeLine{174   reference operator[](std::size\_t i) \{}
\DoxyCodeLine{175     \textcolor{keywordflow}{return} std::apply([\&](\textcolor{keyword}{auto}\&\&... r) \{ \textcolor{keywordflow}{return} std::forward\_as\_tuple(std::forward<\textcolor{keyword}{decltype}(r)>(r)[i]...); \}, *\textcolor{keyword}{this});}
\DoxyCodeLine{176   \}}
\DoxyCodeLine{177 }
\DoxyCodeLine{178   const\_reference operator[](std::size\_t i)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{179     \textcolor{keywordflow}{return} std::apply([\&](\textcolor{keyword}{auto}\&\&... r) \{ \textcolor{keywordflow}{return} std::forward\_as\_tuple(std::forward<\textcolor{keyword}{decltype}(r)>(r)[i]...); \}, *\textcolor{keyword}{this});}
\DoxyCodeLine{180   \}}
\DoxyCodeLine{181 }
\DoxyCodeLine{182 }
\DoxyCodeLine{183 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{184   \textcolor{keywordtype}{void} push\_back(Attributes... attrs) \{}
\DoxyCodeLine{185     std::apply([\&](\textcolor{keyword}{auto}\&... vs) \{ (vs.push\_back(attrs), ...); \}, *\textcolor{keyword}{this});}
\DoxyCodeLine{186   \}}
\DoxyCodeLine{187 }
\DoxyCodeLine{188   \textcolor{keywordtype}{void} push\_back(std::tuple<Attributes...> attrs) \{}
\DoxyCodeLine{189     std::apply([\&](Attributes... attr) \{ push\_back(attr...); \}, attrs);}
\DoxyCodeLine{190   \}}
\DoxyCodeLine{191 }
\DoxyCodeLine{192   \textcolor{keywordtype}{void} push\_at(std::size\_t i, Attributes... attrs) \{}
\DoxyCodeLine{193     std::apply([\&](\textcolor{keyword}{auto}\&... vs) \{ ((vs[i] = attrs), ...); \}, *\textcolor{keyword}{this});}
\DoxyCodeLine{194   \}}
\DoxyCodeLine{195 }
\DoxyCodeLine{196   \textcolor{keywordtype}{void} push\_at(std::size\_t i, std::tuple<Attributes...> attrs) \{}
\DoxyCodeLine{197     std::apply([\&](Attributes... attr) \{ push\_at(i, attr...); \}, attrs);}
\DoxyCodeLine{198   \}}
\DoxyCodeLine{199 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{200 }
\DoxyCodeLine{201   \textcolor{keywordtype}{void} clear() \{}
\DoxyCodeLine{202     std::apply([\&](\textcolor{keyword}{auto}\&... vs) \{ (vs.clear(), ...); \}, *\textcolor{keyword}{this});}
\DoxyCodeLine{203   \}}
\DoxyCodeLine{204 }
\DoxyCodeLine{205   \textcolor{keywordtype}{void} resize(\textcolor{keywordtype}{size\_t} N) \{}
\DoxyCodeLine{206     std::apply([\&](\textcolor{keyword}{auto}\&\&... vs) \{ (vs.resize(N), ...); \}, *\textcolor{keyword}{this});}
\DoxyCodeLine{207   \}}
\DoxyCodeLine{208 }
\DoxyCodeLine{209   \textcolor{keywordtype}{void} reserve(\textcolor{keywordtype}{size\_t} N) \{}
\DoxyCodeLine{210     std::apply([\&](\textcolor{keyword}{auto}\&\&... vs) \{ (vs.reserve(N), ...); \}, *\textcolor{keyword}{this});}
\DoxyCodeLine{211   \}}
\DoxyCodeLine{212 }
\DoxyCodeLine{213   \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{214   \textcolor{keywordtype}{void} serialize(std::ostream\& outfile, \textcolor{keyword}{const} T\& vs)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{215     \textcolor{keywordtype}{size\_t} st\_size = vs.size();}
\DoxyCodeLine{216     \textcolor{keywordtype}{size\_t} el\_size = \textcolor{keyword}{sizeof}(vs[0]);}
\DoxyCodeLine{217     outfile.write(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&st\_size), \textcolor{keyword}{sizeof}(size\_t));}
\DoxyCodeLine{218     outfile.write(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&el\_size), \textcolor{keyword}{sizeof}(size\_t));}
\DoxyCodeLine{219     outfile.write(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(vs.data()), st\_size * el\_size);}
\DoxyCodeLine{220   \}}
\DoxyCodeLine{221 }
\DoxyCodeLine{222   \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{223   \textcolor{keywordtype}{void} deserialize(std::istream\& infile, T\& vs) \{}
\DoxyCodeLine{224     \textcolor{keywordtype}{size\_t} st\_size = -\/1;}
\DoxyCodeLine{225     \textcolor{keywordtype}{size\_t} el\_size = -\/1;}
\DoxyCodeLine{226     infile.read(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&st\_size), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));}
\DoxyCodeLine{227     infile.read(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&el\_size), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));}
\DoxyCodeLine{228     infile.read(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(vs.data()), st\_size * el\_size);}
\DoxyCodeLine{229   \}}
\DoxyCodeLine{230 }
\DoxyCodeLine{231   \textcolor{keywordtype}{void} serialize(std::ostream\& outfile)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{232     \textcolor{keywordtype}{size\_t} st\_size = std::get<0>(*this).size();}
\DoxyCodeLine{233     \textcolor{keywordtype}{size\_t} el\_size = std::tuple\_size<storage\_type>::value;}
\DoxyCodeLine{234     outfile.write(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&st\_size), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));}
\DoxyCodeLine{235     outfile.write(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&el\_size), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));}
\DoxyCodeLine{236     std::apply([\&](\textcolor{keyword}{auto}\&... vs) \{ (serialize(outfile, vs), ...); \}, *\textcolor{keyword}{this});}
\DoxyCodeLine{237   \}}
\DoxyCodeLine{238 }
\DoxyCodeLine{239   \textcolor{keywordtype}{void} deserialize(std::istream\& infile) \{}
\DoxyCodeLine{240     \textcolor{keywordtype}{size\_t} st\_size = -\/1;}
\DoxyCodeLine{241     \textcolor{keywordtype}{size\_t} el\_size = -\/1;}
\DoxyCodeLine{242     infile.read(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&st\_size), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));}
\DoxyCodeLine{243     infile.read(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&el\_size), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{size\_t}));}
\DoxyCodeLine{244     resize(st\_size);}
\DoxyCodeLine{245     std::apply([\&](\textcolor{keyword}{auto}\&... vs) \{ (deserialize(infile, vs), ...); \}, *\textcolor{keyword}{this});}
\DoxyCodeLine{246   \}}
\DoxyCodeLine{247 }
\DoxyCodeLine{248   \textcolor{keyword}{template} <\textcolor{keyword}{typename} index\_t, \textcolor{keyword}{typename} vertex\_\textcolor{keywordtype}{id}\_type, \textcolor{keyword}{class} T, \textcolor{keyword}{class} ExecutionPolicy = std::execution::parallel\_unsequenced\_policy>}
\DoxyCodeLine{249   \textcolor{keywordtype}{void} permute(\textcolor{keyword}{const} std::vector<index\_t>\& indices, \textcolor{keyword}{const} std::vector<index\_t>\& new\_indices, \textcolor{keyword}{const} std::vector<vertex\_id\_type>\& perm, T\& vs,}
\DoxyCodeLine{250                ExecutionPolicy\&\& ex\_policy = \{\}) \{}
\DoxyCodeLine{251     T ws(vs.size());}
\DoxyCodeLine{252     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0, e = indices.size() -\/ 1; i < e; ++i) \{}
\DoxyCodeLine{253       vertex\_id\_type j = perm[i];}
\DoxyCodeLine{254       std::copy(ex\_policy, vs.begin() + indices[j], vs.begin() + indices[j + 1], ws.begin() + new\_indices[i]);}
\DoxyCodeLine{255     \}}
\DoxyCodeLine{256     std::copy(ex\_policy, ws.begin(), ws.end(), vs.begin());}
\DoxyCodeLine{257   \}}
\DoxyCodeLine{258 }
\DoxyCodeLine{259   \textcolor{keyword}{template} <\textcolor{keyword}{typename} index\_t, \textcolor{keyword}{typename} vertex\_\textcolor{keywordtype}{id}\_type>}
\DoxyCodeLine{260   \textcolor{keywordtype}{void} permute(\textcolor{keyword}{const} std::vector<index\_t>\& indices, \textcolor{keyword}{const} std::vector<index\_t>\& new\_indices, \textcolor{keyword}{const} std::vector<vertex\_id\_type>\& perm) \{}
\DoxyCodeLine{261     std::apply([\&](\textcolor{keyword}{auto}\&... vs) \{ (permute(indices, new\_indices, perm, vs), ...); \}, *\textcolor{keyword}{this});}
\DoxyCodeLine{262   \}}
\DoxyCodeLine{263 }
\DoxyCodeLine{264   \textcolor{keywordtype}{size\_t} size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::get<0>(*this).size(); \}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266   \textcolor{keywordtype}{bool} operator==(zipped\& a) \{ \textcolor{keywordflow}{return} std::equal(std::execution::par, begin(), end(), a.begin()); \}}
\DoxyCodeLine{267 }
\DoxyCodeLine{268   \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} storage\_type\& a) \{ \textcolor{keywordflow}{return} !operator==(a); \}}
\DoxyCodeLine{269 \};}
\DoxyCodeLine{270 }
\DoxyCodeLine{271 }
\DoxyCodeLine{272 \textcolor{keyword}{template} <std::ranges::random\_access\_range... Ranges>}
\DoxyCodeLine{273 zipped<Ranges...> make\_zipped(Ranges\&... rs) \{}
\DoxyCodeLine{274   \textcolor{keywordflow}{return} \{ rs... \};}
\DoxyCodeLine{275 \}}
\DoxyCodeLine{276 }
\DoxyCodeLine{277 \textcolor{keyword}{template} <std::ranges::random\_access\_range... Ranges>}
\DoxyCodeLine{278 zipped<Ranges...> make\_zipped(Ranges\&\&... rs) \{}
\DoxyCodeLine{279   \textcolor{keywordflow}{return} \{ rs... \};}
\DoxyCodeLine{280 \}}
\DoxyCodeLine{281 }
\DoxyCodeLine{282 }
\DoxyCodeLine{283 }
\DoxyCodeLine{284 }
\DoxyCodeLine{285 }
\DoxyCodeLine{286 }
\DoxyCodeLine{287 \}    \textcolor{comment}{// namespace graph}}
\DoxyCodeLine{288 \}    \textcolor{comment}{// namespace nw}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 \textcolor{keyword}{namespace }std \{}
\DoxyCodeLine{291 }
\DoxyCodeLine{292 }
\DoxyCodeLine{293 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{294 \textcolor{keyword}{template} <std::ranges::random\_access\_range... Ranges>}
\DoxyCodeLine{295 \textcolor{keyword}{auto} iter\_swap(\textcolor{keyword}{typename} \mbox{\hyperlink{structnw_1_1graph_1_1zipped}{nw::graph::zipped<Ranges...>::soa\_iterator<false>}} a, \textcolor{keyword}{typename} \mbox{\hyperlink{structnw_1_1graph_1_1zipped}{nw::graph::zipped<Ranges...>::soa\_iterator<false>}} b) \{}
\DoxyCodeLine{296   \textcolor{keyword}{auto} tmp = *a;}
\DoxyCodeLine{297   *a = *b;}
\DoxyCodeLine{298   *b = *tmp;}
\DoxyCodeLine{299 \}}
\DoxyCodeLine{300 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{301 }
\DoxyCodeLine{302 }
\DoxyCodeLine{303 \textcolor{keyword}{template} <\textcolor{keyword}{class}... Attributes>}
\DoxyCodeLine{304 \textcolor{keyword}{class }tuple\_size<nw::graph::zipped<Attributes...>> : \textcolor{keyword}{public} std::integral\_constant<std::size\_t, sizeof...(Attributes)> \{\};}
\DoxyCodeLine{305 }
\DoxyCodeLine{306 \}    \textcolor{comment}{// namespace std}}
\DoxyCodeLine{307 }
\DoxyCodeLine{308 }
\DoxyCodeLine{311 \textcolor{preprocessor}{\#include "{}nwgraph/util/tuple\_hack.hpp"{}}}
\DoxyCodeLine{312 }
\DoxyCodeLine{313 }
\DoxyCodeLine{314 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{315 \textcolor{keyword}{namespace }std \{}
\DoxyCodeLine{316 }
\DoxyCodeLine{317 \textcolor{keyword}{template} <std::ranges::random\_access\_range... Ranges, std::size\_t... Is>}
\DoxyCodeLine{318 \textcolor{keywordtype}{void} swap(\textcolor{keyword}{typename} nw::graph::zipped<Ranges...>::iterator::reference\&\& x, \textcolor{keyword}{typename} nw::graph::zipped<Ranges...>::iterator::reference\&\& y, std::index\_sequence<Is...>) \{}
\DoxyCodeLine{319   \textcolor{keyword}{using} std::swap;}
\DoxyCodeLine{320   }
\DoxyCodeLine{321   (swap(std::get<Is>(x), std::get<Is>(y)), ...);}
\DoxyCodeLine{322 \}}
\DoxyCodeLine{323 }
\DoxyCodeLine{324 \textcolor{keyword}{template} <std::ranges::random\_access\_range... Ranges>}
\DoxyCodeLine{325 \textcolor{keywordtype}{void} swap(\textcolor{keyword}{typename} nw::graph::zipped<Ranges...>::iterator::reference\&\& x, \textcolor{keyword}{typename} nw::graph::zipped<Ranges...>::iterator::reference\&\& y) \{}
\DoxyCodeLine{326   swap(std::move(x), std::move(y), std::make\_index\_sequence<\textcolor{keyword}{sizeof}...(Ranges)>());}
\DoxyCodeLine{327 \}}
\DoxyCodeLine{328 }
\DoxyCodeLine{329 \} }
\DoxyCodeLine{330 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{331 }
\DoxyCodeLine{332 }
\DoxyCodeLine{333 }
\DoxyCodeLine{334 }
\DoxyCodeLine{335 \textcolor{preprocessor}{\#endif    }\textcolor{comment}{// NW\_GRAPH\_ZIP\_HPP}}

\end{DoxyCode}
