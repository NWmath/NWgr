
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Graph Background &#8212; NW Graph 0.10.15 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx13.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"RR": "{\\mathbb R}", "Real": "{\\mathbb R}", "Complex": "{\\mathbb C}", "mat": ["{\\mathbf{#1}}", 1], "vec": ["{\\mathbf{#1}}", 1], "bold": ["{\\bf #1}", 1], "Spc": ["\\mathbb{#1}", 1], "norm": ["|| #1 ||", 1]}}})</script>

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="canonical" href="http://www.sphinx-doc.org/en/master/userguide/graph-background.html" />

    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="../usage/installation.html">Get it</a></li>
    <li><a href="../contents.html">Docs</a></li>
    <li><a href="../develop.html">Extend/Develop</a></li>
  </ul>
  <div>
    <a href="../index.html">
      <img src="../_static/nwgraph.png" alt="NW Graph" height="96px"/>
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../index.html">NW Graph home</a>&#160;|</li>
        <li><a href="../contents.html">Documentation</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Graph Background</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Graph Background</a><ul>
<li><a class="reference internal" href="#graph-terminology">Graph Terminology</a></li>
<li><a class="reference internal" href="#graph-models">Graph Models</a></li>
<li><a class="reference internal" href="#representing-graphs">Representing Graphs</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/userguide/graph-background.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="graph-background">
<span id="sec-graph-background"></span><h1>Graph Background<a class="headerlink" href="#graph-background" title="Permalink to this headline">¶</a></h1>
<p>In order to describe the NWGraph library and its abstractions and
interfaces, it is important to be precise about what we mean when we say
“graph,” not only in terms of the mathematical abstraction, but also in
terms of the corresponding software abstractions. To define our
terminology and to amplify our point regarding “graphs are not for
storing data,” we walk through the steps involved in representing the
implicit relationships in data tables as a graph.</p>
<p><strong>Remark.</strong> Understanding graphs is necessary to develop requirements
for algorithms. However, it should be noted that we don’t derive those
requirements from the graph model, but instead from the algorithms. This
is a key distinction between generic programming and, say, OO
requirements analysis.</p>
<section id="graph-terminology">
<span id="sec-graph-terminology"></span><h2>Graph Terminology<a class="headerlink" href="#graph-terminology" title="Permalink to this headline">¶</a></h2>
<p>Abstractly, we define a <em>graph</em> <span class="math notranslate nohighlight">\(G\)</span> as comprising two finite sets,
<span class="math notranslate nohighlight">\(G =\{ V, E \}\)</span>, where the set <span class="math notranslate nohighlight">\(V\)</span> is a set of entities of
interest, “vertices” or “nodes,” and <span class="math notranslate nohighlight">\(E\)</span> is a set of pairs of
entities from <span class="math notranslate nohighlight">\(V\)</span>, “edges” or “links.” Without loss of generality
we label the entities in <span class="math notranslate nohighlight">\(V\)</span> as <span class="math notranslate nohighlight">\(v_i\)</span> so that
<span class="math notranslate nohighlight">\(V = \{ v_0, v_1, \ldots v_{n-1} \}\)</span>. The set of edges, also
labeled, can be constructed using the labeled entities from <span class="math notranslate nohighlight">\(V\)</span> so
that <span class="math notranslate nohighlight">\(E = \{ e_0, e_1, \ldots e_{m-1} \}\)</span>. The edges may be
ordered pairs, denoted as <span class="math notranslate nohighlight">\((v_i, v_j)\)</span>, which have equality
defined such that
<span class="math notranslate nohighlight">\((v_i,v_j) = (v_m,v_n) \leftrightarrow v_i = v_m  \wedge v_j = v_n\)</span>.
Or, the edges may be unordered sets, denoted as <span class="math notranslate nohighlight">\(\{v_i, v_j\}\)</span>
which have equality defined as
<span class="math notranslate nohighlight">\((v_i,v_j) = (v_m,v_n) \leftrightarrow\left( v_i = v_m  \wedge v_j = v_n\right) \vee \left( v_i = v_n  \wedge v_j = v_m\right)\)</span>.
If a graph is defined with ordered edges we say the graph is <em>directed</em>;
if the graph is defined with unordered edges we say the graph is
<em>undirected</em>.</p>
</section>
<section id="graph-models">
<h2>Graph Models<a class="headerlink" href="#graph-models" title="Permalink to this headline">¶</a></h2>
<p>Graphs are powerful abstractions because they allow us to reason about
the relationships between entities, irrespective of what the entities
actually are. But, when we use graph algorithms in practice, we are
using them to model some specific problem. Since one of the motivations
behind NWGraph is to support graph computing in the context of real
programs, we briefly describe the first part of the abstraction process
when modeling with graphs.</p>
<p>Fig. <a class="reference external" href="#fig:graph-model-circuit">1</a> shows a model of an electrical
circuit as a directed graph, both schematically, as a circle and line
diagram, and mathematically, as the sets <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(E\)</span>.
Two-terminal circuit elements connect to each other at given circuit
nodes. We thus model circuit connection points as graph vertices, and
the connections between them as edges. In the case of circuits,
orientation of circuit elements matters and so we use directed edges in
the graph.</p>
<p>Fig. <a class="reference external" href="#fig:graph-model-airports">2</a> similarly shows a model of an
airport route table as an undirected graph. We begin with a table of
airports and a table of distances in kilometers between pairs of
airports. We model this situation as a graph by identifying graph nodes
with airports and graph edges with pairs of cities that are given as
pairs in the distance table.</p>
</section>
<section id="representing-graphs">
<span id="sec-representing-graphs"></span><h2>Representing Graphs<a class="headerlink" href="#representing-graphs" title="Permalink to this headline">¶</a></h2>
<p>To define algorithms on graphs and to be able to reason about those
algorithms, we need to define some representations for graphs (and
corresponding terminology)—–not much can be done computationally with
abstract sets of vertices and edges. Various characteristics of these
representations are what we use to express algorithms (still abstractly)
but when those algorithms are implemented as generic library functions,
those characteristics will in turn become the basis for the library’s
concepts.</p>
<div class="figure docutils container">
<a class="reference internal image-reference" href="userguide/circuit_index_graph_with_vit.pdf"><img alt="image" src="userguide/circuit_index_graph_with_vit.pdf" style="width: 90.0%;" /></a>
</div>
<div class="figure docutils container">
<a class="reference internal image-reference" href="userguide/airport_index_graph_with_vit.pdf"><img alt="image" src="userguide/airport_index_graph_with_vit.pdf" style="width: 90.0%;" /></a>
</div>
<p>One of the fundamental operations in graph algorithms is a <em>traversal</em>.
That is, given a vertex <span class="math notranslate nohighlight">\(u\)</span>, we would like to find the <em>neighbors</em>
of <span class="math notranslate nohighlight">\(u\)</span>, i.e., all vertices <span class="math notranslate nohighlight">\(v\)</span> such that the edge
<span class="math notranslate nohighlight">\((u,v)\)</span> is in the graph. Then, for each of those edges, we would
like to find their neighbors, and so on. The representation that we can
define to make this efficient is an <em>adjacency list</em>.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G = (V,E)\)</span>, we can define an adjacency-list
representation in the following way. Assign to each element of <span class="math notranslate nohighlight">\(V\)</span>
a unique index from the range <span class="math notranslate nohighlight">\([0,|V|)\)</span> and denote the vertex
identified with index <span class="math notranslate nohighlight">\(i\)</span> as <span class="math notranslate nohighlight">\(V[i]\)</span>. We can now define a new
graph with the same structure as <span class="math notranslate nohighlight">\(G\)</span>, but in terms of the indices
in <span class="math notranslate nohighlight">\([0,|V|)\)</span>, rather than with the elements in <span class="math notranslate nohighlight">\(V\)</span>. Let the
<em>index graph of</em> <span class="math notranslate nohighlight">\(G\)</span> be the graph <span class="math notranslate nohighlight">\(G'=(V',E')\)</span>, where
<span class="math notranslate nohighlight">\(V'=[0,|V|)\)</span> and <span class="math notranslate nohighlight">\(E'\)</span> consists of <span class="math notranslate nohighlight">\(|E|\)</span> pairs of
indices from <span class="math notranslate nohighlight">\(V\)</span>, such that a pair <span class="math notranslate nohighlight">\((i,j)\)</span> is in E’ if and
only if <span class="math notranslate nohighlight">\((V[i],V[j])\)</span> is in <span class="math notranslate nohighlight">\(E\)</span>. Which is all to say, the
index graph of <span class="math notranslate nohighlight">\(G\)</span> is the graph we get by replacing all elements
of <span class="math notranslate nohighlight">\(G\)</span> with their corresponding indices.
Figs. <a class="reference external" href="#fig:circuit_index_to_adj">[fig:circuit_index_to_adj]</a>
and <a class="reference external" href="#fig:airport_index_to_adj">[fig:airport_index_to_adj]</a> show the
progression from an index graph to an index adjacency list (compare also
to Figs. <a class="reference external" href="#fig:graph-model-circuit">1</a>
and <a class="reference external" href="#fig:graph-model-airports">2</a>). Since edges are given in terms
of vertex names, in order to create a list of edge indices, we need to
translate from vertex name to vertex index. Accordingly,
Figs. <a class="reference external" href="#fig:graph-model-circuit">1</a>
and <a class="reference external" href="#fig:graph-model-airports">2</a> also show the translation table
from vertex to index.</p>
<p>Of course, we don’t need an underlying graph to define what an index
graph itself is. We can say that a graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is an index
graph if its vertex set is a set of contiguous indices, i.e., with
<span class="math notranslate nohighlight">\(V=[0,|V|-1)\)</span>. Since an index graph is just a graph, in cases
where the context is clear, we may refer to an index graph simply as a
graph. We note that an adjacency list can only be defined over an index
graph.</p>
<p>Finally, we can make the following precise definition: An <em>adjacency
list</em> of an index graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> is an array <span class="math notranslate nohighlight">\(Adj(G)\)</span> of
size <span class="math notranslate nohighlight">\(|V|\)</span> (the array is indexed from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(|V|-1\)</span>)
with the following properties:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Adj(G)\)</span> is a container of <span class="math notranslate nohighlight">\(|V|\)</span> containers, one
container for each vertex in <span class="math notranslate nohighlight">\(V\)</span>, and</p></li>
<li><p>The container <span class="math notranslate nohighlight">\(Adj(G)[u]\)</span> contains all vertices <span class="math notranslate nohighlight">\(v\)</span> for
which there is an edge <span class="math notranslate nohighlight">\((u,v)\in E\)</span>.</p></li>
</ul>
<p>This structure, <strong>an adjacency list of an index graph, or an index
adjacency list, is the fundamental structure used by almost all graph
algorithms.</strong> and show the index graph and the adjacency list
representation of our airport and circuit examples.</p>
<p><strong>Remark (1):</strong> Although the standard term for this kind of abstraction
is “adjacency list”, and although it is often drawn schematically with
linked lists as elements, it is not necessary that this abstraction be
implemented as an actual linked list. In fact, other representations are
significantly more efficient. <strong>What is important is that the items that
are stored, vertex indices, can be used to index into the adjacency list
to obtain other lists of neighbors.</strong></p>
<p><strong>Remark (2):</strong> The index adjacency list does not store edges per se,
rather it stores lists of reachable neighbors. Therefore, the index
adjacency list is neither inherently directed nor undirected. That is,
for a given vertex <span class="math notranslate nohighlight">\(u\)</span>, the container <span class="math notranslate nohighlight">\(Adj(G)[u]\)</span> contains
the vertex <span class="math notranslate nohighlight">\(v\)</span> if the edge <span class="math notranslate nohighlight">\((u,v)\)</span> is contained in
<span class="math notranslate nohighlight">\(E\)</span>. This means that for a directed graph with edge <span class="math notranslate nohighlight">\((u,v)\)</span>
in , <span class="math notranslate nohighlight">\(E\)</span>, <span class="math notranslate nohighlight">\(Adj(G)[u]\)</span> will contain <span class="math notranslate nohighlight">\(v\)</span>. For an
undirected graph with edge <span class="math notranslate nohighlight">\((u,v)\)</span> is contained in <span class="math notranslate nohighlight">\(E\)</span>,
<span class="math notranslate nohighlight">\(Adj(G)[u]\)</span> will contain <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(Adj(G)[v]\)</span> will
contain <span class="math notranslate nohighlight">\(u\)</span>. <strong>Directedness of the original graph is thus made
manifest in the values stored in the index adjacency list.</strong></p>
<p>Compare, for instance, the adjacency lists in
Figs. <a class="reference external" href="#fig:circuit_index_to_adj">[fig:circuit_index_to_adj]</a>
and <a class="reference external" href="#fig:airport_index_to_adj">[fig:airport_index_to_adj]</a>. The
graphs have the same structure in the schematics and in the mathematical
notations (shown in Figs. <a class="reference external" href="#fig:graph-model-circuit">1</a>
and <a class="reference external" href="#fig:graph-model-airports">2</a>). However, when realized as
adjacency list, the adjacency list in
Fig. <a class="reference external" href="#fig:graph-model-airports">2</a> is symmetrized. Every edge
<span class="math notranslate nohighlight">\(\{u,v\}\)</span> in the graph is inserted twice into the adjacency list:
once as <span class="math notranslate nohighlight">\(\{u,v\}\)</span> and once as <span class="math notranslate nohighlight">\(\{v,u\}\)</span>.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../index.html">NW Graph home</a>&#160;|</li>
        <li><a href="../contents.html">Documentation</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Graph Background</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, PNNL, UW.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.0.
    </div>
  </body>
</html>