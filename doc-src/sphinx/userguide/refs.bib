

@techreport{STL,
  author =        {Alexander Stepanov and Meng Lee},
  institution =   {HP Laboratories},
  month =         {November},
  number =        {HPL-95-11},
  title =         {The Standard Template Library},
  year =          {1995},
}

@book{stepanov2014mathematics,
  author =        {Stepanov, Alexander A and Rose, Daniel E},
  publisher =     {Pearson Education},
  title =         {From mathematics to generic programming},
  year =          {2014},
}

@incollection{Musser89,
  author =        {David R. Musser and Alexander A. Stepanov},
  booktitle =     {International Symposium ISSAC 1988},
  editor =        {P Gianni},
  pages =         {13--25},
  publisher =     {Springer-Verlag},
  series =        {Lecture Notes in Computer Science},
  title =         {Generic Programming},
  volume =        {38},
  year =          {1989},
}

@misc{conorconcepts,
  author =        {{Conor Hoekstra}},
  title =         {{C++ Concepts vs Rust Traits vs Haskell Typeclasses
                   vs Swift Protocols}},
  year =          {2021},
  url =           {https://www.youtube.com/watch?v=iPVoCTgvi8M},
}

@article{bernardy2010generic,
  author =        {Bernardy, Jean-Philippe and Jansson, Patrik and
                   Zalewski, Marcin and Schupp, Sibylle},
  journal =       {Journal of Functional Programming},
  number =        {3-4},
  pages =         {271--302},
  title =         {Generic programming with c++ concepts and haskell
                   type classes—a comparison},
  volume =        {20},
  year =          {2010},
}

@inproceedings{garcia03:_comparative_study,
  address =       {New York, NY, USA},
  author =        {Garcia, Ronald and Jarvi, Jaakko and
                   Lumsdaine, Andrew and Siek, Jeremy G. and
                   Willcock, Jeremiah},
  booktitle =     {Proceedings of the 18th Annual ACM SIGPLAN Conference
                   on Object-Oriented Programing, Systems, Languages,
                   and Applications},
  pages =         {115–134},
  publisher =     {Association for Computing Machinery},
  series =        {OOPSLA '03},
  title =         {A Comparative Study of Language Support for Generic
                   Programming},
  year =          {2003},
  abstract =      {Many modern programming languages support basic
                   generic programming, sufficient to implement
                   type-safe polymorphic containers. Some languages have
                   moved beyond this basic support to a broader, more
                   powerful interpretation of generic programming, and
                   their extensions have proven valuable in practice.
                   This paper reports on a comprehensive comparison of
                   generics in six programming languages: C++, Standard
                   ML, Haskell, Eiffel, Java (with its proposed generics
                   extension), and Generic C. By implementing a
                   substantial example in each of these languages, we
                   identify eight language features that support this
                   broader view of generic programming. We find these
                   features are necessary to avoid awkward designs, poor
                   maintainability, unnecessary run-time checks, and
                   painfully verbose code. As languages increasingly
                   support generics, it is important that language
                   designers understand the features necessary to
                   provide powerful generics and that their absence
                   causes serious difficulties for programmers.},
  doi =           {10.1145/949305.949317},
  isbn =          {1581137125},
  url =           {https://doi.org/10.1145/949305.949317},
}

@article{garcia07:_extended_comparative_study,
  author =        {Garcia, Ronald and Jarvi, Jaakko and
                   Lumsdaine, Andrew and Siek, Jeremy and
                   Willcock, Jeremiah},
  journal =       {Journal of Functional Programming},
  number =        {2},
  pages =         {145–205},
  publisher =     {Cambridge University Press},
  title =         {An extended comparative study of language support for
                   generic programming},
  volume =        {17},
  year =          {2007},
  doi =           {10.1017/S0956796806006198},
}

@techreport{niebler2018one,
  author =        {Niebler, Eric and Carter, Casey and
                   Di Bella, Christopher},
  institution =   {Tech. rep. P0896r4. Nov. 2018. url: http://www.
                   open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.
                   pdf},
  title =         {The One Ranges Proposal},
  year =          {2018},
}

@book{cormen2009introduction,
  author =        {Cormen, Thomas H and Leiserson, Charles E and
                   Rivest, Ronald L and Stein, Clifford},
  publisher =     {MIT press},
  title =         {Introduction to algorithms},
  year =          {2009},
}

@techreport{_tag_invoke,
  author =        {Lewis Baker and Eric Niebler and Kirk Shoop},
  institution =   {JTC1},
  number =        {P1895R0},
  title =         {: tag\_invoke: A general pattern for supporting
                   customisable functions},
  year =          {2019},
  url =           {},
}

@book{Cormen_2009,
  author =        {Thomas H. Cormen and Charles E. Leiserson and
                   Ronald L. Rivest and Clifford Stein},
  edition =       {3rd ed},
  publisher =     {MIT Press},
  title =         {Introduction to algorithms},
  year =          {2009},
  isbn =          {978-0-262-03384-8},
}

@article{Beamer-DOBFS,
  author =        {Scott Beamer and Krste Asanovi\'{c} and
                   David A. Patterson},
  journal =       {Proceedings of the International Conference for High
                   Performance Computing, Networking, Storage and
                   Analysis (SC)},
  title =         {Direction-Optimizing Breadth-First Search},
  year =          {2012},
}

@article{MEYER2003114,
  author =        {Ulrich Meyer and Peter Sanders},
  journal =       {Journal of Algorithms},
  note =          {1998 European Symposium on Algorithms},
  number =        {1},
  pages =         {114 - 152},
  title =         {{$\Delta$}-stepping: a parallelizable shortest path
                   algorithm},
  volume =        {49},
  year =          {2003},
  abstract =      {The single source shortest path problem for arbitrary
                   directed graphs with n nodes, m edges and nonnegative
                   edge weights can sequentially be solved using $O(n
                   \log n + m)$ operations. However, no work-efficient
                   parallel algorithm is known that runs in sublinear
                   time for arbitrary graphs. In this paper we present a
                   rather simple algorithm for the single source
                   shortest path problem. Our new algorithm, which we
                   call Delta-stepping, can be implemented very
                   efficiently in sequential and parallel setting for a
                   large class of graphs. For random edge weights and
                   arbitrary graphs with maximum node degree d,
                   sequential Δ-stepping needs $O(n+m+dL)$ total
                   average-case time, where L denotes the maximum
                   shortest path weight from the source node s to any
                   node reachable from s. For example, this means linear
                   time on directed graphs with constant maximum degree.
                   Our best parallel version for a PRAM takes $O(dL \log
                   n+ \log^2n)$ time and $O(n+m+dL\log n)$ work on
                   average. For random graphs, even O(log2n) time and
                   O(n+m) work on average can be achieved. We also
                   discuss how the algorithm can be adapted to work with
                   nonrandom edge weights and how it can be implemented
                   on distributed memory machines. Experiments indicate
                   that already a simple implementation of the algorithm
                   achieves significant speedup on real machines.},
  doi =           {https://doi.org/10.1016/S0196-6774(03)00076-2},
  issn =          {0196-6774},
  url =           {http://www.sciencedirect.com/science/article/pii/
                  S0196677403000762},
}

@inproceedings{boykov01:_exper_compar_min_cut_max,
  author       = {Boykov, Yuri and Kolmogorov, Vladimir},
  title	       = {An Experimental Comparison of Min-Cut/Max-Flow Algorithms for Energy
                  Minimization in Vision},
  year	       = 2001,
  isbn	       = 3540425233,
  publisher    = {Springer-Verlag},
  address      = {Berlin, Heidelberg},
  booktitle    = {Proceedings of the Third International Workshop on Energy
                  Minimization Methods in Computer Vision and Pattern Recognition},
  pages	       = {359–374},
  numpages     = 16,
  series       = {EMMCVPR '01}
}

@inproceedings{sutton2018optimizing,
  author =        {Sutton, Michael and Ben-Nun, Tal and Barak, Amnon},
  booktitle =     {{IPDPS}},
  organization =  {IEEE},
  pages =         {12--21},
  title =         {Optimizing parallel graph connectivity computation
                   via subgraph sampling},
  year =          {2018},
}

@techreport{shiloach1980log,
  author =        {Shiloach, Yossi and Vishkin, Uzi},
  institution =   {Computer Science Department, Technion},
  title =         {An {O}(log n) parallel connectivity algorithm},
  year =          {1980},
}

@inproceedings{shun_simple_2014,
  author =        {Shun, J. and Dhulipala, L. and Blelloch, G.},
  booktitle =     {Proceedings of the 26th {ACM} Symposium on
                   Parallelism in Algorithms and Architectures},
  pages =         {143--153},
  publisher =     {{ACM}},
  series =        {{SPAA} '14},
  title =         {A Simple and Practical Linear-work Parallel Algorithm
                   for Connectivity},
  year =          {2014},
  abstract =      {Graph connectivity is a fundamental problem in
                   computer science with many important applications.
                   Sequentially, connectivity can be done in linear work
                   easily using breadth-first search or depth-first
                   search. There have been many parallel algorithms for
                   connectivity, however the simpler parallel algorithms
                   require super-linear work, and the linear-work
                   polylogarithmic-depth parallel algorithms are very
                   complicated and not amenable to implementation. In
                   this work, we address this gap by describing a simple
                   and practical expected linear-work, polylogarithmic
                   depth parallel algorithm for graph connectivity. Our
                   algorithm is based on a recent parallel algorithm for
                   generating low-diameter graph decompositions by
                   Miller et al., which uses parallel breadth-first
                   searches. We discuss a (modest) variant of their
                   decomposition algorithm which preserves the
                   theoretical complexity while leading to simpler and
                   faster implementations. We experimentally compare the
                   connectivity algorithms using both the original
                   decomposition algorithm and our modified
                   decomposition algorithm. We also experimentally
                   compare against the fastest existing parallel
                   connectivity implementations (which are not
                   theoretically linear-work and polylogarithmic-depth)
                   and show that our implementations are competitive for
                   various input graphs. In addition, we compare our
                   implementations to sequential connectivity algorithms
                   and show that on 40 cores we achieve good speedup
                   relative to the sequential implementations for many
                   input graphs. We discuss the various optimizations
                   used in our implementations and present an extensive
                   experimental analysis of the performance. Our
                   algorithm is the first parallel connectivity
                   algorithm that is both theoretically and practically
                   efficient.},
  doi =           {10.1145/2612669.2612692},
  isbn =          {978-1-4503-2821-0},
  url =           {http://doi.acm.org/10.1145/2612669.2612692},
}

@phdthesis{orzan_distributed_2004,
  author =        {Orzan, S. M.},
  month =         nov,
  school =        {VRIJE UNIVERSITEIT},
  type =          {Ph.D. thesis},
  title =         {On Distributed Verification and Verified
                   Distribution},
  year =          {2004},
  url =           {http://dare.ubvu.vu.nl/handle/1871/10338},
}

@article{yan_pregel_2014,
  author =        {Yan, Da and Cheng, James and Xing, Kai and Lu, Yi and
                   Ng, Wilfred and Bu, Yingyi},
  journal =       {Proc. {VLDB} Endow.},
  number =        {14},
  pages =         {1821--1832},
  title =         {Pregel Algorithms for Graph Connectivity Problems
                   with Performance Guarantees},
  volume =        {7},
  year =          {2014},
  abstract =      {Graphs in real life applications are often huge, such
                   as the Web graph and various social networks. These
                   massive graphs are often stored and processed in
                   distributed sites. In this paper, we study graph
                   algorithms that adopt Google's Pregel, an iterative
                   vertex-centric framework for graph processing in the
                   Cloud. We first identify a set of desirable
                   properties of an efficient Pregel algorithm, such as
                   linear space, communication and computation cost per
                   iteration, and logarithmic number of iterations. We
                   define such an algorithm as a practical Pregel
                   algorithm ({PPA}). We then propose {PPAs} for
                   computing connected components ({CCs}), biconnected
                   components ({BCCs}) and strongly connected components
                   ({SCCs}). The {PPAs} for computing {BCCs} and {SCCs}
                   use the {PPAs} of many fundamental graph problems as
                   building blocks, which are of interest by themselves.
                   Extensive experiments over large real graphs verified
                   the efficiency of our algorithms.},
  doi =           {10.14778/2733085.2733089},
  issn =          {2150-8097},
  url =           {http://dx.doi.org/10.14778/2733085.2733089},
}

@inproceedings{arasu2002pagerank,
  author =        {Arasu, Arvind and Novak, Jasmine and Tomkins, Andrew and
                   Tomlin, John},
  booktitle =     {WWW},
  pages =         {107--117},
  title =         {{PageRank} computation and the structure of the web:
                   {E}xperiments and algorithms},
  year =          {2002},
}

@inproceedings{triangle_lumsdaine_2020,
  author =        {Andrew {Lumsdaine} and Luke {Dalessandro} and
                   Kevin {Deweese} and Jesun {Firoz} and
                   Scott {McMillan}},
  booktitle =     {2020 IEEE High Performance Extreme Computing
                   Conference (HPEC)},
  number =        {},
  pages =         {1-8},
  title =         {Triangle Counting with Cyclic Distributions},
  volume =        {},
  year =          {2020},
  doi =           {10.1109/HPEC43674.2020.9286220},
}

@article{brandes_bc,
  author =        {Ulrik Brandes},
  journal =       {The Journal of Mathematical Sociology},
  number =        {2},
  pages =         {163-177},
  publisher =     {Routledge},
  title =         {A faster algorithm for betweenness centrality},
  volume =        {25},
  year =          {2001},
  abstract =      {Motivated by the fast‐growing need to compute
                   centrality indices on large, yet very sparse,
                   networks, new algorithms for betweenness are
                   introduced in this paper. They require $O(n + m)$
                   space and run in $O(nm))$ and $O(nm + n^2 \log n)$
                   time on unweighted and weighted networks,
                   respectively, where m is the number of links.
                   Experimental evidence is provided that this
                   substantially increases the range of networks for
                   which centrality analysis is feasible. The
                   betweenness centrality index is essential in the
                   analysis of social networks, but costly to compute.
                   Currently, the fastest known algorithms require
                   $Theta(n^3)$ time and $Theta(n^2)$ space, where n is
                   the number of actors in the network.},
  doi =           {10.1080/0022250X.2001.9990249},
  url =           {https://doi.org/10.1080/0022250X.2001.9990249},
}

@article{jones1993parallel,
  author =        {Jones, Mark T and Plassmann, Paul E},
  journal =       {SIAM Journal on Scientific Computing},
  number =        {3},
  pages =         {654--669},
  publisher =     {SIAM},
  title =         {A parallel graph coloring heuristic},
  volume =        {14},
  year =          {1993},
}

@book{Siek_Lee_Lumsdaine_2002,
  author =        {Siek, Jeremy G. and Lee, Lie-Quan and
                   Lumsdaine, Andrew},
  publisher =     {Addison-Wesley},
  title =         {The Boost Graph Library: User Guide and Reference
                   Manual},
  year =          {2002},
}

@misc{dimacs9th,
  howpublished =  {{\tt http://www.dis.uniroma1.it/challenge9/}},
  key =           {DIMACS},
  title =         {9th {DIMACS} Implementation Challenge - {S}hortest
                   Paths.},
  year =          {2006},
}

@article{Twitter,
  author =        {Haewoon Kwak and Changhyun Lee and Hosung Park and
                   Sue Moon},
  journal =       {{WWW}},
  title =         {What is {Twitter}, a Social Network or a News Media?},
  year =          {2010},
}

@article{LAW1,
  author =        {Paolo Boldi and Sebastiano Vigna},
  journal =       {WWW},
  pages =         {595--601},
  title =         {The {W}eb{G}raph Framework {I}: Compression
                   Techniques},
  year =          {2004},
}

@inproceedings{Graph500,
  author =        {Murphy, Richard C. and Wheeler, Kyle B. and
                   Barrett, Brian W and Ang, James A.},
  booktitle =     {Cray User's Group},
  organization =  {CUG},
  title =         {Introducing the {G}raph 500},
  year =          {2010},
}

@article{Erdos,
  author =        {Paul Erd\H{o}s and Alfr\'{e}d R\'{e}nyi},
  journal =       {Publicationes Mathematicae},
  pages =         {290--297},
  title =         {On Random Graphs. {I}},
  volume =        {6},
  year =          {1959},
}

@article{GAP,
  author =        {Beamer, Scott and Asanovi\'{c}, Krste and
                   Patterson, David},
  journal =       {arXiv preprint arXiv:1508.03919},
  title =         {The {GAP} {B}enchmark {S}uite},
  year =          {2015},
}

@inproceedings{kulkarni2007,
  author =        {Kulkarni, Milind and Pingali, Keshav and
                   Walter, Bruce and Ramanarayanan, Ganesh and
                   Bala, Kavita and Chew, L. Paul},
  booktitle =     {{PLDI}},
  pages =         {211--222},
  publisher =     {ACM},
  title =         {Optimistic Parallelism Requires Abstractions},
  year =          {2007},
  doi =           {10.1145/1250734.1250759},
  url =           {https://doi.org/10.1145/1250734.1250759},
}

@article{graphit:2018,
  author =        {Zhang, Yunming and Yang, Mengjiao and
                   Baghdadi, Riyadh and Kamil, Shoaib and Shun, Julian and
                   Amarasinghe, Saman},
  journal =       {PACMPL/OOPSLA},
  month =         oct,
  pages =         {121:1--121:30},
  title =         {{GraphIt}: {A} High-performance Graph {DSL}},
  volume =        {2},
  year =          {2018},
}

@misc{tbbrepo,
  author =        {{Intel}},
  title =         {{Intel Threading Building Blocks (TBB)}},
  year =          {2020},
  url =           {https://github.com/oneapi-src/oneTBB},
}

@article{dezsHo2011lemon,
  author =        {Dezs{\H{o}}, Bal{\'a}zs and J{\"u}ttner, Alp{\'a}r and
                   Kov{\'a}cs, P{\'e}ter},
  journal =       {Electronic Notes in Theoretical Computer Science},
  number =        {5},
  pages =         {23--45},
  publisher =     {Elsevier},
  title =         {LEMON--an open source C++ graph template library},
  volume =        {264},
  year =          {2011},
}

@inproceedings{mattson2019lagraph,
  author =        {Mattson, Tim and Davis, Timothy A. and Kumar, Manoj and
                   Buluc, Aydin and McMillan, Scott and
                   Moreira, Jos{\'e} and Yang, Carl},
  booktitle =     {{GrAPL} at {IPDPS}},
  organization =  {IEEE},
  pages =         {276--284},
  title =         {{LAGraph}: {A} community effort to collect graph
                   algorithms built on top of the {GraphBLAS}},
  year =          {2019},
}

@inproceedings{zhang2016gbtl,
  author =        {Zhang, Peter and Zalewski, Marcin and
                   Lumsdaine, Andrew and Misurda, Samantha and
                   McMillan, Scott},
  booktitle =     {{GABB} at {IPDPS}},
  organization =  {IEEE},
  pages =         {912--920},
  title =         {{GBTL-CUDA}: Graph algorithms and primitives for
                   {GPU}s},
  year =          {2016},
}

@inproceedings{mathgraphblas16,
  author =        {Jeremy Kepner and Peter Aaltonen and David Bader and
                   Ayd{\i}n Bulu\c{c} and Franz Franchetti and
                   John Gilbert and Dylan Hutchison and Manoj Kumar and
                   Andrew Lumsdaine and Henning Meyerhenke and
                   Scott McMillan and Jos{\'e} Moreira and John Owens and
                   Carl Yang and Marcin Zalewski and Timothy Mattson},
  booktitle =     {HPEC},
  publisher =     {IEEE},
  title =         {Mathematical Foundations of the {GraphBLAS}},
  year =          {2016},
}

@inproceedings{SciPyProceedings_11,
  address =       {Pasadena, CA USA},
  author =        {Aric A. Hagberg and Daniel A. Schult and
                   Pieter J. Swart},
  booktitle =     {Proceedings of the 7th Python in Science Conference},
  editor =        {Ga\"el Varoquaux and Travis Vaught and
                   Jarrod Millman},
  pages =         {11 - 15},
  title =         {Exploring Network Structure, Dynamics, and Function
                   using NetworkX},
  year =          {2008},
}

@article{staudt_sazonovs_meyerhenke_2016,
  author =        {Staudt, Christian L. and Sazonovs, Aleksejs and
                   Meyerhenke, Henning},
  journal =       {Network Science},
  number =        {4},
  pages =         {508–530},
  publisher =     {Cambridge University Press},
  title =         {NetworKit: A tool suite for large-scale complex
                   network analysis},
  volume =        {4},
  year =          {2016},
  doi =           {10.1017/nws.2016.20},
}

@inproceedings{Lifting_douglas_2005,
  address =       {New York, NY, USA},
  author =        {Gregor, Douglas and Lumsdaine, Andrew},
  booktitle =     {Proceedings of the 20th Annual ACM SIGPLAN Conference
                   on Object-Oriented Programming, Systems, Languages,
                   and Applications},
  pages =         {423–437},
  publisher =     {Association for Computing Machinery},
  series =        {OOPSLA '05},
  title =         {Lifting Sequential Graph Algorithms for
                   Distributed-Memory Parallel Computation},
  year =          {2005},
  abstract =      {This paper describes the process used to extend the
                   Boost Graph Library (BGL) for parallel operation with
                   distributed memory. The BGL consists of a rich set of
                   generic graph algorithms and supporting data
                   structures, but it was not originally designed with
                   parallelism in mind. In this paper, we revisit the
                   abstractions comprising the BGL in the context of
                   distributed-memory parallelism, lifting away the
                   implicit requirements of sequential execution and a
                   single shared address space. We illustrate our
                   approach by describing the process as applied to one
                   of the core algorithms in the BGL, breadth-first
                   search. The result is a generic algorithm that is
                   unchanged from the sequential algorithm, requiring
                   only the introduction of external (distributed) data
                   structures for parallel execution. More importantly,
                   the generic implementation retains its interface and
                   semantics, such that other distributed algorithms can
                   be built upon it, just as algorithms are layered in
                   the sequential case. By characterizing these
                   extensions as well as the extension process, we
                   develop general principles and patterns for using
                   (and reusing) generic, object-oriented parallel
                   software libraries. We demonstrate that the resulting
                   algorithm implementations are both efficient and
                   scalable with performance results for several
                   algorithms.},
  doi =           {10.1145/1094811.1094844},
  isbn =          {1595930310},
  url =           {https://doi.org/10.1145/1094811.1094844},
}

@inproceedings{shunppopp13,
  address =       {New York, NY, USA},
  author =        {Shun, Julian and Blelloch, Guy E.},
  booktitle =     {Proceedings of the 18th ACM SIGPLAN Symposium on
                   Principles and Practice of Parallel Programming},
  pages =         {135–146},
  publisher =     {Association for Computing Machinery},
  series =        {PPoPP ’13},
  title =         {Ligra: A Lightweight Graph Processing Framework for
                   Shared Memory},
  year =          {2013},
  doi =           {10.1145/2442516.2442530},
  isbn =          {9781450319225},
  url =           {https://doi.org/10.1145/2442516.2442530},
}

@book{shaposhnik_practical_2015,
  address =       {New York},
  author =        {Shaposhnik, Roman and Martella, Claudio and
                   Logothetis, Dionysios},
  edition =       {1st ed. edition},
  month =         oct,
  publisher =     {Apress},
  title =         {Practical {Graph} {Analytics} with {Apache} {Giraph}},
  year =          {2015},
  abstract =      {Practical Graph Analytics with Apache Giraph helps
                   you build data mining and machine learning
                   applications using the Apache Foundation’s Giraph
                   framework for graph processing. This is the same
                   framework as used by Facebook, Google, and other
                   social media analytics operations to derive business
                   value from vast amounts of interconnected data
                   points. Graphs arise in a wealth of data scenarios
                   and describe the connections that are naturally
                   formed in both digital and real worlds. Examples of
                   such connections abound in online social networks
                   such as Facebook and Twitter, among users who rate
                   movies from services like Netflix and Amazon Prime,
                   and are useful even in the context of biological
                   networks for scientific research. Whether in the
                   context of business or science, viewing data as
                   connected adds value by increasing the amount of
                   information available to be drawn from that data and
                   put to use in generating new revenue or scientific
                   opportunities. Apache Giraph offers a simple yet
                   flexible programming model targeted to graph
                   algorithms and designed to scale easily to
                   accommodate massive amounts of data. Originally
                   developed at Yahoo!, Giraph is now a top top-level
                   project at the Apache Foundation, and it enlists
                   contributors from companies such as Facebook,
                   LinkedIn, and Twitter. Practical Graph Analytics with
                   Apache Giraph brings the power of Apache Giraph to
                   you, showing how to harness the power of graph
                   processing for your own data by building
                   sophisticated graph analytics applications using the
                   very same framework that is relied upon by some of
                   the largest players in the industry today.},
  isbn =          {978-1-4842-1252-3},
  language =      {English},
}

@inproceedings{wang2016gunrock,
  author =        {Wang, Yangzihao and Davidson, Andrew and Pan, Yuechao and
                   Wu, Yuduo and Riffel, Andy and Owens, John D.},
  booktitle =     {{PPoPP}},
  title =         {Gunrock: {A} high-performance graph processing
                   library on the {GPU}},
  year =          {2016},
}

@inproceedings{og2020,
  author =        {Zhang, Yunming and Brahmakshatriya, Ajay and
                   Chen, Xinyi and Dhulipala, Laxman and Kamil, Shoaib and
                   Amarasinghe, Saman and Shun, Julian},
  booktitle =     {CGO},
  pages =         {158–170},
  publisher =     {ACM},
  title =         {Optimizing Ordered Graph Algorithms with {GraphIt}},
  year =          {2020},
  doi =           {10.1145/3368826.3377909},
  url =           {https://doi.org/10.1145/3368826.3377909},
}

@inproceedings{azad2020evaluation,
  author =        {Azad, Ariful and Aznaveh, Mohsen Mahmoudi and
                   Beamer, Scott and Blanco, Mark and Chen, Jinhao and
                   D'Alessandro, Luke and Dathathri, Roshan and
                   Davis, Tim and Deweese, Kevin and Firoz, Jesun and
                   others},
  booktitle =     {2020 IEEE International Symposium on Workload
                   Characterization (IISWC)},
  organization =  {IEEE},
  pages =         {216--227},
  title =         {Evaluation of Graph Analytics Frameworks Using the
                   GAP Benchmark Suite},
  year =          {2020},
}

